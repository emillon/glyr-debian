From: Etienne Millon <me@emillon.org>
Subject: Revert "Updated the sourcecode with astyle to reflect my current taste."
Origin: Upstream

This patch incorporate two upstream commits (f6800dde, 302c35e9) necessary to
make the project build again.
---
diff --git a/lib/blacklist.c b/lib/blacklist.c
index 19de76c..93a2c18 100644
--- a/lib/blacklist.c
+++ b/lib/blacklist.c
@@ -23,41 +23,43 @@
 
 /////////////////////////////////
 
-GHashTable *lookup_table = NULL;
-gchar *blacklist_array[] = {
+GHashTable * lookup_table = NULL;
+gchar * blacklist_array[] =
+{
     "http://ecx.images-amazon.com/images/I/11J2DMYABHL.jpg",       /* blank image */
     "http://cdn.recordshopx.com/cover/normal/5/53/53138.jpg%3Fcd"  /* blank image */
 };
 
 /////////////////////////////////
 
-void blacklist_build(void)
+void blacklist_build (void)
 {
-    lookup_table = g_hash_table_new(g_str_hash, g_str_equal);
-    gint b_size = sizeof(blacklist_array) / sizeof(gchar *);
-    for(gint it = 0; it < b_size; it++) {
-        if(blacklist_array[it] != NULL) {
-            g_hash_table_insert(lookup_table, blacklist_array[it], blacklist_array[it]);
+    lookup_table = g_hash_table_new (g_str_hash,g_str_equal);
+    gint b_size = sizeof (blacklist_array) / sizeof (gchar *);
+    for (gint it = 0; it < b_size; it++)
+    {
+        if (blacklist_array[it] != NULL)
+        {
+            g_hash_table_insert (lookup_table,blacklist_array[it],blacklist_array[it]);
         }
     }
 }
 
 /////////////////////////////////
 
-void blacklist_destroy(void)
+void blacklist_destroy (void)
 {
-    g_hash_table_destroy(lookup_table);
+    g_hash_table_destroy (lookup_table);
 }
 
 /////////////////////////////////
 
-gboolean is_blacklisted(gchar *URL)
+gboolean is_blacklisted (gchar * URL)
 {
-    if(lookup_table == NULL || URL == NULL) {
+    if (lookup_table == NULL || URL == NULL)
         return FALSE;
-    }
 
-    return !(g_hash_table_lookup(lookup_table, URL) == NULL);
+    return ! (g_hash_table_lookup (lookup_table,URL) == NULL);
 }
 
 /////////////////////////////////
diff --git a/lib/cache.c b/lib/cache.c
index 92bdc3c..8a777ad 100644
--- a/lib/cache.c
+++ b/lib/cache.c
@@ -26,7 +26,8 @@
 
 ///////////////////////////////
 
-enum {
+enum
+{
     SQL_TABLE_DEF,
     SQL_FOREACH,
     SQL_DELETE_SELECT,
@@ -35,7 +36,8 @@ enum {
     SQL_INSERT_CACHE
 };
 
-static const char *sqlcode[] = {
+static const char * sqlcode[] =
+{
     [SQL_TABLE_DEF] =
     "PRAGMA synchronous = 1;                                                     \n"
     "PRAGMA temp_store = 2;                                                      \n"
@@ -75,7 +77,7 @@ static const char *sqlcode[] = {
     "CREATE INDEX IF NOT EXISTS index_title_id    ON metadata(title_id);         \n"
     "CREATE INDEX IF NOT EXISTS index_provider_id ON metadata(provider_id);      \n"
     "CREATE UNIQUE INDEX IF NOT EXISTS index_unique                              \n"
-    "       ON metadata(get_type, ata_type, ata_checksum,source_url);            \n"
+    "       ON metadata(get_type,data_type,data_checksum,source_url);            \n"
     "-- Insert imageformats                                                      \n"
     "INSERT OR IGNORE INTO image_types VALUES('jpeg');                           \n"
     "INSERT OR IGNORE INTO image_types VALUES('jpg');                            \n"
@@ -169,7 +171,7 @@ static const char *sqlcode[] = {
     "  (SELECT rowid FROM providers WHERE provider_name = LOWER('%q')),    \n"
     "  ?,                                                                  \n"
     "  (SELECT rowid FROM image_types WHERE image_type_name = LOWER('%q')),\n"
-    "  ?, , , , , , , ,                                                    \n"
+    "  ?,?,?,?,?,?,?,?,?                                                   \n"
     ");                                                                    \n"
 };
 
@@ -177,30 +179,30 @@ static const char *sqlcode[] = {
 ////////////////////// Prototypes //////////////////////
 ////////////////////////////////////////////////////////
 
-static void insert_cache_data(GlyrDatabase *db, GlyrQuery *query, GlyrMemCache *cache);
-static void execute(GlyrDatabase *db, const gchar *sql_statement);
-static gchar *convert_from_option_to_sql(GlyrQuery *q);
+static void insert_cache_data (GlyrDatabase * db, GlyrQuery * query, GlyrMemCache * cache);
+static void execute (GlyrDatabase * db, const gchar * sql_statement);
+static gchar * convert_from_option_to_sql (GlyrQuery * q);
 
-static double get_current_time(void);
-static void add_to_cache_list(GlyrMemCache **list, GlyrMemCache *to_add);
+static double get_current_time (void);
+static void add_to_cache_list (GlyrMemCache ** list, GlyrMemCache * to_add);
 
-static int delete_callback(void *result, int argc, char **argv, char **azColName);
-static int select_callback(void *result, int argc, char **argv, char **azColName);
+static int delete_callback (void * result, int argc, char ** argv, char ** azColName);
+static int select_callback (void * result, int argc, char ** argv, char ** azColName);
 
 
 ////////////////////////////////////////////////////////
 ////////////////// Useful Defines //////////////////////
 ////////////////////////////////////////////////////////
 
-#define INSERT_STRING(SQL, RG) {                        \
+#define INSERT_STRING(SQL,ARG) {                        \
         if(SQL && ARG) {                                    \
             /* We have to use _ascii_ here,                   */\
             /* since there seems to be some encoding problems */\
             /* in SQLite, which are triggered by comparing    */\
             /* lower and highercase umlauts for example       */\
             /* Simple encoding-indepent lowercase prevents it */\
-            gchar * lower_str = g_ascii_strdown(ARG, 1);    \
-            gchar * sql = sqlite3_mprintf(SQL, ower_str);   \
+            gchar * lower_str = g_ascii_strdown(ARG,-1);    \
+            gchar * sql = sqlite3_mprintf(SQL,lower_str);   \
             execute(db,sql);                                \
             sqlite3_free(sql);                              \
             g_free(lower_str);                              \
@@ -210,9 +212,9 @@ static int select_callback(void *result, int argc, char **argv, char **azColName
 ////////////////////////////////////////////////////////
 
 /* Ensure no invalid data comes in */
-#define ABORT_ON_FAILED_REQS(REQS, PT_ARG, RG) {                   \
+#define ABORT_ON_FAILED_REQS(REQS,OPT_ARG,ARG) {                   \
         if((REQS & OPT_ARG) == 0 && ARG == NULL) {                     \
-            glyr_message(-1, ULL, Warning: %s != NULL failed", ARG);   \
+            glyr_message(-1,NULL,"Warning: %s != NULL failed",#ARG);   \
             goto rollback;                                             \
         }                                                              \
     }
@@ -227,10 +229,10 @@ static int select_callback(void *result, int argc, char **argv, char **azColName
         /* lower and highercase umlauts for example       */                 \
         /* Simple encoding-indepent lowercase prevents it */                 \
         \
-        gchar * lower = g_ascii_strdown(VARNAME, 1);                         \
+        gchar * lower = g_ascii_strdown(VARNAME,-1);                         \
         if(lower != NULL)                                                    \
         {                                                                    \
-            TO_CONSTR = sqlite3_mprintf("AND %s = '%q'\n", IELDNAME, ower);  \
+            TO_CONSTR = sqlite3_mprintf("AND %s = '%q'\n",FIELDNAME,lower);  \
             g_free(lower);                                                   \
         }                                                                    \
     }
@@ -241,16 +243,16 @@ static int select_callback(void *result, int argc, char **argv, char **azColName
 
 ////////////////////////////////////////////////////////
 
-#define SQL_BIND_TEXT(stmt, ext, os) {                                               \
+#define SQL_BIND_TEXT(stmt,text,pos) {                                               \
         int cpPos = pos;                                                                 \
         if(stmt && text) {                                                               \
-            int rc = sqlite3_bind_text(stmt, pPos, ext,strlen(text) + 1, SQLITE_STATIC); \
+            int rc = sqlite3_bind_text(stmt,cpPos,text,strlen(text) + 1, SQLITE_STATIC); \
             if(rc != SQLITE_OK) {                                                        \
-                printf("Could not bind value: %d\n", c);                                 \
+                printf("Could not bind value: %d\n",rc);                                 \
             }                                                                            \
         }                                                                                \
     }                                                                                    \
- 
+     
 ////////////////////////////////////////////////////////
 
 /* How long to wait till returning SQLITE_BUSY */
@@ -259,7 +261,7 @@ static int select_callback(void *result, int argc, char **argv, char **azColName
 #define DO_PROFILE false
 
 #if DO_PROFILE
-static GTimer *select_callback_timer = NULL;
+static GTimer * select_callback_timer = NULL;
 static float select_callback_spent = 0;
 #endif
 
@@ -267,20 +269,22 @@ static float select_callback_spent = 0;
 ////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////
 
-typedef struct {
-    GlyrDatabase *con;
+typedef struct
+{
+    GlyrDatabase * con;
     gint deleted;
     gint max_delete;
 
 } delete_callback_data;
 
 
-typedef struct {
-    GlyrMemCache **result;
-    GlyrQuery *query;
+typedef struct
+{
+    GlyrMemCache ** result;
+    GlyrQuery * query;
     gint counter;
     glyr_foreach_callback cb;
-    void *userptr;
+    void * userptr;
 
 } select_callback_data;
 
@@ -288,56 +292,66 @@ typedef struct {
 ////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////
 
-__attribute__((visibility("default")))
-GlyrDatabase *glyr_db_init(const char *root_path)
+__attribute__ ( (visibility ("default") ) )
+GlyrDatabase * glyr_db_init (const char * root_path)
 {
-    GlyrDatabase *to_return = NULL;
+    GlyrDatabase * to_return = NULL;
 
 #if DO_PROFILE
-    GTimer *open_db = g_timer_new();
+    GTimer * open_db = g_timer_new();
     select_callback_timer = g_timer_new();
 #endif
 
-    if(sqlite3_threadsafe() == FALSE) {
-        glyr_message(-1, NULL, "WARNING: Your SQLite version seems not to be threadsafe? \n"
-                     "         Expect corrupted data and other weird behaviour!\n");
+    if (sqlite3_threadsafe() == FALSE)
+    {
+        glyr_message (-1,NULL,"WARNING: Your SQLite version seems not to be threadsafe? \n"
+                      "         Expect corrupted data and other weird behaviour!\n");
     }
 
-    if(root_path != NULL && g_file_test(root_path, G_FILE_TEST_EXISTS)) {
-        sqlite3 *db_connection = NULL;
+    if (root_path != NULL && g_file_test (root_path,G_FILE_TEST_EXISTS) )
+    {
+        sqlite3 * db_connection = NULL;
 
-        if(g_file_test(root_path, G_FILE_TEST_IS_DIR)) {
-            gchar *db_file_path = g_strdup_printf("%s%s%s", root_path,
-                                                  (g_str_has_suffix(root_path, G_DIR_SEPARATOR_S) ? "" : G_DIR_SEPARATOR_S),
-                                                  GLYR_DB_FILENAME);
+        if (g_file_test (root_path,G_FILE_TEST_IS_DIR) )
+        {
+            gchar * db_file_path = g_strdup_printf ("%s%s%s",root_path,
+                                                    (g_str_has_suffix (root_path,G_DIR_SEPARATOR_S) ? "" : G_DIR_SEPARATOR_S),
+                                                    GLYR_DB_FILENAME);
 
-            gint db_open_err = sqlite3_open_v2(db_file_path, &db_connection,
-                                               SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX,
-                                               NULL);
+            gint db_open_err = sqlite3_open_v2 (db_file_path,&db_connection,
+                                                SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX,
+                                                NULL);
 
-            if(db_open_err == SQLITE_OK) {
-                to_return = g_malloc0(sizeof(GlyrDatabase));
-                to_return->root_path = g_strdup(root_path);
+            if (db_open_err == SQLITE_OK)
+            {
+                to_return = g_malloc0 (sizeof (GlyrDatabase) );
+                to_return->root_path = g_strdup (root_path);
                 to_return->db_handle = db_connection;
-                sqlite3_busy_timeout(db_connection, DB_BUSY_WAIT);
+                sqlite3_busy_timeout (db_connection,DB_BUSY_WAIT);
 
                 /* Now create the Tables via sql */
-                execute(to_return, (char *) sqlcode[SQL_TABLE_DEF]);
-            } else {
-                glyr_message(-1, NULL, "Connecting to database failed: %s\n", sqlite3_errmsg(db_connection));
-                sqlite3_close(db_connection);
+                execute (to_return, (char*) sqlcode[SQL_TABLE_DEF]);
+            }
+            else
+            {
+                glyr_message (-1,NULL,"Connecting to database failed: %s\n",sqlite3_errmsg (db_connection) );
+                sqlite3_close (db_connection);
             }
-            g_free(db_file_path);
-        } else {
-            glyr_message(-1, NULL, "Warning: %s is not a directory; Creating DB Structure failed.\n", root_path);
+            g_free (db_file_path);
+        }
+        else
+        {
+            glyr_message (-1,NULL,"Warning: %s is not a directory; Creating DB Structure failed.\n",root_path);
         }
-    } else {
-        glyr_message(-1, NULL, "Warning: %s does not exist; Creating DB Structure failed.\n", root_path);
+    }
+    else
+    {
+        glyr_message (-1,NULL,"Warning: %s does not exist; Creating DB Structure failed.\n",root_path);
     }
 
 #if DO_PROFILE
-    g_message("Time to open DB: %lf\n", g_timer_elapsed(open_db, NULL));
-    g_timer_destroy(open_db);
+    g_message ("Time to open DB: %lf\n",g_timer_elapsed (open_db,NULL) );
+    g_timer_destroy (open_db);
 #endif
     return to_return;
 }
@@ -347,16 +361,20 @@ GlyrDatabase *glyr_db_init(const char *root_path)
 ////////////////////////////////////
 
 
-__attribute__((visibility("default")))
-void glyr_db_destroy(GlyrDatabase *db_object)
+__attribute__ ( (visibility ("default") ) )
+void glyr_db_destroy (GlyrDatabase * db_object)
 {
-    if(db_object != NULL) {
-        int db_err = sqlite3_close(db_object->db_handle);
-        if(db_err == SQLITE_OK) {
-            g_free((gchar *) db_object->root_path);
-            g_free(db_object);
-        } else {
-            glyr_message(-1, NULL, "Disconnecting database failed: %s\n", sqlite3_errmsg(db_object->db_handle));
+    if (db_object != NULL)
+    {
+        int db_err = sqlite3_close (db_object->db_handle);
+        if (db_err == SQLITE_OK)
+        {
+            g_free ( (gchar*) db_object->root_path);
+            g_free (db_object);
+        }
+        else
+        {
+            glyr_message (-1,NULL,"Disconnecting database failed: %s\n",sqlite3_errmsg (db_object->db_handle) );
         }
     }
 }
@@ -365,15 +383,18 @@ void glyr_db_destroy(GlyrDatabase *db_object)
 ////////////////////////////////////
 ////////////////////////////////////
 
-__attribute__((visibility("default")))
-int glyr_db_edit(GlyrDatabase *db, GlyrQuery *query, GlyrMemCache *edited)
+__attribute__ ( (visibility ("default") ) )
+int glyr_db_edit (GlyrDatabase * db, GlyrQuery * query, GlyrMemCache * edited)
 {
     int result = 0;
-    if(db && query) {
-        result = glyr_db_delete(db, query);
-        if(result != 0) {
-            for(GlyrMemCache *elem = edited; elem; elem = elem->next) {
-                glyr_db_insert(db, query, edited);
+    if (db && query)
+    {
+        result = glyr_db_delete (db,query);
+        if (result != 0)
+        {
+            for (GlyrMemCache * elem = edited; elem; elem = elem->next)
+            {
+                glyr_db_insert (db,query,edited);
             }
         }
     }
@@ -384,23 +405,26 @@ int glyr_db_edit(GlyrDatabase *db, GlyrQuery *query, GlyrMemCache *edited)
 ////////////////////////////////////
 ////////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_db_replace(GlyrDatabase *db, unsigned char *md5sum, GlyrQuery *query, GlyrMemCache *data)
+__attribute__ ( (visibility ("default") ) )
+void glyr_db_replace (GlyrDatabase * db, unsigned char * md5sum, GlyrQuery * query, GlyrMemCache * data)
 {
-    if(db != NULL && md5sum != NULL) {
-        gchar *sql = "DELETE FROM metadata WHERE data_checksum = ? ;\n";
+    if (db != NULL && md5sum != NULL)
+    {
+        gchar * sql = "DELETE FROM metadata WHERE data_checksum = ? ;\n";
         sqlite3_stmt *stmt = NULL;
-        sqlite3_prepare_v2(db->db_handle, sql, strlen(sql) + 1, &stmt, NULL);
-        sqlite3_bind_blob(stmt, 1, md5sum, 16, SQLITE_STATIC);
+        sqlite3_prepare_v2 (db->db_handle, sql, strlen (sql) + 1, &stmt, NULL);
+        sqlite3_bind_blob (stmt, 1, md5sum, 16, SQLITE_STATIC);
 
-        if(sqlite3_step(stmt) != SQLITE_DONE) {
-            glyr_message(1, query, "Error message: %s\n", sqlite3_errmsg(db->db_handle));
+        if (sqlite3_step (stmt) != SQLITE_DONE)
+        {
+            glyr_message (1,query,"Error message: %s\n", sqlite3_errmsg (db->db_handle) );
         }
 
-        sqlite3_finalize(stmt);
+        sqlite3_finalize (stmt);
 
-        if(data != NULL) {
-            glyr_db_insert(db, query, data);
+        if (data != NULL)
+        {
+            glyr_db_insert (db,query,data);
         }
     }
 }
@@ -410,67 +434,77 @@ void glyr_db_replace(GlyrDatabase *db, unsigned char *md5sum, GlyrQuery *query,
 ////////////////////////////////////
 
 
-__attribute__((visibility("default")))
-gint glyr_db_delete(GlyrDatabase *db, GlyrQuery *query)
+__attribute__ ( (visibility ("default") ) )
+gint glyr_db_delete (GlyrDatabase * db, GlyrQuery * query)
 {
     gint result = 0;
-    if(db && query) {
+    if (db && query)
+    {
         /* Find out which fields are required for this getter */
-        GLYR_FIELD_REQUIREMENT reqs = glyr_get_requirements(query->type);
+        GLYR_FIELD_REQUIREMENT reqs = glyr_get_requirements (query->type);
 
         /* Spaces in SQL statements just for pretty debug printing */
-        gchar *artist_constr = "";
-        if((reqs & GLYR_REQUIRES_ARTIST) != 0 && query->artist) {
-            ADD_CONSTRAINT(artist_constr, "a.artist_name", query->artist);
+        gchar * artist_constr = "";
+        if ( (reqs & GLYR_REQUIRES_ARTIST) != 0 && query->artist)
+        {
+            ADD_CONSTRAINT (artist_constr,"a.artist_name",query->artist);
         }
 
-        gchar *album_constr  = "";
-        if((reqs & GLYR_REQUIRES_ALBUM) != 0 && query->album) {
-            ADD_CONSTRAINT(album_constr, "b.album_name", query->album);
+        gchar * album_constr  = "";
+        if ( (reqs & GLYR_REQUIRES_ALBUM ) != 0 && query->album)
+        {
+            ADD_CONSTRAINT (album_constr,"b.album_name",query->album);
         }
 
-        gchar *title_constr = "";
-        if((reqs & GLYR_REQUIRES_TITLE) != 0 && query->title) {
-            ADD_CONSTRAINT(title_constr, "t.title_name", query->title);
+        gchar * title_constr = "";
+        if ( (reqs & GLYR_REQUIRES_TITLE ) != 0 && query->title)
+        {
+            ADD_CONSTRAINT (title_constr,"t.title_name",query->title);
         }
 
-        /* Get a SQL formatted list of enabled providers: IN('lastfm', ...') */
-        gchar *from_argument_list = convert_from_option_to_sql(query);
+        /* Get a SQL formatted list of enabled providers: IN('lastfm','...') */
+        gchar * from_argument_list = convert_from_option_to_sql (query);
 
         /* Check if links should be deleted */
-        gchar *img_url_constr = "";
-        if(TYPE_IS_IMAGE(query->type)) {
-            if(query->download == FALSE) {
-                img_url_constr = sqlite3_mprintf("AND data_type = %d ", GLYR_TYPE_IMG_URL);
-            } else {
-                img_url_constr = sqlite3_mprintf("AND NOT data_type = %d ", GLYR_TYPE_IMG_URL);
+        gchar * img_url_constr = "";
+        if (TYPE_IS_IMAGE (query->type) )
+        {
+            if (query->download == FALSE)
+            {
+                img_url_constr = sqlite3_mprintf ("AND data_type = %d ", GLYR_TYPE_IMG_URL);
+            }
+            else
+            {
+                img_url_constr = sqlite3_mprintf ("AND NOT data_type = %d ", GLYR_TYPE_IMG_URL);
             }
         }
 
-        gchar *sql = sqlite3_mprintf(sqlcode[SQL_DELETE_SELECT],
-                                     query->type,        /* Limit to <type>             */
-                                     title_constr,       /* Title Constr, may be empty  */
-                                     album_constr,       /* Album Constr, may be empty  */
-                                     artist_constr,      /* Artist Constr, may be empty */
-                                     from_argument_list, /* Provider contraint          */
-                                     img_url_constr,     /* Search for links?           */
-                                     query->number       /* LIMIT to <number>           */
-                                    );
+        gchar * sql = sqlite3_mprintf (sqlcode[SQL_DELETE_SELECT],
+                                       query->type,        /* Limit to <type>             */
+                                       title_constr,       /* Title Constr, may be empty  */
+                                       album_constr,       /* Album Constr, may be empty  */
+                                       artist_constr,      /* Artist Constr, may be empty */
+                                       from_argument_list, /* Provider contraint          */
+                                       img_url_constr,     /* Search for links?           */
+                                       query->number       /* LIMIT to <number>           */
+                                      );
 
 
-        if(sql != NULL) {
+        if (sql != NULL)
+        {
             delete_callback_data cb_data;
             cb_data.con = db;
             cb_data.deleted = 0;
             cb_data.max_delete = query->number;
 
-            gchar *err_msg = NULL;
-            sqlite3_exec(db->db_handle, sql, delete_callback, &cb_data, &err_msg);
-            if(err_msg != NULL) {
-                glyr_message(-1, NULL, "SQL Delete error: %s\n", err_msg);
-                sqlite3_free(err_msg);
+            gchar * err_msg = NULL;
+            sqlite3_exec (db->db_handle,sql,delete_callback,&cb_data,&err_msg);
+            if (err_msg != NULL)
+            {
+                glyr_message (-1,NULL,"SQL Delete error: %s\n",err_msg);
+                sqlite3_free (err_msg);
             }
-            sqlite3_free(sql);
+            sqlite3_free (sql);
             result = cb_data.deleted;
         }
 
@@ -478,23 +512,19 @@ gint glyr_db_delete(GlyrDatabase *db, GlyrQuery *query)
          * Free ressources with according free calls,
          */
 
-        if(*artist_constr) {
-            sqlite3_free(artist_constr);
-        }
+        if (*artist_constr)
+            sqlite3_free (artist_constr);
 
-        if(*album_constr) {
-            sqlite3_free(album_constr);
-        }
+        if (*album_constr)
+            sqlite3_free (album_constr);
 
-        if(*title_constr) {
-            sqlite3_free(title_constr);
-        }
+        if (*title_constr)
+            sqlite3_free (title_constr);
 
-        if(*img_url_constr) {
-            sqlite3_free(img_url_constr);
-        }
+        if (*img_url_constr)
+            sqlite3_free (img_url_constr);
 
-        g_free(from_argument_list);
+        g_free (from_argument_list);
 
     }
     return result;
@@ -505,10 +535,11 @@ gint glyr_db_delete(GlyrDatabase *db, GlyrQuery *query)
 ////////////////////////////////////
 
 
-__attribute__((visibility("default")))
-void glyr_db_foreach(GlyrDatabase *db, glyr_foreach_callback cb, void *userptr)
+__attribute__ ( (visibility ("default") ) )
+void glyr_db_foreach (GlyrDatabase * db, glyr_foreach_callback cb, void * userptr)
 {
-    if(db != NULL && cb != NULL) {
+    if (db != NULL && cb != NULL)
+    {
         select_callback_data scb_data;
         scb_data.cb = cb;
         scb_data.userptr = userptr;
@@ -520,12 +551,14 @@ void glyr_db_foreach(GlyrDatabase *db, glyr_foreach_callback cb, void *userptr)
         scb_data.result = NULL;
 
         int rc = SQLITE_OK;
-        char *err_msg = NULL;
-        if((rc = sqlite3_exec(db->db_handle, sqlcode[SQL_FOREACH], select_callback, &scb_data, &err_msg)) != SQLITE_OK) {
-            if(rc != SQLITE_ABORT) {
-                glyr_message(-1, NULL, "SQL Foreach error: %s\n", err_msg);
+        char * err_msg = NULL;
+        if ( (rc = sqlite3_exec (db->db_handle,sqlcode[SQL_FOREACH],select_callback,&scb_data,&err_msg) ) != SQLITE_OK)
+        {
+            if (rc != SQLITE_ABORT)
+            {
+                glyr_message (-1,NULL,"SQL Foreach error: %s\n",err_msg);
             }
-            sqlite3_free(err_msg);
+            sqlite3_free (err_msg);
         }
     }
 }
@@ -534,49 +567,58 @@ void glyr_db_foreach(GlyrDatabase *db, glyr_foreach_callback cb, void *userptr)
 ////////////////////////////////////
 ////////////////////////////////////
 
-__attribute__((visibility("default")))
-GlyrMemCache *glyr_db_lookup(GlyrDatabase *db, GlyrQuery *query)
+__attribute__ ( (visibility ("default") ) )
+GlyrMemCache * glyr_db_lookup (GlyrDatabase * db, GlyrQuery * query)
 {
-    GlyrMemCache *result = NULL;
-    if(db != NULL && query != NULL) {
-        GLYR_FIELD_REQUIREMENT reqs = glyr_get_requirements(query->type);
-        gchar *artist_constr = "";
-        if((reqs & GLYR_REQUIRES_ARTIST) != 0) {
-            ADD_CONSTRAINT(artist_constr, "artist_name", query->artist);
+    GlyrMemCache * result = NULL;
+    if (db != NULL && query != NULL)
+    {
+        GLYR_FIELD_REQUIREMENT reqs = glyr_get_requirements (query->type);
+        gchar * artist_constr = "";
+        if ( (reqs & GLYR_REQUIRES_ARTIST) != 0)
+        {
+            ADD_CONSTRAINT (artist_constr,"artist_name",query->artist);
         }
-        gchar *album_constr  = "";
-        if((reqs & GLYR_REQUIRES_ALBUM) != 0) {
-            ADD_CONSTRAINT(album_constr, "album_name", query->album);
+        gchar * album_constr  = "";
+        if ( (reqs & GLYR_REQUIRES_ALBUM ) != 0)
+        {
+            ADD_CONSTRAINT (album_constr,"album_name",query->album);
         }
 
-        gchar *title_constr = "";
-        if((reqs & GLYR_REQUIRES_TITLE) != 0) {
-            ADD_CONSTRAINT(title_constr, "title_name", query->title);
+        gchar * title_constr = "";
+        if ( (reqs & GLYR_REQUIRES_TITLE ) != 0)
+        {
+            ADD_CONSTRAINT (title_constr,"title_name",query->title);
         }
 
-        gchar *from_argument_list = convert_from_option_to_sql(query);
-        gchar *img_url_constr = "";
+        gchar * from_argument_list = convert_from_option_to_sql (query);
+        gchar * img_url_constr = "";
 
-        if(TYPE_IS_IMAGE(query->type)) {
-            if(query->download == FALSE) {
-                img_url_constr = sqlite3_mprintf("AND data_type = %d ", GLYR_TYPE_IMG_URL);
-            } else {
-                img_url_constr = sqlite3_mprintf("AND NOT data_type = %d ", GLYR_TYPE_IMG_URL);
+        if (TYPE_IS_IMAGE (query->type) )
+        {
+            if (query->download == FALSE)
+            {
+                img_url_constr = sqlite3_mprintf ("AND data_type = %d ", GLYR_TYPE_IMG_URL);
+            }
+            else
+            {
+                img_url_constr = sqlite3_mprintf ("AND NOT data_type = %d ", GLYR_TYPE_IMG_URL);
             }
         }
 
-        gchar *sql = sqlite3_mprintf(sqlcode[SQL_LOOKUP],
-                                     query->type,
-                                     title_constr,
-                                     album_constr,
-                                     artist_constr,
-                                     img_url_constr,
-                                     from_argument_list,
-                                     query->number
-                                    );
+        gchar * sql = sqlite3_mprintf (sqlcode[SQL_LOOKUP],
+                                       query->type,
+                                       title_constr,
+                                       album_constr,
+                                       artist_constr,
+                                       img_url_constr,
+                                       from_argument_list,
+                                       query->number
+                                      );
 
 
-        if(sql != NULL) {
+        if (sql != NULL)
+        {
             select_callback_data data;
             data.result = &result;
             data.query = query;
@@ -584,34 +626,39 @@ GlyrMemCache *glyr_db_lookup(GlyrDatabase *db, GlyrQuery *query)
             data.cb = NULL;
             data.userptr = NULL;
 
-            gchar *err_msg = NULL;
-            sqlite3_exec(db->db_handle, sql, select_callback, &data, &err_msg);
-            if(err_msg != NULL) {
-                glyr_message(-1, NULL, "glyr_db_lookup: %s\n", err_msg);
-                sqlite3_free(err_msg);
+            gchar * err_msg = NULL;
+            sqlite3_exec (db->db_handle,sql,select_callback,&data,&err_msg);
+            if (err_msg != NULL)
+            {
+                glyr_message (-1,NULL,"glyr_db_lookup: %s\n",err_msg);
+                sqlite3_free (err_msg);
             }
-            sqlite3_free(sql);
+            sqlite3_free (sql);
         }
 
 #if DO_PROFILE
-        g_message("Spent %.5f Seconds in Selectcallback.\n", select_callback_spent);
+        g_message ("Spent %.5f Seconds in Selectcallback.\n",select_callback_spent);
         select_callback_spent = 0;
 #endif
 
-        if(*artist_constr) {
-            sqlite3_free(artist_constr);
+        if (*artist_constr)
+        {
+            sqlite3_free (artist_constr);
         }
-        if(*album_constr) {
-            sqlite3_free(album_constr);
+        if (*album_constr)
+        {
+            sqlite3_free (album_constr);
         }
-        if(*title_constr) {
-            sqlite3_free(title_constr);
+        if (*title_constr)
+        {
+            sqlite3_free (title_constr);
         }
 
-        g_free(from_argument_list);
+        g_free (from_argument_list);
 
-        if(*img_url_constr != '\0') {
-            sqlite3_free(img_url_constr);
+        if (*img_url_constr != '\0')
+        {
+            sqlite3_free (img_url_constr);
         }
     }
     return result;
@@ -622,31 +669,35 @@ GlyrMemCache *glyr_db_lookup(GlyrDatabase *db, GlyrQuery *query)
 ////////////////////////////////////
 
 
-__attribute__((visibility("default")))
-void glyr_db_insert(GlyrDatabase *db, GlyrQuery *q, GlyrMemCache *cache)
+__attribute__ ( (visibility ("default") ) )
+void glyr_db_insert (GlyrDatabase * db, GlyrQuery * q, GlyrMemCache * cache)
 {
-    if(db && q && cache) {
-        GLYR_FIELD_REQUIREMENT reqs = glyr_get_requirements(q->type);
-        execute(db, "BEGIN IMMEDIATE;");
-        if((reqs & GLYR_REQUIRES_ARTIST) || (reqs & GLYR_OPTIONAL_ARTIST)) {
-            ABORT_ON_FAILED_REQS(reqs, GLYR_OPTIONAL_ARTIST, q->artist);
-            INSERT_STRING("INSERT OR IGNORE INTO artists VALUES('%q');", q->artist);
+    if (db && q && cache)
+    {
+        GLYR_FIELD_REQUIREMENT reqs = glyr_get_requirements (q->type);
+        execute (db,"BEGIN IMMEDIATE;");
+        if ( (reqs & GLYR_REQUIRES_ARTIST) || (reqs & GLYR_OPTIONAL_ARTIST) )
+        {
+            ABORT_ON_FAILED_REQS (reqs,GLYR_OPTIONAL_ARTIST,q->artist);
+            INSERT_STRING ("INSERT OR IGNORE INTO artists VALUES('%q');",q->artist);
         }
-        if((reqs & GLYR_REQUIRES_ALBUM) || (reqs & GLYR_OPTIONAL_ALBUM)) {
-            ABORT_ON_FAILED_REQS(reqs, GLYR_OPTIONAL_ALBUM, q->album);
-            INSERT_STRING("INSERT OR IGNORE INTO albums  VALUES('%q');", q->album);
+        if ( (reqs & GLYR_REQUIRES_ALBUM) || (reqs & GLYR_OPTIONAL_ALBUM) )
+        {
+            ABORT_ON_FAILED_REQS (reqs,GLYR_OPTIONAL_ALBUM,q->album);
+            INSERT_STRING ("INSERT OR IGNORE INTO albums  VALUES('%q');",q->album);
         }
-        if((reqs & GLYR_REQUIRES_TITLE) || (reqs & GLYR_OPTIONAL_TITLE)) {
-            ABORT_ON_FAILED_REQS(reqs, GLYR_OPTIONAL_TITLE, q->title);
-            INSERT_STRING("INSERT OR IGNORE INTO titles  VALUES('%q');", q->title);
+        if ( (reqs & GLYR_REQUIRES_TITLE) || (reqs & GLYR_OPTIONAL_TITLE) )
+        {
+            ABORT_ON_FAILED_REQS (reqs,GLYR_OPTIONAL_TITLE,q->title);
+            INSERT_STRING ("INSERT OR IGNORE INTO titles  VALUES('%q');",q->title);
         }
 
-        gchar *provider = CACHE_GET_PROVIDER(cache);
-        INSERT_STRING("INSERT OR IGNORE INTO providers VALUES('%q');", provider);
-        insert_cache_data(db, q, cache);
+        gchar * provider = CACHE_GET_PROVIDER (cache);
+        INSERT_STRING ("INSERT OR IGNORE INTO providers VALUES('%q');",provider);
+        insert_cache_data (db,q,cache);
 
 rollback:
-        execute(db, "COMMIT;");
+        execute (db,"COMMIT;");
     }
 }
 
@@ -654,11 +705,11 @@ rollback:
 ////////////////////////////////////
 ////////////////////////////////////
 
-__attribute__((visibility("default")))
-GlyrMemCache *glyr_db_make_dummy(void)
+__attribute__ ( (visibility ("default") ) )
+GlyrMemCache * glyr_db_make_dummy (void)
 {
-    GlyrMemCache *c = glyr_cache_new();
-    glyr_cache_set_data(c, g_strdup("[dummy]"), -1);
+    GlyrMemCache * c = glyr_cache_new();
+    glyr_cache_set_data (c,g_strdup ("[dummy]"),-1);
     c->rating = -1;
     return c;
 }
@@ -669,14 +720,16 @@ GlyrMemCache *glyr_db_make_dummy(void)
 
 // --------- INTERNALS ------------ //
 
-static void execute(GlyrDatabase *db, const gchar *sql_statement)
+static void execute (GlyrDatabase * db, const gchar * sql_statement)
 {
-    if(db && sql_statement) {
-        char *err_msg = NULL;
-        sqlite3_exec(db->db_handle, sql_statement, NULL, NULL, &err_msg);
-        if(err_msg != NULL) {
-            glyr_message(-1, NULL, "glyr_db_execute: SQL error: %s\n", err_msg);
-            sqlite3_free(err_msg);
+    if (db && sql_statement)
+    {
+        char * err_msg = NULL;
+        sqlite3_exec (db->db_handle,sql_statement,NULL,NULL,&err_msg);
+        if (err_msg != NULL)
+        {
+            glyr_message (-1,NULL,"glyr_db_execute: SQL error: %s\n", err_msg);
+            sqlite3_free (err_msg);
         }
     }
 }
@@ -689,53 +742,58 @@ static void execute(GlyrDatabase *db, const gchar *sql_statement)
  *  Return the current time as double:
  *  <seconds>.<microseconds/one_second>
  */
-static double get_current_time(void)
+static double get_current_time (void)
 {
     struct timeval tim;
-    gettimeofday(&tim, NULL);
-    return (double) tim.tv_sec + ((double) tim.tv_usec / 1e6);
+    gettimeofday (&tim, NULL);
+    return (double) tim.tv_sec + ( (double) tim.tv_usec/1e6);
 }
 
 ////////////////////////////////////
 
-static void insert_cache_data(GlyrDatabase *db, GlyrQuery *query, GlyrMemCache *cache)
+static void insert_cache_data (GlyrDatabase * db, GlyrQuery * query, GlyrMemCache * cache)
 {
-    if(db && query && cache) {
+    if (db && query && cache)
+    {
         int pos = 1;
-        char *sql = sqlite3_mprintf(sqlcode[SQL_INSERT_CACHE],
-                                    query->artist,
-                                    query->album,
-                                    query->title,
-                                    CACHE_GET_PROVIDER(cache),
-                                    cache->img_format
-                                   );
+        char * sql = sqlite3_mprintf (sqlcode[SQL_INSERT_CACHE],
+                                      query->artist,
+                                      query->album,
+                                      query->title,
+                                      CACHE_GET_PROVIDER (cache),
+                                      cache->img_format
+                                     );
 
         sqlite3_stmt *stmt = NULL;
-        sqlite3_prepare_v2(db->db_handle, sql, strlen(sql) + 1, &stmt, NULL);
-
-        SQL_BIND_TEXT(stmt, cache->dsrc, pos++);
-        sqlite3_bind_int(stmt, pos++, cache->duration);
-        sqlite3_bind_int(stmt, pos++, query->type);
-        sqlite3_bind_int(stmt, pos++, cache->type);
-        sqlite3_bind_int(stmt, pos++, cache->size);
-        sqlite3_bind_int(stmt, pos++, cache->is_image);
-        sqlite3_bind_blob(stmt, pos++, cache->md5sum, sizeof cache->md5sum, SQLITE_STATIC);
-
-        if(cache->data != NULL) {
-            sqlite3_bind_blob(stmt, pos++, cache->data, cache->size, SQLITE_STATIC);
-        } else {
-            glyr_message(1, query, "glyr: Warning: Attempting to insert cache with missing data!\n");
+        sqlite3_prepare_v2 (db->db_handle, sql, strlen (sql) + 1, &stmt, NULL);
+
+        SQL_BIND_TEXT (stmt,cache->dsrc,pos++);
+        sqlite3_bind_int (stmt, pos++, cache->duration);
+        sqlite3_bind_int (stmt, pos++, query->type);
+        sqlite3_bind_int (stmt, pos++, cache->type);
+        sqlite3_bind_int (stmt, pos++, cache->size);
+        sqlite3_bind_int (stmt, pos++, cache->is_image);
+        sqlite3_bind_blob (stmt,pos++, cache->md5sum, sizeof cache->md5sum, SQLITE_STATIC);
+
+        if (cache->data != NULL)
+        {
+            sqlite3_bind_blob (stmt, pos++, cache->data, cache->size, SQLITE_STATIC);
+        }
+        else
+        {
+            glyr_message (1,query,"glyr: Warning: Attempting to insert cache with missing data!\n");
         }
 
-        sqlite3_bind_int(stmt, pos++, cache->rating);
-        sqlite3_bind_double(stmt, pos++, get_current_time());
+        sqlite3_bind_int (stmt, pos++, cache->rating);
+        sqlite3_bind_double (stmt,pos++, get_current_time() );
 
-        if(sqlite3_step(stmt) != SQLITE_DONE) {
-            glyr_message(1, query, "glyr_db_insert: SQL failure: %s\n", sqlite3_errmsg(db->db_handle));
+        if (sqlite3_step (stmt) != SQLITE_DONE)
+        {
+            glyr_message (1,query,"glyr_db_insert: SQL failure: %s\n", sqlite3_errmsg (db->db_handle) );
         }
 
-        sqlite3_finalize(stmt);
-        sqlite3_free(sql);
+        sqlite3_finalize (stmt);
+        sqlite3_free (sql);
     }
 }
 
@@ -747,20 +805,25 @@ static void insert_cache_data(GlyrDatabase *db, GlyrQuery *query, GlyrMemCache *
 
 #define DEBUG_LIST false
 
-static void add_to_cache_list(GlyrMemCache **list, GlyrMemCache *to_add)
+static void add_to_cache_list (GlyrMemCache ** list, GlyrMemCache * to_add)
 {
-    if(to_add && list) {
-        GlyrMemCache *head = *list;
-        if(head == NULL) {
+    if (to_add && list)
+    {
+        GlyrMemCache * head = *list;
+        if (head == NULL)
+        {
             /* Initialize list */
             *list = to_add;
-        } else {
+        }
+        else
+        {
             /* Find rating in list
              * head will store the first non-matchin item,
              * tail = head->prev
              * */
-            GlyrMemCache *tail = head;
-            while(head && head->rating > to_add->rating) {
+            GlyrMemCache * tail = head;
+            while (head && head->rating > to_add->rating)
+            {
                 tail = head;
                 head = head->next;
             }
@@ -771,19 +834,23 @@ static void add_to_cache_list(GlyrMemCache **list, GlyrMemCache *to_add)
              * caches (== higher timestamp), are sorted
              * at the start
              */
-            if(head != NULL) {
+            if (head != NULL)
+            {
                 int last_rating = head->rating;
-                while(head && head->rating == last_rating && head->timestamp > to_add->timestamp) {
-                    GlyrMemCache *p = head->next;
-                    if(p && p->rating == last_rating) {
+                while (head && head->rating == last_rating && head->timestamp > to_add->timestamp)
+                {
+                    GlyrMemCache * p = head->next;
+                    if (p && p->rating == last_rating)
+                    {
                         tail = head;
                         head = p;
-                    } else if(p == NULL) {
+                    }
+                    else if (p == NULL)
+                    {
                         tail = head;
                         head = p;
-                    } else {
-                        break;
                     }
+                    else break;
 
                 }
             }
@@ -792,22 +859,23 @@ static void add_to_cache_list(GlyrMemCache **list, GlyrMemCache *to_add)
              * If so just append it,
              * else we insert to_add before head
              */
-            g_assert(tail);
-            if(head != NULL) {
-                GlyrMemCache *prev = head->prev;
-                if(prev != NULL) {
+            g_assert (tail);
+            if (head != NULL)
+            {
+                GlyrMemCache * prev = head->prev;
+                if (prev != NULL)
                     prev->next = to_add;
-                }
 
                 to_add->prev = prev;
                 to_add->next = head;
 
                 head->prev = to_add;
 
-                if(prev == NULL) {
+                if (prev == NULL)
                     *list = to_add;
-                }
-            } else { /* We're at the end */
+            }
+            else /* We're at the end */
+            {
                 tail->next = to_add;
                 to_add->prev = tail;
             }
@@ -815,13 +883,14 @@ static void add_to_cache_list(GlyrMemCache **list, GlyrMemCache *to_add)
     }
 
 #if DEBUG_LIST
-    GlyrMemCache *p = *list;
-    while(p != NULL) {
-        char *surr = (to_add == p) ? "*" : "|";
-        g_printerr("%s(%d|%2.10f)%s %c ", surr, p->rating, p->timestamp, surr, (p->next) ? '-' : ' ');
+    GlyrMemCache * p = *list;
+    while (p != NULL)
+    {
+        char * surr = (to_add == p) ? "*" : "|";
+        g_printerr ("%s(%d|%2.10f)%s %c ",surr,p->rating,p->timestamp,surr, (p->next) ? '-' : ' ');
         p = p->next;
     }
-    puts("");
+    puts ("");
 #endif
 
 }
@@ -831,77 +900,86 @@ static void add_to_cache_list(GlyrMemCache **list, GlyrMemCache *to_add)
 ////////////////////////////////////
 
 /* Convert a single result from the DB to an actual Cache */
-static int select_callback(void *result, int argc, char **argv, char **azColName)
+static int select_callback (void * result, int argc, char ** argv, char ** azColName)
 {
 #if DO_PROFILE
-    g_timer_start(select_callback_timer);
+    g_timer_start (select_callback_timer);
 #endif
 
 
     int rc = 0;
-    select_callback_data *data = result;
-    GlyrMemCache **list = data->result;
-
-    if(argc >= 15 && data->counter < data->query->number) {
-        GlyrMemCache *cache = DL_init();
-        if(cache != NULL) {
-            cache->prov = g_strdup(argv[3]);
-            cache->dsrc = g_strdup(argv[4]);
-            cache->img_format = g_strdup(argv[5]);
-
-            cache->duration = (argv[6]  ? strtol(argv[6], NULL, 10)   : 0);
-            cache->type = (argv[8]  ? strtol(argv[8], NULL, 10)   : 0);
-            cache->size = (argv[9]  ? strtol(argv[9], NULL, 10)   : 0);
-            cache->is_image = (argv[10] ? strtol(argv[10], NULL, 10) : 0);
-
-            if(argv[11] != NULL) {
-                memcpy(cache->md5sum, argv[11], 16);
+    select_callback_data * data = result;
+    GlyrMemCache ** list = data->result;
+
+    if (argc >= 15 && data->counter < data->query->number)
+    {
+        GlyrMemCache * cache = DL_init();
+        if (cache != NULL)
+        {
+            cache->prov = g_strdup (argv[3]);
+            cache->dsrc = g_strdup (argv[4]);
+            cache->img_format = g_strdup (argv[5]);
+
+            cache->duration = (argv[6]  ? strtol (argv[6],NULL,10)   : 0);
+            cache->type =     (argv[8]  ? strtol (argv[8],NULL,10)   : 0);
+            cache->size =     (argv[9]  ? strtol (argv[9],NULL,10)   : 0);
+            cache->is_image = (argv[10] ? strtol (argv[10],NULL,10) : 0);
+
+            if (argv[11] != NULL)
+            {
+                memcpy (cache->md5sum,argv[11],16);
             }
 
-            if(argv[12] != NULL && cache->size > 0) {
-                cache->data = g_malloc0(cache->size + 1);
-                memcpy(cache->data, argv[12], cache->size);
+            if (argv[12] != NULL && cache->size > 0)
+            {
+                cache->data = g_malloc0 (cache->size + 1);
+                memcpy (cache->data,argv[12],cache->size);
                 cache->data[cache->size] = 0;
             }
 
-            cache->rating = (argv[13] ? strtol(argv[13], NULL, 10) : 0);
+            cache->rating = (argv[13] ? strtol (argv[13],NULL,10) : 0);
 
             /* Timestamp */
-            if(argv[14] != NULL) {
+            if (argv[14] != NULL)
+            {
                 /* Normal strtod() cuts off part behin the comma.. */
-                cache->timestamp = (argv[14] ? g_ascii_strtod(argv[14], NULL) : 0);
+                cache->timestamp = (argv[14] ? g_ascii_strtod (argv[14],NULL) : 0);
             }
 
             /* We're in the cache, so this one was cached.. :) */
             cache->cached = TRUE;
 
-            if(list != NULL) {
-                add_to_cache_list(list, cache);
-            } else if(data->cb != NULL && cache) {
+            if (list != NULL)
+            {
+                add_to_cache_list (list,cache);
+            }
+            else if (data->cb != NULL && cache)
+            {
                 GlyrQuery q;
-                glyr_query_init(&q);
+                glyr_query_init (&q);
 
-                if(argv[7] != NULL) {
-                    GLYR_GET_TYPE type = strtol(argv[7], NULL, 10);
-                    glyr_opt_type(&q, type);
+                if (argv[7] != NULL)
+                {
+                    GLYR_GET_TYPE type = strtol (argv[7],NULL,10);
+                    glyr_opt_type (&q,type);
                 }
 
-                glyr_opt_artist(&q, argv[0]);
-                glyr_opt_album(&q, argv[1]);
-                glyr_opt_title(&q, argv[2]);
+                glyr_opt_artist (&q,argv[0]);
+                glyr_opt_album (&q, argv[1]);
+                glyr_opt_title (&q, argv[2]);
 
-                rc = data->cb(&q, cache, data->userptr);
+                rc = data->cb (&q,cache,data->userptr);
 
-                glyr_query_destroy(&q);
-                DL_free(cache);
+                glyr_query_destroy (&q);
+                DL_free (cache);
             }
         }
     }
 
     data->counter++;
 #if DO_PROFILE
-    g_timer_stop(select_callback_timer);
-    select_callback_spent += g_timer_elapsed(select_callback_timer, NULL);
+    g_timer_stop (select_callback_timer);
+    select_callback_spent += g_timer_elapsed (select_callback_timer,NULL);
 #endif
     return rc;
 }
@@ -910,17 +988,20 @@ static int select_callback(void *result, int argc, char **argv, char **azColName
 ////////////////////////////////////
 ////////////////////////////////////
 
-static gchar *convert_from_option_to_sql(GlyrQuery *q)
+static gchar * convert_from_option_to_sql (GlyrQuery * q)
 {
-    gchar *result = g_strdup("'none'");
-
-    for(GList *elem = r_getSList(); elem; elem = elem->next) {
-        MetaDataSource *item = elem->data;
-        if(item && (q->type == item->type || item->type == GLYR_GET_ANY)) {
-            if(provider_is_enabled(q, item) == TRUE) {
-                gchar *old_mem = result;
-                result = g_strdup_printf("%s%s'%s'", result, (*result) ? ",  : "", item->name);
-                g_free(old_mem);
+    gchar * result = g_strdup ("'none'");
+
+    for (GList * elem = r_getSList(); elem; elem = elem->next)
+    {
+        MetaDataSource * item = elem->data;
+        if (item && (q->type == item->type || item->type == GLYR_GET_ANY) )
+        {
+            if (provider_is_enabled (q,item) == TRUE)
+            {
+                gchar * old_mem = result;
+                result = g_strdup_printf ("%s%s'%s'",result, (*result) ? "," : "",item->name);
+                g_free (old_mem);
             }
         }
     }
@@ -931,23 +1012,25 @@ static gchar *convert_from_option_to_sql(GlyrQuery *q)
 ////////////////////////////////////
 ////////////////////////////////////
 
-static int delete_callback(void *result, int argc, char **argv, char **azColName)
+static int delete_callback (void * result, int argc, char ** argv, char ** azColName)
 {
-    delete_callback_data *data = result;
-    if(argc >= 4 && result && data->max_delete > data->deleted) {
+    delete_callback_data * data = result;
+    if (argc >= 4 && result && data->max_delete > data->deleted)
+    {
         /* God, this is so silly.. SQL, why you don't like " = null"
          * I can't think of any easier way to do this, tell me if you found one
          */
-        gchar *sql_delete = sqlite3_mprintf(sqlcode[SQL_ACTUAL_DELETE],
-                                            argv[0] ? "=" : " IS ", argv[0] ? argv[0] : "NULL",
-                                            argv[1] ? "=" : " IS ", argv[1] ? argv[1] : "NULL",
-                                            argv[2] ? "=" : " IS ", argv[2] ? argv[2] : "NULL",
-                                            argv[3] ? "=" : " IS ", argv[3] ? argv[3] : "NULL",
-                                            argv[4] ? "=" : " IS ", argv[4] ? argv[4] : "NULL");
-
-        if(sql_delete != NULL) {
-            execute(data->con, sql_delete);
-            sqlite3_free(sql_delete);
+        gchar * sql_delete = sqlite3_mprintf (sqlcode[SQL_ACTUAL_DELETE],
+                                              argv[0] ? "=" : " IS ", argv[0] ? argv[0] : "NULL",
+                                              argv[1] ? "=" : " IS ", argv[1] ? argv[1] : "NULL",
+                                              argv[2] ? "=" : " IS ", argv[2] ? argv[2] : "NULL",
+                                              argv[3] ? "=" : " IS ", argv[3] ? argv[3] : "NULL",
+                                              argv[4] ? "=" : " IS ", argv[4] ? argv[4] : "NULL");
+
+        if (sql_delete != NULL)
+        {
+            execute (data->con,sql_delete);
+            sqlite3_free (sql_delete);
             data->deleted++;
         }
     }
diff --git a/lib/cache_intern.c b/lib/cache_intern.c
index af19fd9..b4b6f86 100644
--- a/lib/cache_intern.c
+++ b/lib/cache_intern.c
@@ -28,34 +28,39 @@
 /////////////////////////////////
 
 /* Check if a cache is already in the db, by cheskum or source_url  */
-gboolean db_contains(GlyrDatabase *db, GlyrMemCache *cache)
+gboolean db_contains (GlyrDatabase * db, GlyrMemCache * cache)
 {
     gboolean result = FALSE;
-    if(db && cache) {
-        gchar *sql = sqlite3_mprintf(
-                         "SELECT source_url, ata_checksum, ata_size, ata_type FROM metadata AS m      "
-                         "WHERE (m.data_type = %d AND m.data_size = %d AND m.data_checksum = '?')     "
-                         "OR (m.source_url LIKE '%q' AND m.source_url IS NOT NULL AND data_type = %d) "
-                         "LIMIT 1;                                                                    ",
-                         cache->type,
-                         cache->size,
-                         cache->dsrc,
-                         cache->type);
+    if (db && cache)
+    {
+        gchar * sql = sqlite3_mprintf (
+                          "SELECT source_url,data_checksum,data_size,data_type FROM metadata AS m      "
+                          "WHERE (m.data_type = %d AND m.data_size = %d AND m.data_checksum = '?')     "
+                          "OR (m.source_url LIKE '%q' AND m.source_url IS NOT NULL AND data_type = %d) "
+                          "LIMIT 1;                                                                    ",
+                          cache->type,
+                          cache->size,
+                          cache->dsrc,
+                          cache->type);
 
-        if(sql != NULL) {
-            sqlite3_stmt *stmt = NULL;
-            sqlite3_prepare_v2(db->db_handle, sql, strlen(sql) + 1, &stmt, NULL);
-            sqlite3_bind_blob(stmt, 1, cache->md5sum, sizeof cache->md5sum, SQLITE_TRANSIENT);
+        if (sql != NULL)
+        {
+            sqlite3_stmt * stmt = NULL;
+            sqlite3_prepare_v2 (db->db_handle, sql, strlen (sql) + 1, &stmt, NULL);
+            sqlite3_bind_blob (stmt, 1, cache->md5sum, sizeof cache->md5sum, SQLITE_TRANSIENT);
 
-            int err = sqlite3_step(stmt);
-            if(err == SQLITE_ROW) {
+            int err = sqlite3_step (stmt);
+            if (err == SQLITE_ROW)
+            {
                 result = TRUE;
-            } else if(err != SQLITE_DONE) {
-                glyr_message(-1, NULL, "db_contains: error message: %s\n", sqlite3_errmsg(db->db_handle));
+            }
+            else if (err != SQLITE_DONE)
+            {
+                glyr_message (-1,NULL,"db_contains: error message: %s\n", sqlite3_errmsg (db->db_handle) );
             }
 
-            sqlite3_finalize(stmt);
-            sqlite3_free(sql);
+            sqlite3_finalize (stmt);
+            sqlite3_free (sql);
         }
     }
     return result;
diff --git a/lib/config.h b/lib/config.h
index cffcc3b..c225e39 100644
--- a/lib/config.h
+++ b/lib/config.h
@@ -12,11 +12,11 @@
 
 #define GLYR_VERSION_MAJOR "1"
 #define GLYR_VERSION_MINOR "0"
-#define GLYR_VERSION_MICRO "5"
+#define GLYR_VERSION_MICRO "6"
 
 #define GLYR_VERSION_MAJOR_INT 1
 #define GLYR_VERSION_MINOR_INT 0
-#define GLYR_VERSION_MICRO_INT 5
+#define GLYR_VERSION_MICRO_INT 6
 
 /**
  * GLYR_CHECK_VERSION:
diff --git a/lib/core.c b/lib/core.c
index d3753fb..e620057 100644
--- a/lib/core.c
+++ b/lib/core.c
@@ -39,16 +39,17 @@
 //////////////////////////////////////
 
 
-static int _msg(const char *fmt, va_list params)
+static int _msg (const char * fmt, va_list params)
 {
-    gchar *tmp_buf = NULL;
+    gchar * tmp_buf = NULL;
 
     /* Silly, but needs a way to get length */
-    gint written = g_vasprintf(&tmp_buf, fmt, params);
+    gint written = g_vasprintf (&tmp_buf,fmt,params);
 
-    if(written != -1 && tmp_buf != NULL) {
-        g_log(G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "%s", tmp_buf);
-        g_free(tmp_buf);
+    if (written != -1 && tmp_buf != NULL)
+    {
+        g_log (G_LOG_DOMAIN,G_LOG_LEVEL_INFO,"%s",tmp_buf);
+        g_free (tmp_buf);
         tmp_buf = NULL;
     }
     return written;
@@ -56,16 +57,19 @@ static int _msg(const char *fmt, va_list params)
 
 //////////////////////////////////////
 
-int glyr_message(int verbosity, GlyrQuery *s, const char *fmt, ...)
+int glyr_message (int verbosity, GlyrQuery * s, const char * fmt, ...)
 {
     gint written = 0;
-    if(s != NULL || verbosity == -1) {
-        if(verbosity == -1 || verbosity <= s->verbosity) {
+    if (s != NULL || verbosity == -1)
+    {
+        if (verbosity == -1 || verbosity <= s->verbosity)
+        {
             va_list params;
-            if(fmt != NULL) {
-                va_start(params, fmt);
-                written = _msg(fmt, params);
-                va_end(params);
+            if (fmt != NULL)
+            {
+                va_start (params,fmt);
+                written = _msg (fmt,params);
+                va_end (params);
             }
         }
     }
@@ -78,14 +82,13 @@ int glyr_message(int verbosity, GlyrQuery *s, const char *fmt, ...)
 /**
 * Check if the size of a cover fits the specs
 */
-gboolean size_is_okay(int sZ, int min, int max)
+gboolean size_is_okay (int sZ, int min, int max)
 {
-    if((min == -1 && max == -1) ||
+    if ( (min == -1 && max == -1) ||
             (min == -1 && max >= sZ) ||
             (min <= sZ && max == -1) ||
-            (min <= sZ && max >= sZ)) {
+            (min <= sZ && max >= sZ)  )
         return TRUE;
-    }
 
     return FALSE;
 }
@@ -95,31 +98,35 @@ gboolean size_is_okay(int sZ, int min, int max)
 /* cache incoming data in a GlyrMemCache
  * libglyr is spending quite some time here
  */
-static size_t DL_buffer(void *puffer, size_t size, size_t nmemb, void *buff_data)
+static size_t DL_buffer (void *puffer, size_t size, size_t nmemb, void * buff_data)
 {
     size_t realsize = size * nmemb;
-    DLBufferContainer *data = (DLBufferContainer *) buff_data;
-    if(data != NULL) {
-        GlyrMemCache *mem = data->cache;
-        mem->data = realloc(mem->data, mem->size + realsize + 1);
-        if(mem->data) {
-            memcpy(& (mem->data[mem->size]), puffer, realsize);
+    DLBufferContainer * data = (DLBufferContainer *) buff_data;
+    if (data != NULL)
+    {
+        GlyrMemCache * mem = data->cache;
+        mem->data = realloc (mem->data, mem->size + realsize + 1);
+        if (mem->data)
+        {
+            memcpy (& (mem->data[mem->size]), puffer, realsize);
             mem->size += realsize;
             mem->data[mem->size] = 0;
 
-            GlyrQuery *query = data->query;
-            if(query && GET_ATOMIC_SIGNAL_EXIT(query)) {
+            GlyrQuery * query = data->query;
+            if (query && GET_ATOMIC_SIGNAL_EXIT (query) )
+            {
                 return 0;
             }
 
             /* Test if a endmarker is in this buffer */
-            const gchar *endmarker = data->endmarker;
-            if(endmarker && strstr(mem->data, endmarker)) {
+            const gchar * endmarker = data->endmarker;
+            if (endmarker && strstr (mem->data,endmarker) )
                 return 0;
-            }
-        } else {
-            glyr_message(-1, NULL, "Caching failed: Out of memory.\n");
-            glyr_message(-1, NULL, "Did you perhaps try to load a 4, GB .iso into your RAM?\n");
+        }
+        else
+        {
+            glyr_message (-1,NULL,"Caching failed: Out of memory.\n");
+            glyr_message (-1,NULL,"Did you perhaps try to load a 4,7GB .iso into your RAM?\n");
         }
     }
     return realsize;
@@ -127,40 +134,46 @@ static size_t DL_buffer(void *puffer, size_t size, size_t nmemb, void *buff_data
 
 //////////////////////////////////////
 
-void DL_set_data(GlyrMemCache *cache, const gchar *data, gint len)
+void DL_set_data (GlyrMemCache * cache, const gchar * data, gint len)
 {
-    if(cache != NULL) {
-        g_free(cache->data);
-
-        cache->data = (gchar *) data;
-        if(data != NULL) {
-            cache->size = (len >= 0) ? (gsize) len : strlen(data);
-            update_md5sum(cache);
-        } else {
+    if (cache != NULL)
+    {
+        g_free (cache->data);
+
+        cache->data = (gchar*) data;
+        if (data != NULL)
+        {
+            cache->size = (len >= 0) ? (gsize) len : strlen (data);
+            update_md5sum (cache);
+        }
+        else
+        {
             cache->size = 0;
-            memset(cache->md5sum, 0, 16);
+            memset (cache->md5sum,0,16);
         }
     }
 }
 
 //////////////////////////////////////
 
-GlyrMemCache *DL_copy(GlyrMemCache *cache)
+GlyrMemCache * DL_copy (GlyrMemCache * cache)
 {
-    GlyrMemCache *result = NULL;
-    if(cache != NULL) {
-        result = g_malloc0(sizeof(GlyrMemCache));
-        memcpy(result, cache, sizeof(GlyrMemCache));
-        if(cache->size > 0) {
+    GlyrMemCache * result = NULL;
+    if (cache != NULL)
+    {
+        result = g_malloc0 (sizeof (GlyrMemCache) );
+        memcpy (result,cache,sizeof (GlyrMemCache) );
+        if (cache->size > 0)
+        {
             /* Remember NUL for strings */
-            result->data = g_malloc(cache->size + 1);
+            result->data = g_malloc (cache->size + 1);
             result->data[cache->size] = 0;
-            memcpy(result->data, cache->data, cache->size);
+            memcpy (result->data,cache->data,cache->size);
         }
-        result->dsrc = g_strdup(cache->dsrc);
-        result->prov = g_strdup(cache->prov);
-        result->img_format = g_strdup(cache->img_format);
-        memcpy(result->md5sum, cache->md5sum, 16);
+        result->dsrc = g_strdup (cache->dsrc);
+        result->prov = g_strdup (cache->prov);
+        result->img_format = g_strdup (cache->img_format);
+        memcpy (result->md5sum,cache->md5sum,16);
 
         result->next = NULL;
         result->prev = NULL;
@@ -171,28 +184,32 @@ GlyrMemCache *DL_copy(GlyrMemCache *cache)
 //////////////////////////////////////
 
 // cleanup internal buffer if no longer used
-void DL_free(GlyrMemCache *cache)
+void DL_free (GlyrMemCache *cache)
 {
-    if(cache) {
-        if(cache->size && cache->data) {
-            g_free(cache->data);
+    if (cache)
+    {
+        if (cache->size && cache->data)
+        {
+            g_free (cache->data);
             cache->data = NULL;
         }
-        if(cache->dsrc) {
-            g_free(cache->dsrc);
+        if (cache->dsrc)
+        {
+            g_free (cache->dsrc);
             cache->dsrc = NULL;
         }
 
-        if(cache->prov) {
-            g_free(cache->prov);
+        if (cache->prov)
+        {
+            g_free (cache->prov);
             cache->prov = NULL;
         }
 
         cache->size = 0;
         cache->type = GLYR_TYPE_UNKNOWN;
 
-        g_free(cache->img_format);
-        g_free(cache);
+        g_free (cache->img_format);
+        g_free (cache);
         cache = NULL;
     }
 }
@@ -200,10 +217,10 @@ void DL_free(GlyrMemCache *cache)
 //////////////////////////////////////
 
 // Use this to init the internal buffer
-GlyrMemCache *DL_init(void)
+GlyrMemCache* DL_init (void)
 {
-    GlyrMemCache *cache = g_malloc0(sizeof(GlyrMemCache));
-    memset(cache, 0, sizeof(GlyrMemCache));
+    GlyrMemCache * cache = g_malloc0 (sizeof (GlyrMemCache) );
+    memset (cache,0,sizeof (GlyrMemCache) );
 
     cache->type = GLYR_TYPE_UNKNOWN;
     cache->cached = FALSE;
@@ -216,29 +233,37 @@ GlyrMemCache *DL_init(void)
 //////////////////////////////////////
 
 // Splits http_proxy to libcurl conform represantation
-static gboolean proxy_to_curl(gchar *proxystring, char **userpwd, char **server)
+static gboolean proxy_to_curl (gchar * proxystring, char ** userpwd, char ** server)
 {
-    if(proxystring && userpwd && server) {
-        if(proxystring != NULL) {
-            gchar *ddot = strchr(proxystring, ':');
-            gchar *asgn = strchr(proxystring, '@');
-
-            if(ddot == NULL || asgn < ddot) {
-                *server  = g_strdup(proxystring);
+    if (proxystring && userpwd && server)
+    {
+        if (proxystring != NULL)
+        {
+            gchar * ddot = strchr (proxystring,':');
+            gchar * asgn = strchr (proxystring,'@');
+
+            if (ddot == NULL || asgn < ddot)
+            {
+                *server  = g_strdup (proxystring);
                 *userpwd = NULL;
                 return TRUE;
-            } else {
-                gsize len = strlen(proxystring);
-                char *protocol = strstr(proxystring, "://");
-
-                if(protocol == NULL) {
-                    protocol = (gchar *) proxystring;
-                } else {
+            }
+            else
+            {
+                gsize len = strlen (proxystring);
+                char * protocol = strstr (proxystring,"://");
+
+                if (protocol == NULL)
+                {
+                    protocol = (gchar*) proxystring;
+                }
+                else
+                {
                     protocol += 3;
                 }
 
-                *userpwd = g_strndup(protocol, asgn - protocol);
-                *server  = g_strndup(asgn + 1, protocol + len - asgn);
+                *userpwd = g_strndup (protocol,asgn-protocol);
+                *server  = g_strndup (asgn+1,protocol+len-asgn);
                 return TRUE;
             }
         }
@@ -249,44 +274,51 @@ static gboolean proxy_to_curl(gchar *proxystring, char **userpwd, char **server)
 
 //////////////////////////////////////
 
-struct header_data {
-    gchar *type;
-    gchar *format;
-    gchar *extra;
+struct header_data
+{
+    gchar * type;
+    gchar * format;
+    gchar * extra;
 };
 
 //////////////////////////////////////
 
 /* Parse header file. Get Contenttype from it and save it in the header_data struct */
-gsize header_cb(void *ptr, gsize size, gsize nmemb, void *userdata)
+gsize header_cb (void *ptr, gsize size, gsize nmemb, void *userdata)
 {
     gsize bytes = size * nmemb;
-    if(ptr != NULL && userdata != NULL) {
+    if (ptr != NULL && userdata != NULL)
+    {
         /* Transform safely into string */
         gchar nulbuf[bytes + 1];
-        memcpy(nulbuf, ptr, bytes);
+        memcpy (nulbuf,ptr,bytes);
         nulbuf[bytes] = '\0';
 
         /* We're only interested in the content type */
-        gchar *cttp  = "Content-Type: ";
-        gsize ctt_len = strlen(cttp);
-        if(ctt_len < bytes && g_ascii_strncasecmp(cttp, nulbuf, ctt_len) == 0) {
-            gchar **content_type = g_strsplit_set(nulbuf + ctt_len, " /;", 0);
-            if(content_type != NULL) {
+        gchar * cttp  = "Content-Type: ";
+        gsize ctt_len = strlen (cttp);
+        if (ctt_len < bytes && g_ascii_strncasecmp (cttp,nulbuf,ctt_len) == 0)
+        {
+            gchar ** content_type = g_strsplit_set (nulbuf + ctt_len," /;",0);
+            if (content_type != NULL)
+            {
                 gsize set_at = 0;
-                gchar **elem = content_type;
-                struct header_data *info = userdata;
+                gchar ** elem = content_type;
+                struct header_data * info = userdata;
 
                 /* Set fields..  */
-                while(elem[0] != NULL) {
-                    if(elem[0][0] != '\0') {
-                        switch(set_at) {
+                while (elem[0] != NULL)
+                {
+                    if (elem[0][0] != '\0')
+                    {
+                        switch (set_at)
+                        {
                         case 0:
-                            g_free(info->type);
-                            info->type   = g_strdup(elem[0]);
+                            g_free (info->type);
+                            info->type   = g_strdup (elem[0]);
                             break;
                         case 1:
-                            g_free(info->format);
+                            g_free (info->format);
 
                             /*
                              * Specialcase:
@@ -294,24 +326,27 @@ gsize header_cb(void *ptr, gsize size, gsize nmemb, void *userdata)
                              * for their images. This is annoying, but needs to be
                              * handled nevertheless. Shame on you, htbackdrops.
                              * */
-                            if(g_ascii_strncasecmp(elem[0], "octet-stream", 12) == 0) {
-                                g_free(info->type);
-                                info->type   = g_strdup("image");
-                                info->format = g_strdup("jpeg");
-                            } else {
-                                info->format = g_strdup(elem[0]);
+                            if (g_ascii_strncasecmp (elem[0],"octet-stream",12) == 0)
+                            {
+                                g_free (info->type);
+                                info->type   = g_strdup ("image");
+                                info->format = g_strdup ("jpeg");
+                            }
+                            else
+                            {
+                                info->format = g_strdup (elem[0]);
                             }
                             break;
                         case 2:
-                            g_free(info->extra);
-                            info->extra  = g_strdup(elem[0]);
+                            g_free (info->extra);
+                            info->extra  = g_strdup (elem[0]);
                             break;
                         }
                         set_at++;
                     }
                     elem++;
                 }
-                g_strfreev(content_type);
+                g_strfreev (content_type);
             }
         }
     }
@@ -321,94 +356,107 @@ gsize header_cb(void *ptr, gsize size, gsize nmemb, void *userdata)
 //////////////////////////////////////
 
 /* empty callback just prevent writing header to stdout */
-gsize nearly_empty_callback(void *p, gsize size, gsize numb, void *pp_Query)
+gsize nearly_empty_callback (void * p, gsize size, gsize numb, void * pp_Query)
 {
-    GlyrQuery *query = (GlyrQuery *) pp_Query;
-    return (query && GET_ATOMIC_SIGNAL_EXIT(query)) ? 0 : (size * numb);
+    GlyrQuery * query = (GlyrQuery *) pp_Query;
+    return (query && GET_ATOMIC_SIGNAL_EXIT (query) ) ? 0 : (size * numb);
 }
 
 //////////////////////////////////////
 
-static void DL_setproxy(CURL *eh, gchar *proxystring)
+static void DL_setproxy (CURL *eh, gchar * proxystring)
 {
-    if(proxystring != NULL) {
-        gchar *userpwd;
-        gchar *server;
-        proxy_to_curl(proxystring, &userpwd, &server);
-
-        if(server != NULL) {
-            curl_easy_setopt(eh, CURLOPT_PROXY, server);
-            g_free(server);
-        } else {
-            glyr_message(-1, NULL, "Warning: Invalid proxy string.\n");
+    if (proxystring != NULL)
+    {
+        gchar * userpwd;
+        gchar * server;
+        proxy_to_curl (proxystring,&userpwd,&server);
+
+        if (server != NULL)
+        {
+            curl_easy_setopt (eh, CURLOPT_PROXY,server);
+            g_free (server);
+        }
+        else
+        {
+            glyr_message (-1,NULL,"Warning: Invalid proxy string.\n");
         }
 
-        if(userpwd != NULL) {
-            curl_easy_setopt(eh, CURLOPT_PROXYUSERPWD, userpwd);
-            g_free(userpwd);
+        if (userpwd != NULL)
+        {
+            curl_easy_setopt (eh,CURLOPT_PROXYUSERPWD,userpwd);
+            g_free (userpwd);
         }
     }
 }
 
 //////////////////////////////////////
 
-static struct header_data *retrieve_content_info(gchar *url, gchar *proxystring, gchar *useragent, GlyrQuery *query)
+static struct header_data * retrieve_content_info (gchar * url, gchar * proxystring, gchar * useragent, GlyrQuery * query)
 {
-    struct header_data *info = NULL;
-    if(url != NULL) {
-        CURL *eh = curl_easy_init();
+    struct header_data * info = NULL;
+    if (url != NULL)
+    {
+        CURL * eh = curl_easy_init();
         CURLcode rc = CURLE_OK;
 
-        info = g_malloc0(sizeof(struct header_data));
-        gchar *link_user_agent =  g_strdup_printf("%s / linkvalidator", useragent);
+        info = g_malloc0 (sizeof (struct header_data) );
+        gchar * link_user_agent =  g_strdup_printf ("%s / linkvalidator",useragent);
 
-        curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);
-        curl_easy_setopt(eh, CURLOPT_NOSIGNAL, 1L);
-        curl_easy_setopt(eh, CURLOPT_USERAGENT, link_user_agent);
-        curl_easy_setopt(eh, CURLOPT_URL, url);
-        curl_easy_setopt(eh, CURLOPT_FOLLOWLOCATION, TRUE);
-        curl_easy_setopt(eh, CURLOPT_MAXREDIRS, 5L);
-        curl_easy_setopt(eh, CURLOPT_HEADER, TRUE);
-        curl_easy_setopt(eh, CURLOPT_SSL_VERIFYPEER, FALSE);
+        curl_easy_setopt (eh, CURLOPT_TIMEOUT, 10);
+        curl_easy_setopt (eh, CURLOPT_NOSIGNAL, 1L);
+        curl_easy_setopt (eh, CURLOPT_USERAGENT, link_user_agent);
+        curl_easy_setopt (eh, CURLOPT_URL,url);
+        curl_easy_setopt (eh, CURLOPT_FOLLOWLOCATION, TRUE);
+        curl_easy_setopt (eh, CURLOPT_MAXREDIRS, 5L);
+        curl_easy_setopt (eh, CURLOPT_HEADER,TRUE);
+        curl_easy_setopt (eh, CURLOPT_SSL_VERIFYPEER, FALSE);
 
         /* Dirty hack here: Amazon bitches at me when setting NOBODY to true *
          * But otherwise large images won't pass with other providers        *
          * Check domain therefore..
          */
-        if(strstr(url, "amazon") != NULL) {
-            curl_easy_setopt(eh, CURLOPT_NOBODY, FALSE);
-        } else {
-            curl_easy_setopt(eh, CURLOPT_NOBODY, TRUE);
+        if (strstr (url,"amazon") != NULL)
+        {
+            curl_easy_setopt (eh, CURLOPT_NOBODY,FALSE);
+        }
+        else
+        {
+            curl_easy_setopt (eh, CURLOPT_NOBODY,TRUE);
         }
 
-        curl_easy_setopt(eh, CURLOPT_HEADERFUNCTION, header_cb);
-        curl_easy_setopt(eh, CURLOPT_WRITEFUNCTION, nearly_empty_callback);
-        curl_easy_setopt(eh, CURLOPT_WRITEDATA, query);
-        curl_easy_setopt(eh, CURLOPT_WRITEHEADER, info);
+        curl_easy_setopt (eh, CURLOPT_HEADERFUNCTION, header_cb);
+        curl_easy_setopt (eh, CURLOPT_WRITEFUNCTION, nearly_empty_callback);
+        curl_easy_setopt (eh, CURLOPT_WRITEDATA, query);
+        curl_easy_setopt (eh, CURLOPT_WRITEHEADER, info);
 
         /* Set proxy, if any */
-        DL_setproxy(eh, proxystring);
+        DL_setproxy (eh, proxystring);
 
         /* This seemed to prevent some valid urls from passing. Strange. */
-        //curl_easy_setopt(eh, CURLOPT_FAILONERROR, RUE);
+        //curl_easy_setopt(eh, CURLOPT_FAILONERROR,TRUE);
 
-        rc = curl_easy_perform(eh);
-        curl_easy_cleanup(eh);
+        rc = curl_easy_perform (eh);
+        curl_easy_cleanup (eh);
 
-        if(rc != CURLE_OK) {
-            if(GET_ATOMIC_SIGNAL_EXIT(query) == FALSE) {
-                glyr_message(1, query, "- DLError: %s [%d]\n", curl_easy_strerror(rc), rc);
+        if (rc != CURLE_OK)
+        {
+            if (GET_ATOMIC_SIGNAL_EXIT (query) == FALSE)
+            {
+                glyr_message (1,query,"- DLError: %s [%d]\n",curl_easy_strerror (rc),rc);
             }
-            g_free(info);
+            g_free (info);
             info = NULL;
-        } else {
-            /* Remove trailing newlines, arriage returns */
-            chomp_breakline(info->type);
-            chomp_breakline(info->format);
-            chomp_breakline(info->extra);
+        }
+        else
+        {
+            /* Remove trailing newlines,carriage returns */
+            chomp_breakline (info->type);
+            chomp_breakline (info->format);
+            chomp_breakline (info->extra);
         }
 
-        g_free(link_user_agent);
+        g_free (link_user_agent);
     }
     return info;
 }
@@ -416,57 +464,58 @@ static struct header_data *retrieve_content_info(gchar *url, gchar *proxystring,
 //////////////////////////////////////
 
 // Init an easyhandler with all relevant options
-static DLBufferContainer *DL_setopt(CURL *eh, GlyrMemCache *cache, const char *url, GlyrQuery *s, void *magic_private_ptr, long timeout, gchar *endmarker)
+static DLBufferContainer * DL_setopt (CURL *eh, GlyrMemCache * cache, const char * url, GlyrQuery * s, void * magic_private_ptr, long timeout, gchar * endmarker)
 {
     // Set options (see 'man curl_easy_setopt')
-    curl_easy_setopt(eh, CURLOPT_TIMEOUT, timeout);
-    curl_easy_setopt(eh, CURLOPT_NOSIGNAL, 1L);
+    curl_easy_setopt (eh, CURLOPT_TIMEOUT, timeout);
+    curl_easy_setopt (eh, CURLOPT_NOSIGNAL, 1L);
 
     // last.fm and discogs require an useragent (wokrs without too)
-    curl_easy_setopt(eh, CURLOPT_USERAGENT, (s && s->useragent) ? s->useragent : GLYR_DEFAULT_USERAGENT);
-    curl_easy_setopt(eh, CURLOPT_HEADER, 0L);
+    curl_easy_setopt (eh, CURLOPT_USERAGENT, (s && s->useragent) ? s->useragent : GLYR_DEFAULT_USERAGENT);
+    curl_easy_setopt (eh, CURLOPT_HEADER, 0L);
 
     // Pass vars to curl
-    curl_easy_setopt(eh, CURLOPT_URL, url);
-    curl_easy_setopt(eh, CURLOPT_PRIVATE, magic_private_ptr);
-    curl_easy_setopt(eh, CURLOPT_VERBOSE, (s && s->verbosity >= 4));
-    curl_easy_setopt(eh, CURLOPT_WRITEFUNCTION, DL_buffer);
-    curl_easy_setopt(eh, CURLOPT_SSL_VERIFYPEER, FALSE);
-
-    DLBufferContainer *dlbuffer = g_malloc0(sizeof(DLBufferContainer));
-    curl_easy_setopt(eh, CURLOPT_WRITEDATA, (void *) dlbuffer);
+    curl_easy_setopt (eh, CURLOPT_URL, url);
+    curl_easy_setopt (eh, CURLOPT_PRIVATE, magic_private_ptr);
+    curl_easy_setopt (eh, CURLOPT_VERBOSE, (s && s->verbosity >= 4) );
+    curl_easy_setopt (eh, CURLOPT_WRITEFUNCTION, DL_buffer);
+    curl_easy_setopt (eh, CURLOPT_SSL_VERIFYPEER, FALSE);
+
+    DLBufferContainer * dlbuffer = g_malloc0 (sizeof (DLBufferContainer) );
+    curl_easy_setopt (eh, CURLOPT_WRITEDATA, (void *) dlbuffer);
     dlbuffer->cache = cache;
     dlbuffer->endmarker = endmarker;
     dlbuffer->query = s;
 
     // amazon plugin requires redirects
-    curl_easy_setopt(eh, CURLOPT_FOLLOWLOCATION, 1L);
-    curl_easy_setopt(eh, CURLOPT_MAXREDIRS, (s) ? s->redirects : 2);
+    curl_easy_setopt (eh, CURLOPT_FOLLOWLOCATION, 1L);
+    curl_easy_setopt (eh, CURLOPT_MAXREDIRS, (s) ? s->redirects : 2);
 
     // Do not download 404 pages
-    curl_easy_setopt(eh, CURLOPT_FAILONERROR, 1L);
+    curl_easy_setopt (eh, CURLOPT_FAILONERROR, 1L);
 
     // Set proxy to use
-    DL_setproxy(eh, (gchar *)(s) ? s->proxy : NULL);
+    DL_setproxy (eh, (gchar*) (s) ? s->proxy : NULL);
 
     // Discogs requires gzip compression
-    curl_easy_setopt(eh, CURLOPT_ENCODING, "gzip");
+    curl_easy_setopt (eh, CURLOPT_ENCODING,"gzip");
 
     // Don't save cookies - I had some quite embarassing moments
     // when amazon's startpage showed me "Hooray for Boobies",
     // because I searched for the Bloodhoundgang album...
     // (because I have it already of course! ;-))
-    curl_easy_setopt(eh, CURLOPT_COOKIEJAR , "");
+    curl_easy_setopt (eh, CURLOPT_COOKIEJAR ,"");
 
     return dlbuffer;
 }
 
 //////////////////////////////////////
 
-gboolean continue_search(gint current, GlyrQuery *s)
+gboolean continue_search (gint current, GlyrQuery * s)
 {
     gboolean decision = FALSE;
-    if(s != NULL && GET_ATOMIC_SIGNAL_EXIT(s) == FALSE) {
+    if (s != NULL && GET_ATOMIC_SIGNAL_EXIT (s) == FALSE)
+    {
         /* Take an educated guess, let the provider get more, because URLs might be wrong,
          * as we check this later, it's good to have some more ULRs waiting for us,     *
          * alternatively we might hit the maximum for one plugin (off by one!)          */
@@ -477,7 +526,7 @@ gboolean continue_search(gint current, GlyrQuery *s)
          */
         gint pre_cache = (s->local_db) ? s->number : 0;
         decision = (current + s->itemctr) < (s->number + buffering + pre_cache) &&
-                   (current < s->plugmax || (s->plugmax == -1));
+                   (current < s->plugmax || (s->plugmax == -1) );
 
     }
     return decision;
@@ -488,46 +537,55 @@ gboolean continue_search(gint current, GlyrQuery *s)
 //////////////////////////////////////
 
 /* Check for dupes. This does not affect the HEAD of the list, therefore no GList return */
-gsize delete_dupes(GList *result, GlyrQuery *s)
+gsize delete_dupes (GList * result, GlyrQuery * s)
 {
-    if(!result || g_list_length(result) < 1) {
+    if (!result || g_list_length (result) < 1)
         return 0;
-    }
 
     /* Build new hashes, the data might have changed */
-    for(GList *elem = result; elem; elem = elem->next) {
-        update_md5sum(elem->data);
+    for (GList * elem = result; elem; elem = elem->next)
+    {
+        update_md5sum (elem->data);
     }
 
     gint double_items = 0;
-    for(GList *inode = result; inode; inode = inode->next) {
-        GlyrMemCache *lval = inode->data;
+    for (GList * inode = result; inode; inode = inode->next)
+    {
+        GlyrMemCache * lval = inode->data;
 
-        GList *jnode = result;
-        while(jnode != NULL) {
+        GList * jnode = result;
+        while (jnode != NULL)
+        {
             bool is_duplicate  = false;
-            GlyrMemCache *rval = jnode->data;
+            GlyrMemCache * rval = jnode->data;
 
-            if(lval && rval && rval != lval && lval->size == rval->size) {
+            if (lval && rval && rval != lval && lval->size == rval->size)
+            {
                 /* Compare via checkums */
-                if(CALC_MD5SUMS == false) {
-                    if(!memcmp(lval->data, rval->data, rval->size)) {
+                if (CALC_MD5SUMS == false)
+                {
+                    if (!memcmp (lval->data,rval->data,rval->size) )
+                    {
                         is_duplicate = true;
                     }
-                } else {
-                    if(!memcmp(lval->md5sum, rval->md5sum, 16)) {
+                }
+                else
+                {
+                    if (!memcmp (lval->md5sum,rval->md5sum,16) )
+                    {
                         is_duplicate = true;
                     }
                 }
 
                 /* Delete this element.. */
-                if(is_duplicate == true) {
-                    DL_free(rval);
+                if (is_duplicate == true)
+                {
+                    DL_free (rval);
 
                     /* Delete this ref from the list */
-                    GList *to_free = jnode;
+                    GList * to_free = jnode;
                     jnode = jnode->next;
-                    result = g_list_delete_link(result, to_free);
+                    result = g_list_delete_link (result,to_free);
 
                     /* Remember him.. */
                     double_items++;
@@ -544,52 +602,59 @@ gsize delete_dupes(GList *result, GlyrQuery *s)
 //////////////////////////////////////
 
 // Download a singe file NOT in parallel
-GlyrMemCache *download_single(const char *url, GlyrQuery *s, const char *end)
+GlyrMemCache * download_single (const char* url, GlyrQuery * s, const char * end)
 {
-    if(url != NULL && is_blacklisted((gchar *) url) == false) {
+    if (url != NULL && is_blacklisted ( (gchar*) url) == false)
+    {
         CURL *curl = NULL;
         CURLcode res = 0;
 
         /* Init handles */
         curl = curl_easy_init();
-        GlyrMemCache *dldata = DL_init();
+        GlyrMemCache * dldata = DL_init();
 
         /* DL_buffer needs the 'end' mark.
          * As I didnt want to introduce a new struct just for this
          * I save it in->dsrc */
-        if(end != NULL) {
-            dldata->dsrc = g_strdup(end);
+        if (end != NULL)
+        {
+            dldata->dsrc = g_strdup (end);
         }
 
-        if(curl != NULL) {
+        if (curl != NULL)
+        {
             /* Configure curl */
-            DLBufferContainer *dlbuffer = DL_setopt(curl, dldata, url, s, NULL, (s) ? s->timeout : 5, NULL);
+            DLBufferContainer * dlbuffer = DL_setopt (curl,dldata,url,s,NULL, (s) ? s->timeout : 5, NULL);
 
             /* Perform transaction */
-            res = curl_easy_perform(curl);
+            res = curl_easy_perform (curl);
 
             /* Free the pointer buff */
-            g_free(dlbuffer);
+            g_free (dlbuffer);
 
             /* Better check again */
-            if(res != CURLE_OK && res != CURLE_WRITE_ERROR) {
-                glyr_message(3, s, "glyr: E: singledownload: %s [E:%d]\n", curl_easy_strerror(res), res);
-                DL_free(dldata);
+            if (res != CURLE_OK && res != CURLE_WRITE_ERROR)
+            {
+                glyr_message (3,s,"glyr: E: singledownload: %s [E:%d]\n", curl_easy_strerror (res),res);
+                DL_free (dldata);
                 dldata = NULL;
-            } else {
+            }
+            else
+            {
                 /* Set the source URL */
-                if(dldata->dsrc != NULL) {
-                    g_free(dldata->dsrc);
+                if (dldata->dsrc != NULL)
+                {
+                    g_free (dldata->dsrc);
                 }
 
-                dldata->dsrc = g_strdup(url);
+                dldata->dsrc = g_strdup (url);
             }
 
-            curl_easy_cleanup(curl);
-            update_md5sum(dldata);
+            curl_easy_cleanup (curl);
+            update_md5sum (dldata);
             return dldata;
         }
-        DL_free(dldata);
+        DL_free (dldata);
     }
     return NULL;
 }
@@ -597,10 +662,11 @@ GlyrMemCache *download_single(const char *url, GlyrQuery *s, const char *end)
 //////////////////////////////////////
 
 // Init a callback object and a curl_easy_handle
-static GlyrMemCache *init_async_cache(CURLM *cm, cb_object *capo, GlyrQuery *s, long timeout, gchar *endmark)
+static GlyrMemCache * init_async_cache (CURLM * cm, cb_object * capo, GlyrQuery *s, long timeout, gchar * endmark)
 {
-    GlyrMemCache *dlcache = NULL;
-    if(capo && capo->url) {
+    GlyrMemCache * dlcache = NULL;
+    if (capo && capo->url)
+    {
         /* Init handle */
         CURL *eh = curl_easy_init();
 
@@ -614,10 +680,10 @@ static GlyrMemCache *init_async_cache(CURLM *cm, cb_object *capo, GlyrQuery *s,
         capo->dlbuffer = NULL;
 
         /* Configure this handle */
-        capo->dlbuffer = DL_setopt(eh, dlcache, capo->url, s, (void *) capo, timeout, endmark);
+        capo->dlbuffer = DL_setopt (eh, dlcache, capo->url, s, (void*) capo,timeout, endmark);
 
         /* Add handle to multihandle */
-        curl_multi_add_handle(cm, eh);
+        curl_multi_add_handle (cm, eh);
 
         /* This is set to true once DL_buffer is reached */
         capo->was_buffered = FALSE;
@@ -628,22 +694,24 @@ static GlyrMemCache *init_async_cache(CURLM *cm, cb_object *capo, GlyrQuery *s,
 
 //////////////////////////////////////
 
-static GList *init_async_download(GList *url_list, GList *endmark_list, CURLM *cmHandle, GlyrQuery *s, int abs_timeout)
+static GList * init_async_download (GList * url_list, GList * endmark_list, CURLM * cmHandle, GlyrQuery * s, int abs_timeout)
 {
-    GList *cb_list = NULL;
-    for(GList *elem = url_list; elem; elem = elem->next) {
-        if(is_blacklisted((gchar *) elem->data) == false) {
-            cb_object *obj = g_malloc0(sizeof(cb_object));
+    GList * cb_list = NULL;
+    for (GList * elem = url_list; elem; elem = elem->next)
+    {
+        if (is_blacklisted ( (gchar*) elem->data) == false)
+        {
+            cb_object * obj = g_malloc0 (sizeof (cb_object) );
             obj->s = s;
-            obj->url = g_strdup((gchar *)(elem->data));
-            cb_list = g_list_prepend(cb_list, obj);
+            obj->url = g_strdup ( (gchar*) (elem->data) );
+            cb_list = g_list_prepend (cb_list,obj);
             obj->consumed = FALSE;
 
             /* Get the endmark from the endmark list */
-            gint endmark_pos = g_list_position(url_list, elem);
-            GList *glist_m  = g_list_nth(endmark_list, endmark_pos);
-            gchar *endmark  = (glist_m == NULL) ? NULL : glist_m->data;
-            obj->cache = init_async_cache(cmHandle, obj, s, abs_timeout, endmark);
+            gint endmark_pos = g_list_position (url_list,elem);
+            GList * glist_m  = g_list_nth (endmark_list,endmark_pos);
+            gchar * endmark  = (glist_m==NULL) ? NULL : glist_m->data;
+            obj->cache = init_async_cache (cmHandle,obj,s,abs_timeout,endmark);
         }
     }
     return cb_list;
@@ -651,46 +719,51 @@ static GList *init_async_download(GList *url_list, GList *endmark_list, CURLM *c
 
 //////////////////////////////////////
 
-static void destroy_async_download(GList *cb_list, CURLM *cmHandle, gboolean free_caches)
+static void destroy_async_download (GList * cb_list, CURLM * cmHandle, gboolean free_caches)
 {
     /* Free ressources */
-    curl_multi_cleanup(cmHandle);
-
-    if(cb_list != NULL) {
-        for(GList *elem = cb_list; elem; elem = elem->next) {
-            cb_object *item = elem->data;
-            if(item->handle != NULL) {
-                curl_easy_cleanup(item->handle);
+    curl_multi_cleanup (cmHandle);
+
+    if (cb_list != NULL)
+    {
+        for (GList * elem = cb_list; elem; elem = elem->next)
+        {
+            cb_object * item = elem->data;
+            if (item->handle != NULL)
+            {
+                curl_easy_cleanup (item->handle);
             }
 
             /* Also free unbuffered items, that don't appear in the queue,
              * even if free_caches was set to FALSE
              */
-            if((free_caches == TRUE || item->was_buffered == FALSE)
-                    && item->consumed == FALSE) {
-                DL_free(item->cache);
+            if ( (free_caches == TRUE || item->was_buffered == FALSE)
+                    && item->consumed == FALSE)
+            {
+                DL_free (item->cache);
                 item->cache = NULL;
             }
 
-            g_free(item->dlbuffer);
-            g_free(item->url);
+            g_free (item->dlbuffer);
+            g_free (item->url);
         }
-        glist_free_full(cb_list, g_free);
+        glist_free_full (cb_list,g_free);
     }
 }
 
 //////////////////////////////////////
 /* ----------------- THE HEART OF GOLD ------------------ */
 //////////////////////////////////////
-GList *async_download(GList *url_list, GList *endmark_list, GlyrQuery *s, long parallel_fac, long timeout_fac, AsyncDLCB asdl_callback, void *userptr, gboolean free_caches)
+GList * async_download (GList * url_list, GList * endmark_list, GlyrQuery * s, long parallel_fac, long timeout_fac, AsyncDLCB asdl_callback, void * userptr, gboolean free_caches)
 {
     /* Storage for result items */
-    GList *item_list = NULL;
+    GList * item_list = NULL;
 
-    if(url_list != NULL && s != NULL) {
+    if (url_list != NULL && s != NULL)
+    {
         /* total timeout and parallel tries */
-        long abs_timeout  = ABS(timeout_fac  * s->timeout);
-        long abs_parallel = ABS(parallel_fac * s->parallel);
+        long abs_timeout  = ABS (timeout_fac  * s->timeout);
+        long abs_parallel = ABS (parallel_fac * s->parallel);
 
         /* select() control */
         int max_fd, queue_msg, running_handles = -1;
@@ -698,57 +771,64 @@ GList *async_download(GList *url_list, GList *endmark_list, GlyrQuery *s, long p
         fd_set ReadFDS, WriteFDS, ErrorFDS;
 
         /* Curl Multi Handles (~ container for easy handlers) */
-        CURLM    *cmHandle = curl_multi_init();
-        curl_multi_setopt(cmHandle, CURLMOPT_MAXCONNECTS, abs_parallel);
-        curl_multi_setopt(cmHandle, CURLMOPT_PIPELINING, 1L);
+        CURLM   * cmHandle = curl_multi_init();
+        curl_multi_setopt (cmHandle, CURLMOPT_MAXCONNECTS,abs_parallel);
+        curl_multi_setopt (cmHandle, CURLMOPT_PIPELINING, 1L);
 
         /* Once set to true this will terminate the download */
         gboolean terminate = FALSE;
 
         /* Now create cb_objects */
-        GList *cb_list = init_async_download(url_list, endmark_list, cmHandle, s, abs_timeout);
+        GList * cb_list = init_async_download (url_list,endmark_list,cmHandle,s,abs_timeout);
 
-        while(GET_ATOMIC_SIGNAL_EXIT(s) == FALSE && running_handles != 0 && terminate == FALSE) {
+        while (GET_ATOMIC_SIGNAL_EXIT (s) == FALSE && running_handles != 0 && terminate == FALSE)
+        {
             CURLMcode merr = CURLM_CALL_MULTI_PERFORM;
-            while(merr == CURLM_CALL_MULTI_PERFORM) {
-                merr = curl_multi_perform(cmHandle, &running_handles);
+            while (merr == CURLM_CALL_MULTI_PERFORM)
+            {
+                merr = curl_multi_perform (cmHandle, &running_handles);
             }
-            if(merr != CURLM_OK) {
-                glyr_message(1, s, "Error: curl_multi_perform() failed!");
+            if (merr != CURLM_OK)
+            {
+                glyr_message (1,s,"Error: curl_multi_perform() failed!");
                 return NULL;
             }
 
-            if(running_handles != 0) {
+            if (running_handles != 0)
+            {
                 /* Set up fds */
-                FD_ZERO(&ReadFDS);
-                FD_ZERO(&WriteFDS);
-                FD_ZERO(&ErrorFDS);
-
-                if(curl_multi_fdset(cmHandle, &ReadFDS, &WriteFDS, &ErrorFDS, &max_fd) ||
-                        curl_multi_timeout(cmHandle, &wait_time)) {
-                    glyr_message(1, s, "Error while selecting stream. Might be a bug.\n");
+                FD_ZERO (&ReadFDS);
+                FD_ZERO (&WriteFDS);
+                FD_ZERO (&ErrorFDS);
+
+                if (curl_multi_fdset (cmHandle, &ReadFDS, &WriteFDS, &ErrorFDS, &max_fd) ||
+                        curl_multi_timeout (cmHandle, &wait_time) )
+                {
+                    glyr_message (1,s,"Error while selecting stream. Might be a bug.\n");
                     return NULL;
                 }
 
-                if(wait_time == -1) {
+                if (wait_time == -1)
                     wait_time = 100;
-                }
 
-                if(wait_time >= s->timeout * 1000) {
+                if (wait_time >= s->timeout * 1000)
                     wait_time = s->timeout * 1000;
-                }
 
                 /* Nothing happens.. */
-                if(max_fd == -1) {
-                    g_usleep(wait_time * 100);
-                } else {
+                if (max_fd == -1)
+                {
+                    g_usleep (wait_time * 100);
+                }
+                else
+                {
                     struct timeval Tmax;
-                    Tmax.tv_sec  = (wait_time / 1000);
-                    Tmax.tv_usec = (wait_time % 1000) * 1000;
+                    Tmax.tv_sec  = (wait_time/1000);
+                    Tmax.tv_usec = (wait_time%1000) *1000;
 
                     /* Now block till something interesting happens with the download */
-                    if(select(max_fd + 1, &ReadFDS, &WriteFDS, &ErrorFDS, &Tmax) == -1) {
-                        glyr_message(1, s, "Error: select(%i <=> %li): %i: %s\n", max_fd + 1, wait_time, errno, strerror(errno));
+                    if (select (max_fd+1, &ReadFDS, &WriteFDS, &ErrorFDS, &Tmax) == -1)
+                    {
+                        glyr_message (1,s,"Error: select(%i <=> %li): %i: %s\n",max_fd+1, wait_time, errno, strerror (errno) );
                         return NULL;
                     }
                 }
@@ -756,24 +836,27 @@ GList *async_download(GList *url_list, GList *endmark_list, GlyrQuery *s, long p
 
 
             /* select() returned. There might be some fresh flesh! - Check. */
-            CURLMsg *msg;
-            while(GET_ATOMIC_SIGNAL_EXIT(s) == FALSE &&
+            CURLMsg * msg;
+            while (GET_ATOMIC_SIGNAL_EXIT (s) == FALSE &&
                     terminate == FALSE &&
-                    (msg = curl_multi_info_read(cmHandle, &queue_msg))) {
+                    (msg = curl_multi_info_read (cmHandle, &queue_msg) ) )
+            {
                 /* That download is ready to be viewed */
-                if(msg->msg == CURLMSG_DONE) {
+                if (msg->msg == CURLMSG_DONE)
+                {
                     /* Easy handle of this particular DL */
                     CURL *easy_handle = msg->easy_handle;
 
                     /* Get the callback object associated with the curl handle
                      * for some odd reason curl requires a char * pointer */
-                    cb_object *capo = NULL;
-                    curl_easy_getinfo(msg->easy_handle, CURLINFO_PRIVATE, (((char **) &capo)));
+                    cb_object * capo = NULL;
+                    curl_easy_getinfo (msg->easy_handle, CURLINFO_PRIVATE, ( ( (char**) &capo) ) );
 
                     /* It's useless if it's empty  */
-                    if(capo && capo->cache && capo->cache->data == NULL) {
+                    if (capo && capo->cache && capo->cache->data == NULL)
+                    {
                         capo->consumed = TRUE;
-                        DL_free(capo->cache);
+                        DL_free (capo->cache);
                         capo->cache = NULL;
                     }
 
@@ -781,94 +864,110 @@ GList *async_download(GList *url_list, GList *endmark_list, GlyrQuery *s, long p
                     capo->was_buffered = TRUE;
 
                     /* capo contains now the downloaded cache, ready to parse */
-                    if(msg->data.result == CURLE_OK && capo && capo->cache) {
+                    if (msg->data.result == CURLE_OK && capo && capo->cache)
+                    {
                         /* How many items from the callback will actually be added */
                         gint to_add = 0;
 
                         /* Stop download after this came in */
                         bool stop_download = false;
-                        GList *cb_results = NULL;
+                        GList * cb_results = NULL;
 
                         /* Set origin */
-                        if(capo->cache->dsrc != NULL) {
-                            g_free(capo->cache->dsrc);
+                        if (capo->cache->dsrc != NULL)
+                        {
+                            g_free (capo->cache->dsrc);
                         }
-                        capo->cache->dsrc = g_strdup(capo->url);
+                        capo->cache->dsrc = g_strdup (capo->url);
 
                         /* Call it if present */
-                        if(asdl_callback != NULL) {
+                        if (asdl_callback != NULL)
+                        {
                             /* Add parsed results or nothing if parsed result is empty */
-                            cb_results = asdl_callback(capo, userptr, &stop_download, &to_add);
+                            cb_results = asdl_callback (capo,userptr,&stop_download,&to_add);
                         }
 
-                        if(cb_results != NULL) {
+                        if (cb_results != NULL)
+                        {
                             /* Fill in the source filed (dsrc) if not already done */
-                            for(GList *elem = cb_results; elem; elem = elem->next) {
-                                GlyrMemCache *item = elem->data;
-                                if(item && item->dsrc == NULL) {
+                            for (GList * elem = cb_results; elem; elem = elem->next)
+                            {
+                                GlyrMemCache * item = elem->data;
+                                if (item && item->dsrc == NULL)
+                                {
                                     /* Plugin didn't do any special download */
-                                    item->dsrc = g_strdup(capo->url);
+                                    item->dsrc = g_strdup (capo->url);
                                 }
-                                item_list = g_list_prepend(item_list, item);
+                                item_list = g_list_prepend (item_list,item);
                             }
-                            g_list_free(cb_results);
-                        } else if(to_add != 0) {
+                            g_list_free (cb_results);
+                        }
+                        else if (to_add != 0)
+                        {
                             /* Add it as raw data */
-                            item_list = g_list_prepend(item_list, capo->cache);
-                        } else {
+                            item_list = g_list_prepend (item_list,capo->cache);
+                        }
+                        else
+                        {
                             capo->consumed = TRUE;
-                            DL_free(capo->cache);
+                            DL_free (capo->cache);
                             capo->cache = NULL;
                         }
 
                         /* So, shall we stop? */
                         terminate = stop_download;
 
-                    } else {
+                    }
+                    else
+                    {
                         /* Something in this download was wrong. Tell us what. */
-                        char *errstring = (char *) curl_easy_strerror(msg->data.result);
-                        glyr_message(3, capo->s, "- glyr: Downloaderror: %s [errno:%d]\n",
-                                     errstring ? errstring : "Unknown Error",
-                                     msg->data.result);
+                        char * errstring = (char*) curl_easy_strerror (msg->data.result);
+                        glyr_message (3,capo->s,"- glyr: Downloaderror: %s [errno:%d]\n",
+                                      errstring ? errstring : "Unknown Error",
+                                      msg->data.result);
 
-                        glyr_message(3, capo->s, "  On URL: ");
-                        glyr_message(3, capo->s, "%s\n", capo->url);
+                        glyr_message (3,capo->s,"  On URL: ");
+                        glyr_message (3,capo->s,"%s\n",capo->url);
 
-                        DL_free(capo->cache);
+                        DL_free (capo->cache);
                         capo->cache = NULL;
                         capo->consumed = TRUE;
                     }
 
                     /* We're done with this one.. bybebye */
-                    curl_multi_remove_handle(cmHandle, easy_handle);
-                    curl_easy_cleanup(easy_handle);
+                    curl_multi_remove_handle (cmHandle,easy_handle);
+                    curl_easy_cleanup (easy_handle);
                     capo->handle = NULL;
-                } else {
+                }
+                else
+                {
                     /* Something in the multidownloading gone wrong */
-                    glyr_message(1, s, "Error: multiDownload-errorcode: %d\n", msg->msg);
+                    glyr_message (1,s,"Error: multiDownload-errorcode: %d\n",msg->msg);
                 }
             }
         }
-        destroy_async_download(cb_list, cmHandle, free_caches);
+        destroy_async_download (cb_list,cmHandle,free_caches);
     }
     return item_list;
 }
 
 //////////////////////////////////////
 
-struct wrap_retrieve_pass_data {
-    gchar *url;
-    GlyrQuery *query;
+struct wrap_retrieve_pass_data
+{
+    gchar * url;
+    GlyrQuery * query;
 };
 
-static void *wrap_retrieve_content(gpointer data)
+static void * wrap_retrieve_content (gpointer data)
 {
-    struct header_data *head = NULL;
-    if(data != NULL) {
-        struct wrap_retrieve_pass_data *passed = data;
-        GlyrQuery *query = passed->query;
-        head = retrieve_content_info(passed->url, (gchar *) query->proxy, (gchar *) query->useragent, query);
-        g_free(passed);
+    struct header_data * head = NULL;
+    if (data != NULL)
+    {
+        struct wrap_retrieve_pass_data * passed = data;
+        GlyrQuery * query = passed->query;
+        head = retrieve_content_info (passed->url, (gchar*) query->proxy, (gchar*) query->useragent,query);
+        g_free (passed);
         passed = NULL;
     }
     return head;
@@ -876,77 +975,90 @@ static void *wrap_retrieve_content(gpointer data)
 
 //////////////////////////////////////
 
-static void check_all_types_in_url_list(GList *cache_list, GlyrQuery *s)
+static void check_all_types_in_url_list (GList * cache_list, GlyrQuery * s)
 {
-    if(cache_list != NULL) {
-        GHashTable *thread_id_table = g_hash_table_new(g_direct_hash, g_direct_equal);
-        GList *thread_list = NULL;
-
-        glyr_message(2, s, "#[%02d/%02d] Checking image-types: [", s->itemctr, s->number);
-
-        for(GList *elem = cache_list; elem; elem = elem->next) {
-            GlyrMemCache *item = elem->data;
-            if(item != NULL) {
-                struct wrap_retrieve_pass_data *passer = g_malloc0(sizeof(struct wrap_retrieve_pass_data));
+    if (cache_list != NULL)
+    {
+        GHashTable * thread_id_table = g_hash_table_new (g_direct_hash,g_direct_equal);
+        GList * thread_list = NULL;
+
+        glyr_message (2,s,"#[%02d/%02d] Checking image-types: [",s->itemctr,s->number);
+
+        for (GList * elem = cache_list; elem; elem = elem->next)
+        {
+            GlyrMemCache * item = elem->data;
+            if (item != NULL)
+            {
+                struct wrap_retrieve_pass_data * passer = g_malloc0 (sizeof (struct wrap_retrieve_pass_data) );
                 passer->url   = item->data;
                 passer->query = s;
 
-                GThread *thread = g_thread_new("content_retriever",
-                                               (GThreadFunc) wrap_retrieve_content,
-                                               passer);
+                GThread * thread = g_thread_new("content_retriever",
+                        (GThreadFunc) wrap_retrieve_content,
+                        passer);
 
-                if(thread != NULL) {
-                    thread_list = g_list_prepend(thread_list, thread);
+                if (thread != NULL)
+                {
+                    thread_list = g_list_prepend (thread_list,thread);
                 }
-                g_hash_table_insert(thread_id_table, thread, item);
+                g_hash_table_insert (thread_id_table,thread,item);
             }
         }
 
-        for(GList *thread = thread_list; thread; thread = thread->next) {
+        for (GList * thread = thread_list; thread; thread = thread->next)
+        {
             gboolean success = FALSE;
-            struct header_data *info = g_thread_join(thread->data);
-            if(info != NULL) {
-                GlyrMemCache *linked_cache = g_hash_table_lookup(thread_id_table, thread->data);
-                if(linked_cache != NULL) {
-                    if(g_strcmp0(info->type, "image") == 0) {
-                        linked_cache->img_format = g_strdup(info->format);
+            struct header_data * info = g_thread_join (thread->data);
+            if (info != NULL)
+            {
+                GlyrMemCache * linked_cache = g_hash_table_lookup (thread_id_table,thread->data);
+                if (linked_cache != NULL)
+                {
+                    if (g_strcmp0 (info->type,"image") == 0)
+                    {
+                        linked_cache->img_format = g_strdup (info->format);
                         success = TRUE;
                     }
-                } else {
-                    glyr_message(1, s, "glyr: Uh oh.. empty link in hashtable..\n");
                 }
-                g_free(info->format);
-                g_free(info->type);
-                g_free(info->extra);
-                g_free(info);
+                else
+                {
+                    glyr_message (1,s,"glyr: Uh oh.. empty link in hashtable..\n");
+                }
+                g_free (info->format);
+                g_free (info->type);
+                g_free (info->extra);
+                g_free (info);
             }
 
-            glyr_message(2, s, "%c", (success) ? '.' : '!');
+            glyr_message (2,s,"%c", (success) ? '.' : '!');
         }
-        g_list_free(thread_list);
-        g_hash_table_destroy(thread_id_table);
-        glyr_message(2, s, "]");
+        g_list_free (thread_list);
+        g_hash_table_destroy (thread_id_table);
+        glyr_message (2,s,"]");
     }
 }
 
 //////////////////////////////////////
 
-static gboolean format_is_allowed(gchar *format, gchar *allowed)
+static gboolean format_is_allowed (gchar * format, gchar * allowed)
 {
     /* Let everything pass */
-    if(allowed == NULL) {
+    if (allowed == NULL)
+    {
         return TRUE;
     }
 
     gboolean result = FALSE;
-    if(format != NULL && allowed != NULL) {
-        gchar *token;
+    if (format != NULL && allowed != NULL)
+    {
+        gchar * token;
         gsize offset = 0;
-        gsize len = strlen(allowed);
+        gsize len = strlen (allowed);
 
-        while(!result && (token = get_next_word(allowed, GLYR_DEFAULT_FROM_ARGUMENT_DELIM, &offset, len)) != NULL) {
-            result = (g_strcmp0(token, format) == 0);
-            g_free(token);
+        while (!result && (token = get_next_word (allowed,GLYR_DEFAULT_FROM_ARGUMENT_DELIM,&offset,len) ) != NULL)
+        {
+            result = (g_strcmp0 (token,format) == 0);
+            g_free (token);
         }
     }
     return result;
@@ -955,28 +1067,32 @@ static gboolean format_is_allowed(gchar *format, gchar *allowed)
 
 //////////////////////////////////////
 
-static gint delete_wrong_formats(GList **list, GlyrQuery *s)
+static gint delete_wrong_formats (GList ** list, GlyrQuery * s)
 {
     /* Now compare it agains the format. */
     gsize invalid_format_counter = 0;
-    GList *new_head = *list;
-    GList *elem = new_head;
+    GList * new_head = *list;
+    GList * elem = new_head;
 
-    gchar *allowed_formats = s->allowed_formats;
-    if(allowed_formats == NULL) {
+    gchar * allowed_formats = s->allowed_formats;
+    if (allowed_formats == NULL)
+    {
         allowed_formats = GLYR_DEFAULT_ALLOWED_FORMATS;
     }
 
-    while(elem != NULL) {
-        GlyrMemCache *item = elem->data;
-        if(item != NULL) {
-            if(format_is_allowed(item->img_format, allowed_formats) == FALSE) {
-                GList *to_delete = elem;
+    while (elem != NULL)
+    {
+        GlyrMemCache * item = elem->data;
+        if (item != NULL)
+        {
+            if (format_is_allowed (item->img_format,allowed_formats) == FALSE)
+            {
+                GList * to_delete = elem;
                 elem = elem->next;
                 invalid_format_counter++;
 
-                new_head = g_list_delete_link(new_head, to_delete);
-                DL_free(item);
+                new_head = g_list_delete_link (new_head,to_delete);
+                DL_free (item);
                 item = NULL;
                 continue;
             }
@@ -990,39 +1106,43 @@ static gint delete_wrong_formats(GList **list, GlyrQuery *s)
 
 //////////////////////////////////////
 
-static GList *kick_out_wrong_formats(GList *data_list, GlyrQuery *s)
+static GList * kick_out_wrong_formats (GList * data_list, GlyrQuery * s)
 {
-    GList *new_head = data_list;
+    GList * new_head = data_list;
 
     /* Parallely check if the format is what we wanted */
-    check_all_types_in_url_list(new_head, s);
+    check_all_types_in_url_list (new_head,s);
 
     /* Kick the wrong ones */
-    gint invalid_format_counter = delete_wrong_formats(&new_head, s);
+    gint invalid_format_counter = delete_wrong_formats (&new_head,s);
 
-    glyr_message(2, s, " (-%d item(s) less)\n", invalid_format_counter);
+    glyr_message (2,s," (-%d item(s) less)\n",invalid_format_counter);
     return new_head;
 }
 
 //////////////////////////////////////
 
-static void do_charset_conversion(MetaDataSource *source, GList *text_list)
+static void do_charset_conversion (MetaDataSource * source, GList * text_list)
 {
-    if(source != NULL && text_list != NULL) {
-        for(GList *elem = text_list; elem; elem = elem->next) {
-            GlyrMemCache *cache = elem->data;
+    if (source != NULL && text_list != NULL)
+    {
+        for (GList * elem = text_list; elem; elem = elem->next)
+        {
+            GlyrMemCache * cache = elem->data;
 
             /* We might need to unescape the HTML Utf8 encoded strings first, this is done later anyway. */
-            gchar *utf8_string = unescape_html_UTF8(cache->data);
-            if(utf8_string != NULL) {
+            gchar * utf8_string = unescape_html_UTF8 (cache->data);
+            if (utf8_string != NULL)
+            {
                 gsize new_len;
-                gchar *conv = convert_charset(utf8_string, "UTF-8", source->encoding, &new_len);
-                if(conv != NULL) {
+                gchar * conv = convert_charset (utf8_string,"UTF-8",source->encoding,&new_len);
+                if (conv != NULL)
+                {
                     cache->size = new_len;
-                    g_free(cache->data);
+                    g_free (cache->data);
                     cache->data = conv;
                 }
-                g_free(utf8_string);
+                g_free (utf8_string);
             }
         }
     }
@@ -1030,53 +1150,62 @@ static void do_charset_conversion(MetaDataSource *source, GList *text_list)
 
 //////////////////////////////////////
 
-static GList *check_for_forced_utf8(GlyrQuery *query, GList *text_list)
+static GList * check_for_forced_utf8 (GlyrQuery * query, GList * text_list)
 {
     gint deleted = 0;
-    GList *new_head = text_list;
-    if(query != NULL && text_list != NULL && query->force_utf8 == TRUE) {
-        glyr_message(2, query, "#[%02d/%02d] Checking encoding [", g_list_length(text_list), query->number);
-
-        GList *elem = text_list;
-        while(elem != NULL) {
-            GlyrMemCache *cache = elem->data;
-
-            const gchar *end_of_valid_utf8 = NULL;
-            if(cache && g_utf8_validate(cache->data, cache->size, &end_of_valid_utf8) == FALSE) {
+    GList * new_head = text_list;
+    if (query != NULL && text_list != NULL && query->force_utf8 == TRUE)
+    {
+        glyr_message (2,query,"#[%02d/%02d] Checking encoding [",g_list_length (text_list),query->number);
+
+        GList * elem = text_list;
+        while (elem != NULL)
+        {
+            GlyrMemCache * cache = elem->data;
+
+            const gchar * end_of_valid_utf8 = NULL;
+            if (cache && g_utf8_validate (cache->data,cache->size,&end_of_valid_utf8) == FALSE)
+            {
                 /* UTF8 was forced, and this cache didn't pass -> deletre */
-                glyr_message(2, query, "!");
+                glyr_message (2,query,"!");
 
-                DL_free(cache);
+                DL_free (cache);
                 deleted++;
 
-                GList *to_delete = elem;
+                GList * to_delete = elem;
                 elem = elem->next;
-                new_head = g_list_delete_link(new_head, to_delete);
+                new_head = g_list_delete_link (new_head,to_delete);
                 continue;
-            } else {
-                glyr_message(2, query, ".");
+            }
+            else
+            {
+                glyr_message (2,query,".");
                 elem = elem->next;
             }
         }
-        glyr_message(2, query, "] (-%d item(s) less)\n", deleted);
+        glyr_message (2,query,"] (-%d item(s) less)\n",deleted);
     }
     return new_head;
 }
 
 //////////////////////////////////////
 
-static void normalize_utf8(GList *text_list)
+static void normalize_utf8 (GList * text_list)
 {
-    for(GList *elem = text_list; elem; elem = elem->next) {
-        GlyrMemCache *cache = elem->data;
-        if(cache != NULL && cache->data) {
-            if(g_utf8_validate(cache->data, -1, NULL) != FALSE) {
-                gchar *normalized_utf8 = g_utf8_normalize(cache->data, -1, G_NORMALIZE_NFKC);
-                if(normalized_utf8 != NULL) {
+    for (GList * elem = text_list; elem; elem = elem->next)
+    {
+        GlyrMemCache * cache = elem->data;
+        if (cache != NULL && cache->data)
+        {
+            if (g_utf8_validate (cache->data,-1,NULL) != FALSE)
+            {
+                gchar * normalized_utf8 = g_utf8_normalize (cache->data,-1,G_NORMALIZE_NFKC);
+                if (normalized_utf8 != NULL)
+                {
                     /* Swap cache contents */
-                    g_free(cache->data);
+                    g_free (cache->data);
                     cache->data = normalized_utf8;
-                    cache->size = strlen(normalized_utf8);
+                    cache->size = strlen (normalized_utf8);
                 }
             }
         }
@@ -1085,27 +1214,32 @@ static void normalize_utf8(GList *text_list)
 
 //////////////////////////////////////
 
-static gint delete_already_cached_items(cb_object *capo, GList **list)
+static gint delete_already_cached_items (cb_object * capo, GList ** list)
 {
-    if(capo->s->db_autoread == FALSE) {
+    if (capo->s->db_autoread == FALSE)
+    {
         return 0;
     }
 
     gint deleted = 0;
-    if(capo && capo->s->local_db) {
-        GList *elem = *list;
-        while(elem != NULL) {
-            GlyrMemCache *item = elem->data;
-            if(item != NULL && item->dsrc == NULL && capo->s->imagejob) {
-                item->dsrc = g_strdup(item->data);
+    if (capo && capo->s->local_db)
+    {
+        GList * elem = *list;
+        while (elem != NULL)
+        {
+            GlyrMemCache * item = elem->data;
+            if (item != NULL && item->dsrc == NULL && capo->s->imagejob)
+            {
+                item->dsrc = g_strdup (item->data);
             }
 
-            if(item && db_contains(capo->s->local_db, item)) {
-                GList *to_delete = elem;
+            if (item && db_contains (capo->s->local_db,item) )
+            {
+                GList * to_delete = elem;
                 elem = elem->next;
-                *list = g_list_delete_link(*list, to_delete);
+                *list= g_list_delete_link (*list,to_delete);
 
-                DL_free(item);
+                DL_free (item);
                 deleted++;
                 continue;
             }
@@ -1117,14 +1251,19 @@ static gint delete_already_cached_items(cb_object *capo, GList **list)
 
 //////////////////////////////////////
 
-static void fix_data_types(GList *list, MetaDataSource *src, GlyrQuery *query)
+static void fix_data_types (GList * list, MetaDataSource * src, GlyrQuery * query)
 {
-    for(GList *elem = list; elem; elem = elem->next) {
-        GlyrMemCache *item = elem->data;
-        if(item != NULL && item->type == GLYR_TYPE_UNKNOWN) {
-            if(TYPE_IS_IMAGE(query->type) && query->download == FALSE) {
+    for (GList * elem = list; elem; elem = elem->next)
+    {
+        GlyrMemCache * item = elem->data;
+        if (item != NULL && item->type == GLYR_TYPE_UNKNOWN)
+        {
+            if (TYPE_IS_IMAGE (query->type) && query->download == FALSE)
+            {
                 item->type = GLYR_TYPE_IMG_URL;
-            } else {
+            }
+            else
+            {
                 item->type = src->data_type;
             }
         }
@@ -1135,61 +1274,77 @@ static void fix_data_types(GList *list, MetaDataSource *src, GlyrQuery *query)
 //////////////////////////////////////
 
 /* The actual call to the metadata provider here, coming from the downloader, triggered by start_engine() */
-static GList *call_provider_callback(cb_object *capo, void *userptr, bool *stop_download, gint *to_add)
+static GList * call_provider_callback (cb_object * capo, void * userptr, bool * stop_download, gint * to_add)
 {
-    GList *parsed = NULL;
-    if(userptr != NULL) {
+    GList * parsed = NULL;
+    if (userptr != NULL)
+    {
         /* Get MetaDataSource correlated to this URL */
-        GHashTable *assoc = (GHashTable *) userptr;
-        MetaDataSource *plugin = g_hash_table_lookup(assoc, capo->url);
+        GHashTable * assoc = (GHashTable*) userptr;
+        MetaDataSource * plugin = g_hash_table_lookup (assoc,capo->url);
 
-        if(plugin != NULL) {
-            if(capo->s->itemctr < capo->s->number) {
+        if (plugin != NULL)
+        {
+            if (capo->s->itemctr < capo->s->number)
+            {
                 /* Call the provider's parser */
-                GList *raw_parsed_data = plugin->parser(capo);
+                GList * raw_parsed_data = plugin->parser (capo);
 
                 /* Set the default type if not known otherwise */
-                fix_data_types(raw_parsed_data, plugin, capo->s);
+                fix_data_types (raw_parsed_data,plugin,capo->s);
 
                 /* Also do some duplicate check already */
-                gsize less = delete_dupes(raw_parsed_data, capo->s);
-                if(less > 0) {
-                    gsize items_now = g_list_length(raw_parsed_data) + capo->s->itemctr - less;
-                    glyr_message(2, capo->s, "#[%02d/%02d] Inner check found %ld dupes\n", items_now, capo->s->number, less);
+                gsize less = delete_dupes (raw_parsed_data,capo->s);
+                if (less > 0)
+                {
+                    gsize items_now = g_list_length (raw_parsed_data) + capo->s->itemctr - less;
+                    glyr_message (2,capo->s,"#[%02d/%02d] Inner check found %ld dupes\n",items_now,capo->s->number,less);
                 }
 
                 /* Look up if items already in cache */
-                less = delete_already_cached_items(capo, &raw_parsed_data);
-                if(less > 0) {
-                    gsize items_now = g_list_length(raw_parsed_data) + capo->s->itemctr - less;
-                    glyr_message(2, capo->s, "#[%02d/%02d] DB lookup found %ld dupes\n", items_now, capo->s->number, less);
+                less = delete_already_cached_items (capo,&raw_parsed_data);
+                if (less > 0)
+                {
+                    gsize items_now = g_list_length (raw_parsed_data) + capo->s->itemctr - less;
+                    glyr_message (2,capo->s,"#[%02d/%02d] DB lookup found %ld dupes\n",items_now,capo->s->number,less);
                 }
 
                 /* Any items left to kill? */
-                if(g_list_length(raw_parsed_data) != 0) {
+                if (g_list_length (raw_parsed_data) != 0)
+                {
                     /* We shouldn't check (e.g) lyrics if they are a valid URL ;-) */
-                    if(capo->s->imagejob == TRUE) {
-                        raw_parsed_data = kick_out_wrong_formats(raw_parsed_data, capo->s);
-                    } else { /* We should look if charset conversion is requested */
-                        normalize_utf8(raw_parsed_data);
-                        if(plugin->encoding != NULL) {
-                            glyr_message(2, capo->s, "#[%02d/%02d] Attempting to convert charsets\n", g_list_length(raw_parsed_data), capo->s->number);
-                            do_charset_conversion(plugin, raw_parsed_data);
+                    if (capo->s->imagejob == TRUE)
+                    {
+                        raw_parsed_data = kick_out_wrong_formats (raw_parsed_data,capo->s);
+                    }
+                    else /* We should look if charset conversion is requested */
+                    {
+                        normalize_utf8 (raw_parsed_data);
+                        if (plugin->encoding != NULL)
+                        {
+                            glyr_message (2,capo->s,"#[%02d/%02d] Attempting to convert charsets\n",g_list_length (raw_parsed_data),capo->s->number);
+                            do_charset_conversion (plugin, raw_parsed_data);
                         }
-                        raw_parsed_data = check_for_forced_utf8(capo->s, raw_parsed_data);
+                        raw_parsed_data = check_for_forced_utf8 (capo->s,raw_parsed_data);
                     }
 
-                    if(g_list_length(raw_parsed_data) != 0) {
-                        for(GList *elem = raw_parsed_data; elem; elem = elem->next) {
-                            GlyrMemCache *item = elem->data;
-                            if(item != NULL) {
-                                if(capo->s->itemctr < capo->s->number) {
+                    if (g_list_length (raw_parsed_data) != 0)
+                    {
+                        for (GList * elem = raw_parsed_data; elem; elem = elem->next)
+                        {
+                            GlyrMemCache * item = elem->data;
+                            if (item != NULL)
+                            {
+                                if (capo->s->itemctr < capo->s->number)
+                                {
                                     /* Only reference to the plugin -> copy providername */
-                                    item->prov = g_strdup(plugin->name);
-                                    parsed = g_list_prepend(parsed, item);
+                                    item->prov = g_strdup (plugin->name);
+                                    parsed = g_list_prepend (parsed,item);
                                     capo->s->itemctr++;
-                                } else { /* Not needed anymore. Forget this item */
-                                    DL_free(item);
+                                }
+                                else /* Not needed anymore. Forget this item */
+                                {
+                                    DL_free (item);
                                     item = NULL;
 
                                     /* Also skip other downloads */
@@ -1199,23 +1354,27 @@ static GList *call_provider_callback(cb_object *capo, void *userptr, bool *stop_
                         }
 
                         /* Forget those pointers */
-                        g_list_free(raw_parsed_data);
+                        g_list_free (raw_parsed_data);
                     }
                 }
             }
-        } else {
-            glyr_message(1, capo->s, "glyr: hashmap lookup failed. Cannot call plugin => Bug.\n");
+        }
+        else
+        {
+            glyr_message (1,capo->s,"glyr: hashmap lookup failed. Cannot call plugin => Bug.\n");
         }
 
     }
     /* We replace the cache with a new one -> free the old one */
-    if(capo->cache != NULL) {
-        DL_free(capo->cache);
+    if (capo->cache != NULL)
+    {
+        DL_free (capo->cache);
         capo->cache = NULL;
     }
 
     /* Do not add raw data */
-    if(parsed == NULL) {
+    if (parsed == NULL)
+    {
         *to_add = 0;
     }
 
@@ -1224,17 +1383,19 @@ static GList *call_provider_callback(cb_object *capo, void *userptr, bool *stop_
 
 //////////////////////////////////////
 
-gboolean provider_is_enabled(GlyrQuery *q, MetaDataSource *f)
+gboolean provider_is_enabled (GlyrQuery * q, MetaDataSource * f)
 {
-    if(q->lang_aware_only &&
+    if (q->lang_aware_only &&
             f->lang_aware == false &&
             q->imagejob == false   &&
-            g_strcmp0(f->name, "local") != 0) {
+            g_strcmp0 (f->name,"local") != 0)
+    {
         return FALSE;
     }
 
     /* Assume 'all we have' */
-    if(q->from == NULL) {
+    if (q->from == NULL)
+    {
         return TRUE;
     }
 
@@ -1244,31 +1405,33 @@ gboolean provider_is_enabled(GlyrQuery *q, MetaDataSource *f)
     gboolean all_occured = FALSE;
 
     /* split string */
-    if(f->name != NULL) {
-        gsize name_len = strlen(f->name);
-        gsize len = strlen(q->from);
+    if (f->name != NULL)
+    {
+        gsize name_len = strlen (f->name);
+        gsize len = strlen (q->from);
         gsize offset = 0;
 
-        gchar *token = NULL;
-        while((token = get_next_word(q->from, GLYR_DEFAULT_FROM_ARGUMENT_DELIM, &offset, len))) {
-            if(token != NULL) {
-                gsize token_len = strlen(token);
-                gchar *back = token;
+        gchar * token = NULL;
+        while ( (token = get_next_word (q->from,GLYR_DEFAULT_FROM_ARGUMENT_DELIM,&offset,len) ) )
+        {
+            if (token != NULL)
+            {
+                gsize token_len = strlen (token);
+                gchar * back = token;
 
                 gboolean minus;
-                if((minus = token[0] == '-') || token[0] == '+') {
+                if ( (minus = token[0] == '-') || token[0] == '+')
                     token++;
-                }
 
-                if(!g_ascii_strncasecmp(token, "all", token_len)) {
+                if (!g_ascii_strncasecmp (token,"all",token_len) )
                     all_occured = TRUE;
-                }
 
-                if((token[0] == f->key && token_len == 1) || !g_ascii_strncasecmp(token, f->name, name_len)) {
+                if ( (token[0] == f->key && token_len == 1) || !g_ascii_strncasecmp (token,f->name,name_len) )
+                {
                     is_excluded =  minus;
                     is_found    = !minus;
                 }
-                g_free(back);
+                g_free (back);
             }
         }
     }
@@ -1277,29 +1440,34 @@ gboolean provider_is_enabled(GlyrQuery *q, MetaDataSource *f)
 
 //////////////////////////////////////
 
-/* GnuPlot: plot3d(1/X*Y + (100-Y)*1/(1-X) + 1000, X, .1, .9], Y, , 00]); */
-static gfloat calc_rating(gfloat qsratio, gint quality, gint speed)
+/* GnuPlot: plot3d(1/X*Y + (100-Y)*1/(1-X) + 1000,[X,0.1,0.9],[Y,0,100]); */
+static gfloat calc_rating (gfloat qsratio, gint quality, gint speed)
 {
-    gfloat cratio = CLAMP(qsratio, 0.1, 0.9);
-    return 1000.0f + ((1.0 / (1 - cratio) * quality) + (1.0 / cratio * speed));
+    gfloat cratio = CLAMP (qsratio,0.1,0.9);
+    return 1000.0f + ( (1.0/ (1-cratio) *quality) + (1.0/cratio*speed) );
 }
 
 //////////////////////////////////////
 
-static GList *get_queued(GlyrQuery *s, MetaDataFetcher *fetcher, gint *fired)
+static GList * get_queued (GlyrQuery * s, MetaDataFetcher * fetcher, gint * fired)
 {
-    GList *source_list = NULL;
-    for(gint it = 0; it < s->parallel; it++) {
+    GList * source_list = NULL;
+    for (gint it = 0; it < s->parallel; it++)
+    {
         gint pos = 0;
         gint max_pos = -1;
         gfloat max = G_MINFLOAT;
 
-        for(GList *elem = fetcher->provider; elem; elem = elem->next, ++pos) {
-            MetaDataSource *src = elem->data;
-            if(provider_is_enabled(s, src) == TRUE) {
-                if(fired[pos] == 0) {
-                    gfloat rating = calc_rating(s->qsratio, src->quality, src->speed);
-                    if(rating > max) {
+        for (GList * elem = fetcher->provider; elem; elem = elem->next, ++pos)
+        {
+            MetaDataSource * src = elem->data;
+            if (provider_is_enabled (s,src) == TRUE)
+            {
+                if (fired[pos] == 0)
+                {
+                    gfloat rating = calc_rating (s->qsratio,src->quality,src->speed);
+                    if (rating > max)
+                    {
                         max = rating;
                         max_pos = pos;
                     }
@@ -1307,31 +1475,37 @@ static GList *get_queued(GlyrQuery *s, MetaDataFetcher *fetcher, gint *fired)
             }
         }
 
-        if(max_pos != -1) {
-            GList *wanted = g_list_nth(fetcher->provider, max_pos);
-            if(wanted != NULL) {
-                MetaDataSource *src = wanted->data;
-                source_list = g_list_prepend(source_list, src);
+        if (max_pos != -1)
+        {
+            GList * wanted = g_list_nth (fetcher->provider,max_pos);
+            if (wanted != NULL)
+            {
+                MetaDataSource * src = wanted->data;
+                source_list = g_list_prepend (source_list,src);
             }
             fired[max_pos]++;
         }
     }
 
-    if(source_list != NULL) {
-        source_list = g_list_reverse(source_list);
+    if (source_list != NULL)
+    {
+        source_list = g_list_reverse (source_list);
     }
     return source_list;
 }
 
 //////////////////////////////////////
 
-gboolean is_in_result_list(GlyrMemCache *cache, GList *result_list)
+gboolean is_in_result_list (GlyrMemCache * cache, GList * result_list)
 {
     gboolean result = FALSE;
-    if(cache != NULL) {
-        for(GList *elem = result_list; elem; elem = elem->next) {
-            GlyrMemCache *item = elem->data;
-            if(memcmp(cache->md5sum, item->md5sum, 16) == 0) {
+    if (cache != NULL)
+    {
+        for (GList * elem = result_list; elem; elem = elem->next)
+        {
+            GlyrMemCache * item = elem->data;
+            if (memcmp (cache->md5sum, item->md5sum, 16) == 0)
+            {
                 result = TRUE;
             }
         }
@@ -1341,191 +1515,222 @@ gboolean is_in_result_list(GlyrMemCache *cache, GList *result_list)
 
 //////////////////////////////////////
 
-static void execute_query(GlyrQuery *query, MetaDataFetcher *fetcher, GList *source_list, gboolean *stop_me, GList **result_list)
+static void execute_query (GlyrQuery * query, MetaDataFetcher * fetcher, GList * source_list, gboolean * stop_me, GList ** result_list)
 {
-    GList *url_list = NULL;
-    GList *endmarks = NULL;
-    GList *offline_provider = NULL;
-    GHashTable *url_table = g_hash_table_new(g_str_hash, g_str_equal);
+    GList * url_list = NULL;
+    GList * endmarks = NULL;
+    GList * offline_provider = NULL;
+    GHashTable * url_table = g_hash_table_new (g_str_hash,g_str_equal);
 
     /* Iterate over all sources for this fetcher  */
-    for(GList *source = source_list; source != NULL; source = source->next) {
-        MetaDataSource *item = source->data;
-        if(item != NULL) {
+    for (GList * source = source_list; source != NULL; source = source->next)
+    {
+        MetaDataSource * item = source->data;
+        if (item != NULL)
+        {
             /* get the url of this MetaDataSource */
-            const gchar *lookup_url = item->get_url(query);
+            const gchar * lookup_url = item->get_url (query);
 
             /* Add this to the list */
-            if(lookup_url != NULL) {
-                if(g_ascii_strncasecmp(lookup_url, OFFLINE_PROVIDER, (sizeof OFFLINE_PROVIDER) - 1) != 0) {
+            if (lookup_url != NULL)
+            {
+                if (g_ascii_strncasecmp (lookup_url,OFFLINE_PROVIDER, (sizeof OFFLINE_PROVIDER) - 1) != 0)
+                {
                     /* make a sane URL out of it */
-                    const gchar *prepared = prepare_url(lookup_url, query, TRUE);
+                    const gchar * prepared = prepare_url (lookup_url,query,TRUE);
 
                     /* add it to the hash table and relate it to the MetaDataSource */
-                    g_hash_table_insert(url_table, (gpointer) prepared, (gpointer) item);
-                    url_list = g_list_prepend(url_list, (gpointer) prepared);
-                    endmarks = g_list_prepend(endmarks, (gpointer) item->endmarker);
+                    g_hash_table_insert (url_table, (gpointer) prepared, (gpointer) item);
+                    url_list = g_list_prepend (url_list, (gpointer) prepared);
+                    endmarks = g_list_prepend (endmarks, (gpointer) item->endmarker);
 
                     /* If the URL was dyn. allocated, we should go and free it */
-                    if(item->free_url == TRUE) {
-                        g_free((gchar *) lookup_url);
+                    if (item->free_url == TRUE)
+                    {
+                        g_free ( (gchar*) lookup_url);
                     }
-                } else {
+                }
+                else
+                {
                     /* This providers offers some autogenerated content */
-                    offline_provider = g_list_prepend(offline_provider, item);
+                    offline_provider = g_list_prepend (offline_provider,item);
                 }
             }
         }
     }
 
-    GList *sub_result_list = NULL;
-    gsize url_list_length = g_list_length(url_list);
-    if(url_list_length != 0 || g_list_length(offline_provider) != 0) {
+    GList * sub_result_list = NULL;
+    gsize url_list_length = g_list_length (url_list);
+    if (url_list_length != 0 || g_list_length (offline_provider) != 0)
+    {
         gboolean proceed = TRUE;
-        GList *cached_items = NULL;
-        GList *raw_parsed = NULL;
-        GList *ready_caches = NULL;
+        GList * cached_items = NULL;
+        GList * raw_parsed = NULL;
+        GList * ready_caches = NULL;
 
         /* Handle offline provider, that don't need to download something */
-        for(GList *off_source = offline_provider; proceed && off_source && query->itemctr < query->number; off_source = off_source->next) {
-            MetaDataSource *source = off_source->data;
-            if(source != NULL && source->parser != NULL) {
+        for (GList * off_source = offline_provider; proceed && off_source && query->itemctr < query->number; off_source = off_source->next)
+        {
+            MetaDataSource * source = off_source->data;
+            if (source != NULL && source->parser != NULL)
+            {
                 cb_object pseudo_capo;
-                memset(&pseudo_capo, 0, sizeof pseudo_capo);
+                memset (&pseudo_capo, 0, sizeof pseudo_capo);
                 pseudo_capo.s = query;
 
-                GList *offline_list = source->parser(&pseudo_capo);
+                GList * offline_list = source->parser (&pseudo_capo);
 
-                if(query->imagejob) {
-                    delete_wrong_formats(&offline_list, query);
-                } else {
-                    offline_list = check_for_forced_utf8(query, offline_list);
+                if (query->imagejob)
+                {
+                    delete_wrong_formats (&offline_list,query);
+                }
+                else
+                {
+                    offline_list = check_for_forced_utf8 (query,offline_list);
                 }
 
-                for(GList *off_elem = offline_list; off_elem && query->itemctr < query->number; off_elem = off_elem->next) {
+                for (GList * off_elem = offline_list; off_elem && query->itemctr < query->number; off_elem = off_elem->next)
+                {
                     GLYR_ERROR result = GLYRE_OK;
-                    if(query->callback.download != NULL) {
-                        result = query->callback.download(off_elem->data, query);
+                    if (query->callback.download != NULL)
+                    {
+                        result = query->callback.download (off_elem->data,query);
                     }
 
-                    if(result != GLYRE_STOP_PRE && result != GLYRE_SKIP) {
-                        cached_items = g_list_prepend(cached_items, off_elem->data);
+                    if (result != GLYRE_STOP_PRE && result != GLYRE_SKIP)
+                    {
+                        cached_items = g_list_prepend (cached_items,off_elem->data);
                         query->itemctr++;
                     }
 
-                    if(result == GLYRE_STOP_PRE || result == GLYRE_STOP_POST) {
+                    if (result == GLYRE_STOP_PRE || result == GLYRE_STOP_POST)
+                    {
                         proceed = FALSE;
                         break;
                     }
                 }
-                g_list_free(offline_list);
+                g_list_free (offline_list);
             }
         }
 
         /* Now start the downloadmanager - and call the specified callback with the URL table when an item is ready */
-        if(proceed == TRUE && url_list_length != 0 && query->itemctr < query->number) {
-            raw_parsed = async_download(url_list,
-                                        endmarks,
-                                        query,
-                                        url_list_length / query->timeout  + 1,
-                                        MIN((gint)(url_list_length / query->parallel + 3), query->number + 2),
-                                        call_provider_callback,
-                                        url_table,
-                                        TRUE);
+        if (proceed == TRUE && url_list_length != 0 && query->itemctr < query->number)
+        {
+            raw_parsed = async_download (url_list,
+                                         endmarks,
+                                         query,
+                                         url_list_length / query->timeout  + 1,
+                                         MIN ( (gint) (url_list_length / query->parallel + 3), query->number + 2),
+                                         call_provider_callback,
+                                         url_table,
+                                         TRUE);
         }
 
         /* Now finalize our retrieved items */
-        if(g_list_length(raw_parsed) != 0) {
+        if (g_list_length (raw_parsed) != 0)
+        {
 
             /* Kill duplicates before finalizing */
-            int pre_less = delete_dupes(raw_parsed, query);
-            if(pre_less > 0) {
-                glyr_message(2, query, "- Prefiltering double data: (-%d item(s) less)\n", pre_less);
+            int pre_less = delete_dupes (raw_parsed,query);
+            if (pre_less > 0)
+            {
+                glyr_message (2,query,"- Prefiltering double data: (-%d item(s) less)\n",pre_less);
                 query->itemctr -= pre_less;
             }
 
-            glyr_message(2, query, "---- \n");
-            if(g_list_length(raw_parsed) != 0) {
+            glyr_message (2,query,"---- \n");
+            if (g_list_length (raw_parsed) != 0)
+            {
                 /* Call finalize to sanitize data, or download given URLs */
-                ready_caches = fetcher->finalize(query, raw_parsed, stop_me, result_list);
+                ready_caches = fetcher->finalize (query, raw_parsed,stop_me, result_list);
 
                 /* Raw data not needed anymore */
-                g_list_free(raw_parsed);
+                g_list_free (raw_parsed);
                 raw_parsed = NULL;
             }
         }
 
-        if(cached_items && ready_caches) {
-            sub_result_list = g_list_concat(cached_items, ready_caches);
-        } else {
+        if (cached_items && ready_caches)
+        {
+            sub_result_list = g_list_concat (cached_items, ready_caches);
+        }
+        else
+        {
             sub_result_list = (cached_items) ? cached_items : ready_caches;
         }
     }
 
     /* Free ressources */
-    glist_free_full(url_list, g_free);
-    g_list_free(endmarks);
-    g_list_free(offline_provider);
-    g_hash_table_destroy(url_table);
-
-
-    for(GList *result = sub_result_list; result; result = result->next) {
-        GlyrMemCache *result_cache = result->data;
-        if(result_cache != NULL) {
-            *result_list = g_list_prepend(*result_list, result->data);
+    glist_free_full (url_list,g_free);
+    g_list_free (endmarks);
+    g_list_free (offline_provider);
+    g_hash_table_destroy (url_table);
+
+
+    for (GList * result = sub_result_list; result; result = result->next)
+    {
+        GlyrMemCache * result_cache = result->data;
+        if (result_cache != NULL)
+        {
+            *result_list = g_list_prepend (*result_list,result->data);
         }
     }
-    g_list_free(sub_result_list);
+    g_list_free (sub_result_list);
 }
 //////////////////////////////////////
 
-static void print_trigger(GlyrQuery *query, GList *src_list)
+static void print_trigger (GlyrQuery * query, GList * src_list)
 {
-    glyr_message(2, query, "---- Triggering: ");
-    for(GList *elem = src_list; elem; elem = elem->next) {
-        MetaDataSource *info = elem->data;
-        glyr_message(2, query, "%s ", info->name);
+    glyr_message (2,query,"---- Triggering: ");
+    for (GList * elem = src_list; elem; elem = elem->next)
+    {
+        MetaDataSource * info = elem->data;
+        glyr_message (2,query,"%s ",info->name);
     }
-    glyr_message(2, query, "\n");
+    glyr_message (2,query,"\n");
 }
 
 //////////////////////////////////////
 
-GList *start_engine(GlyrQuery *query, MetaDataFetcher *fetcher, GLYR_ERROR *err)
+GList * start_engine (GlyrQuery * query, MetaDataFetcher * fetcher, GLYR_ERROR * err)
 {
-    gsize list_len = g_list_length(fetcher->provider);
+    gsize list_len = g_list_length (fetcher->provider);
     gint fired[list_len];
-    memset(fired, 0, list_len * sizeof(gint));
+    memset (fired,0,list_len * sizeof (gint) );
 
     gboolean something_was_searched = FALSE;
     gboolean stop_now = FALSE;
 
-    GList *src_list = NULL, * result_list = NULL;
-    while((stop_now == FALSE) &&
-            (g_list_length(result_list) < (gsize) query->number) &&
-            (src_list = get_queued(query, fetcher, fired)) != NULL) {
+    GList * src_list = NULL, * result_list = NULL;
+    while ( (stop_now == FALSE) &&
+            (g_list_length (result_list) < (gsize) query->number) &&
+            (src_list = get_queued (query, fetcher, fired) ) != NULL)
+    {
         /* Print what provider were triggered */
-        print_trigger(query, src_list);
+        print_trigger (query,src_list);
 
         /* Send this list of sources to the download manager */
-        execute_query(query, fetcher, src_list, &stop_now, &result_list);
+        execute_query (query,fetcher,src_list, &stop_now, &result_list);
 
         /* Do not report errors */
         something_was_searched = TRUE;
 
         /* Next list please */
-        g_list_free(src_list);
+        g_list_free (src_list);
 
         /* Check is exit was signaled */
-        stop_now = (GET_ATOMIC_SIGNAL_EXIT(query)) ? TRUE : stop_now;
+        stop_now = (GET_ATOMIC_SIGNAL_EXIT (query) ) ? TRUE : stop_now;
     }
 
-    if(something_was_searched == FALSE) {
-        if(err != NULL) {
+    if (something_was_searched == FALSE)
+    {
+        if (err != NULL)
+        {
             *err = GLYRE_NO_PROVIDER;
         }
 
-        if(query != NULL) {
+        if (query != NULL)
+        {
             query->q_errno = GLYRE_NO_PROVIDER;
         }
     }
@@ -1536,36 +1741,39 @@ GList *start_engine(GlyrQuery *query, MetaDataFetcher *fetcher, GLYR_ERROR *err)
 //////////////////////////////////////
 
 /* New glib implementation, thanks to Etienne Millon */
-void update_md5sum(GlyrMemCache *c)
+void update_md5sum (GlyrMemCache * c)
 {
-    if(c && c->data && c->size > 0) {
+    if (c && c->data && c->size > 0)
+    {
         gsize bufsize = 16;
-        GChecksum *checksum = g_checksum_new(G_CHECKSUM_MD5);
+        GChecksum *checksum = g_checksum_new (G_CHECKSUM_MD5);
 
-        g_checksum_update(checksum, (const guchar *) c->data, c->size);
-        g_checksum_get_digest(checksum, c->md5sum, &bufsize);
-        g_checksum_free(checksum);
+        g_checksum_update (checksum, (const guchar*) c->data, c->size);
+        g_checksum_get_digest (checksum, c->md5sum, &bufsize);
+        g_checksum_free (checksum);
     }
 }
 
 //////////////////////////////////////
 
-void glist_free_full(GList *List, void (* free_func)(void *ptr))
+void glist_free_full (GList * List, void (* free_func) (void * ptr) )
 {
-#if GLIB_CHECK_VERSION(2, 8, )
+#if GLIB_CHECK_VERSION(2,28,0)
 
     /* Use official version */
-    g_list_free_full(List, free_func);
+    g_list_free_full (List,free_func);
 #else
 
     /* Fallback to simple own implementation  */
-    for(GList *elem = List; elem; elem = elem->next) {
-        if(free_func != NULL) {
-            free_func(elem->data);
+    for (GList * elem = List; elem; elem = elem->next)
+    {
+        if (free_func != NULL)
+        {
+            free_func (elem->data);
         }
 
     }
-    g_list_free(List);
+    g_list_free (List);
 #endif
 }
 
diff --git a/lib/glyr.c b/lib/glyr.c
index c341451..aad2ce5 100644
--- a/lib/glyr.c
+++ b/lib/glyr.c
@@ -34,10 +34,11 @@ static volatile gboolean is_initalized = FALSE;
 
 //////////////////////////////////
 
-static const char *err_strings[] = {
+static const char * err_strings[] =
+{
     [GLYRE_UNKNOWN] = "Unknown error",
     [GLYRE_OK] = "No error",
-    [GLYRE_BAD_VALUE] = "Bad value for glyr_opt_[...]()",
+    [GLYRE_BAD_VALUE] ="Bad value for glyr_opt_[...]()",
     [GLYRE_BAD_OPTION] = "Bad option passed to gly_opt_[...]()",
     [GLYRE_NO_PROVIDER] = "No valid provider specified in glyr_opt_from()",
     [GLYRE_EMPTY_STRUCT] = "Empty Query structure (NULL)",
@@ -50,7 +51,8 @@ static const char *err_strings[] = {
     [GLYRE_WAS_STOPPED] = "Library was stopped by glyr_signal_exit()"
 };
 
-static const char *type_strings[] = {
+static const char * type_strings[] =
+{
     [GLYR_TYPE_COVERART] = "cover",
     [GLYR_TYPE_LYRICS] = "songtext",
     [GLYR_TYPE_ARTIST_PHOTO] = "artistphoto",
@@ -74,29 +76,28 @@ static const char *type_strings[] = {
 
 /////////////////////////////////
 
-const gchar *map_language[][2] = {
-    {"en_US", "us"},
-    {"en_CA", "ca"},
-    {"en_UK", "uk"}
+const gchar * map_language[][2] =
+{
+    {"en_US","us"},
+    {"en_CA","ca"},
+    {"en_UK","uk"}
 };
 
 
 /////////////////////////////////
 
-void glyr_internal_log(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer user_data)
+void glyr_internal_log (const gchar *log_domain,GLogLevelFlags log_level,const gchar *message, gpointer user_data)
 {
-    if(message != NULL) {
-        fputs(message, GLYR_OUTPUT);
-    }
+    if (message != NULL) fputs (message,GLYR_OUTPUT);
 }
 
 
 /////////////////////////////////
 
 /* Local scopes are cool. */
-#define END_STRING(STR, HAR)           \
+#define END_STRING(STR,CHAR)           \
     {                                      \
-        gchar * term = strchr(STR, HAR);   \
+        gchar * term = strchr(STR,CHAR);   \
         if(term) *term = 0;                \
     }
 
@@ -105,59 +106,67 @@ void glyr_internal_log(const gchar *log_domain, GLogLevelFlags log_level, const
  *
  * @return a newly allocated language code. Free.
  */
-gchar *guess_language(void)
+gchar * guess_language (void)
 {
     /* Default to 'en' in any case */
-    gchar *result_lang = g_strdup("en");
+    gchar * result_lang = g_strdup ("en");
 
-#if GLIB_CHECK_VERSION(2, 8, )
+#if GLIB_CHECK_VERSION(2,28,0)
     gboolean break_out = FALSE;
 
     /* Please never ever free this */
-    const gchar *const *languages = g_get_language_names();
+    const gchar * const * languages = g_get_language_names();
 
-    for(gint i = 0; languages[i] && break_out == FALSE; i++) {
-        gchar **variants = g_get_locale_variants(languages[i]);
-        for(gint j = 0; variants[j] && !break_out; j++) {
+    for (gint i = 0; languages[i] && break_out == FALSE; i++)
+    {
+        gchar ** variants = g_get_locale_variants (languages[i]);
+        for (gint j = 0; variants[j] && !break_out; j++)
+        {
             /* Look up if we need to map a language */
-            gchar *to_investigate = variants[j];
-            gint map_size = (sizeof(map_language) / (2 * sizeof(char *)));
-            for(gint map = 0; map < map_size; map++) {
-                const gchar *to_map = map_language[map][0];
-                gsize map_len  = strlen(to_map);
-                if(g_ascii_strncasecmp(to_map, to_investigate, map_len) == 0) {
-                    to_investigate = (gchar *) map_language[map][1];
+            gchar * to_investigate = variants[j];
+            gint map_size = (sizeof (map_language) / (2 * sizeof (char*) ) );
+            for (gint map = 0; map < map_size; map++)
+            {
+                const gchar * to_map = map_language[map][0];
+                gsize map_len  = strlen (to_map);
+                if (g_ascii_strncasecmp (to_map,to_investigate,map_len) == 0)
+                {
+                    to_investigate = (gchar*) map_language[map][1];
                     break;
                 }
             }
 
             gboolean allowed_lang = TRUE;
 
-            if(allowed_lang &&
-                    g_ascii_strncasecmp("en", to_investigate, 2) != 0 &&
-                    g_ascii_strncasecmp("C", to_investigate, 1) != 0 &&
-                    !strchr(to_investigate, '@') && !strchr(to_investigate, '.')) {
-                g_free(result_lang);
-                result_lang = g_strdup(to_investigate);
+            if (allowed_lang &&
+                    g_ascii_strncasecmp ("en",to_investigate,2) != 0 &&
+                    g_ascii_strncasecmp ("C", to_investigate,1) != 0 &&
+                    !strchr (to_investigate,'@') && !strchr (to_investigate,'.') )
+            {
+                g_free (result_lang);
+                result_lang = g_strdup (to_investigate);
                 break_out = TRUE;
             }
         }
-        g_strfreev(variants);
+        g_strfreev (variants);
     }
 
-#elif GLIB_CHECK_VERSION(2, 6, )
+#elif GLIB_CHECK_VERSION(2,26,0)
 
     /* Fallback to simpler version of the above,
      * g_get_locale_variants is not there in this version
      */
-    const gchar *const *possible_locales = g_get_language_names();
-    if(possible_locales != NULL) {
+    const gchar * const * possible_locales = g_get_language_names();
+    if (possible_locales != NULL)
+    {
         /* might be a bit weird */
-        for(gint i = 0; possible_locales[i]; i++) {
-            if(g_ascii_strncasecmp("en", possible_locales[i], 2) != 0 &&
-                    g_ascii_strncasecmp("C", possible_locales[i], 1) != 0) {
-                g_free(result_lang);
-                result_lang = g_strdup(possible_locales[i]);
+        for (gint i = 0; possible_locales[i]; i++)
+        {
+            if (g_ascii_strncasecmp ("en",possible_locales[i],2) != 0 &&
+                    g_ascii_strncasecmp ("C", possible_locales[i],1) != 0)
+            {
+                g_free (result_lang);
+                result_lang = g_strdup (possible_locales[i]);
                 break;
             }
         }
@@ -170,9 +179,9 @@ gchar *guess_language(void)
 #endif
 
     /* Properly terminate string */
-    END_STRING(result_lang, '_');
-    END_STRING(result_lang, '@');
-    END_STRING(result_lang, '.');
+    END_STRING (result_lang,'_');
+    END_STRING (result_lang,'@');
+    END_STRING (result_lang,'.');
 
     /* We don't need it anymore */
 #undef END_STRING
@@ -182,18 +191,19 @@ gchar *guess_language(void)
 
 /////////////////////////////////
 
-static int glyr_set_info(GlyrQuery *s, int at, const char *arg);
-static void set_query_on_defaults(GlyrQuery *glyrs);
+static int glyr_set_info (GlyrQuery * s, int at, const char * arg);
+static void set_query_on_defaults (GlyrQuery * glyrs);
 
 /////////////////////////////////
 // OTHER
 /////////////////////////////////
 
 // return a descriptive string on error ID
-__attribute__((visibility("default")))
-const char *glyr_strerror(GLYR_ERROR ID)
+__attribute__ ( (visibility ("default") ) )
+const char * glyr_strerror (GLYR_ERROR ID)
 {
-    if(ID < (sizeof(err_strings) / sizeof(const char *))) {
+    if (ID < (sizeof (err_strings) /sizeof (const char *) ) )
+    {
         return err_strings[ID];
     }
     return err_strings[GLYRE_UNKNOWN];
@@ -201,40 +211,40 @@ const char *glyr_strerror(GLYR_ERROR ID)
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_signal_exit(GlyrQuery *query)
+__attribute__ ( (visibility ("default") ) )
+void glyr_signal_exit (GlyrQuery * query)
 {
-    SET_ATOMIC_SIGNAL_EXIT(query, 1);
+    SET_ATOMIC_SIGNAL_EXIT (query,1);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_cache_update_md5sum(GlyrMemCache *cache)
+__attribute__ ( (visibility ("default") ) )
+void glyr_cache_update_md5sum (GlyrMemCache * cache)
 {
-    update_md5sum(cache);
+    update_md5sum (cache);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_cache_set_data(GlyrMemCache *cache, const char *data, int len)
+__attribute__ ( (visibility ("default") ) )
+void glyr_cache_set_data (GlyrMemCache * cache, const char * data, int len)
 {
-    DL_set_data(cache, data, len);
+    DL_set_data (cache,data,len);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GlyrMemCache *glyr_cache_copy(GlyrMemCache *cache)
+__attribute__ ( (visibility ("default") ) )
+GlyrMemCache * glyr_cache_copy (GlyrMemCache * cache)
 {
-    return DL_copy(cache);
+    return DL_copy (cache);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-const char *glyr_version(void)
+__attribute__ ( (visibility ("default") ) )
+const char * glyr_version (void)
 {
     return "Version "GLYR_VERSION_MAJOR"."GLYR_VERSION_MINOR"."GLYR_VERSION_MICRO" ("GLYR_VERSION_NAME") of ["__DATE__"] compiled at ["__TIME__"]";
 }
@@ -244,556 +254,525 @@ const char *glyr_version(void)
 /////////////////////////////////
 
 // Seperate method because va_arg struggles with function pointers
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_dlcallback(GlyrQuery *settings, DL_callback dl_cb, void *userp)
-{
-if(settings) {
-settings->callback.download     = dl_cb;
-settings->callback.user_pointer = userp;
-return GLYRE_OK;
-}
-return GLYRE_EMPTY_STRUCT;
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_dlcallback (GlyrQuery * settings, DL_callback dl_cb, void * userp)
+{
+    if (settings)
+    {
+        settings->callback.download     = dl_cb;
+        settings->callback.user_pointer = userp;
+        return GLYRE_OK;
+    }
+    return GLYRE_EMPTY_STRUCT;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_type(GlyrQuery *s, GLYR_GET_TYPE type)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_type (GlyrQuery * s, GLYR_GET_TYPE type)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-if(type != GLYR_GET_UNKNOWN) {
-s->type = type;
-return GLYRE_OK;
-}
-return GLYRE_BAD_VALUE;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    if (type != GLYR_GET_UNKNOWN)
+    {
+        s->type = type;
+        return GLYRE_OK;
+    }
+    return GLYRE_BAD_VALUE;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_artist(GlyrQuery *s, const char *artist)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_artist (GlyrQuery * s, const char * artist)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-glyr_set_info(s, 0, artist);
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    glyr_set_info (s,0,artist);
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_album(GlyrQuery *s, const char *album)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_album (GlyrQuery * s, const char * album)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-glyr_set_info(s, 1, album);
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    glyr_set_info (s,1,album);
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_title(GlyrQuery *s, const char *title)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_title (GlyrQuery * s, const char * title)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-glyr_set_info(s, 2, title);
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    glyr_set_info (s,2,title);
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-static int size_set(int *ref, int size)
+static int size_set (int * ref, int size)
 {
-if(size < -1 && ref) {
-*ref = -1;
-return GLYRE_BAD_VALUE;
-}
+    if (size < -1 && ref)
+    {
+        *ref = -1;
+        return GLYRE_BAD_VALUE;
+    }
 
-if(ref) {
-*ref = size;
-return GLYRE_OK;
-}
-return GLYRE_BAD_OPTION;
+    if (ref)
+    {
+        *ref = size;
+        return GLYRE_OK;
+    }
+    return GLYRE_BAD_OPTION;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_img_maxsize(GlyrQuery *s, int size)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_img_maxsize (GlyrQuery * s, int size)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-return size_set(&s->img_max_size, size);
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    return size_set (&s->img_max_size,size);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_img_minsize(GlyrQuery *s, int size)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_img_minsize (GlyrQuery * s, int size)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-return size_set(&s->img_min_size, size);
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    return size_set (&s->img_min_size,size);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_parallel(GlyrQuery *s, unsigned long val)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_parallel (GlyrQuery * s, unsigned long val)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->parallel = (long) val;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->parallel = (long) val;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_timeout(GlyrQuery *s, unsigned long val)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_timeout (GlyrQuery * s, unsigned long val)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->timeout = (long) val;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->timeout = (long) val;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_redirects(GlyrQuery *s, unsigned long val)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_redirects (GlyrQuery * s, unsigned long val)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->redirects = (long) val;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->redirects = (long) val;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_useragent(GlyrQuery *s, const char *useragent)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_useragent (GlyrQuery * s, const char * useragent)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-glyr_set_info(s, 6, (useragent) ? useragent : "");
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    glyr_set_info (s,6, (useragent) ? useragent : "");
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_lang(GlyrQuery *s, const char *langcode)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_lang (GlyrQuery * s, const char * langcode)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-if(langcode != NULL) {
-if(g_ascii_strncasecmp("auto", langcode, 4) == 0) {
-gchar *auto_lang = guess_language();
-glyr_set_info(s, 7, auto_lang);
-g_free(auto_lang);
-} else {
-glyr_set_info(s, 7, langcode);
-}
-return GLYRE_OK;
-}
-return GLYRE_BAD_VALUE;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    if (langcode != NULL)
+    {
+        if (g_ascii_strncasecmp ("auto",langcode,4) == 0)
+        {
+            gchar * auto_lang = guess_language();
+            glyr_set_info (s,7,auto_lang);
+            g_free (auto_lang);
+        }
+        else
+        {
+            glyr_set_info (s,7,langcode);
+        }
+        return GLYRE_OK;
+    }
+    return GLYRE_BAD_VALUE;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_lang_aware_only(GlyrQuery *s, bool lang_aware_only)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_lang_aware_only (GlyrQuery * s, bool lang_aware_only)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->lang_aware_only = lang_aware_only;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->lang_aware_only = lang_aware_only;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_number(GlyrQuery *s, unsigned int num)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_number (GlyrQuery * s, unsigned int num)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->number = num == 0 ? INT_MAX : num;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->number = num == 0 ? INT_MAX : num;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_verbosity(GlyrQuery *s, unsigned int level)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_verbosity (GlyrQuery * s, unsigned int level)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->verbosity = level;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->verbosity = level;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_from(GlyrQuery *s, const char *from)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_from (GlyrQuery * s, const char * from)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-if(from != NULL) {
-glyr_set_info(s, 4, from);
-return GLYRE_OK;
-}
-return GLYRE_BAD_VALUE;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    if (from != NULL)
+    {
+        glyr_set_info (s,4,from);
+        return GLYRE_OK;
+    }
+    return GLYRE_BAD_VALUE;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_allowed_formats(GlyrQuery *s, const char *formats)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_allowed_formats (GlyrQuery * s, const char * formats)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-glyr_set_info(s, 5, (formats == NULL) ? GLYR_DEFAULT_ALLOWED_FORMATS : formats);
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    glyr_set_info (s,5, (formats==NULL) ? GLYR_DEFAULT_ALLOWED_FORMATS : formats);
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_musictree_path(GlyrQuery *s, const char *musictree_path)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_musictree_path (GlyrQuery * s, const char * musictree_path)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-glyr_set_info(s, 8, (musictree_path == NULL) ? GLYR_DEFAULT_MUISCTREE_PATH : musictree_path);
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    glyr_set_info (s,8, (musictree_path==NULL) ? GLYR_DEFAULT_MUISCTREE_PATH : musictree_path);
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_plugmax(GlyrQuery *s, int plugmax)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_plugmax (GlyrQuery * s, int plugmax)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-if(plugmax < 0) {
-return GLYRE_BAD_VALUE;
-}
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    if (plugmax < 0)
+    {
+        return GLYRE_BAD_VALUE;
+    }
 
-s->plugmax = plugmax;
-return GLYRE_OK;
+    s->plugmax = plugmax;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_qsratio(GlyrQuery *s, float ratio)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_qsratio (GlyrQuery * s, float ratio)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->qsratio = MIN(MAX(ratio, 0.0), 1.0);
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->qsratio = MIN (MAX (ratio,0.0),1.0);
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_proxy(GlyrQuery *s, const char *proxystring)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_proxy (GlyrQuery * s, const char * proxystring)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-glyr_set_info(s, 3, proxystring);
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    glyr_set_info (s,3,proxystring);
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_fuzzyness(GlyrQuery *s, int fuzz)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_fuzzyness (GlyrQuery * s, int fuzz)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->fuzzyness = fuzz;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->fuzzyness = fuzz;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_download(GlyrQuery *s, bool download)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_download (GlyrQuery * s, bool download)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->download = download;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->download = download;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_force_utf8(GlyrQuery *s, bool force_utf8)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_force_utf8 (GlyrQuery * s, bool force_utf8)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->force_utf8 = force_utf8;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->force_utf8 = force_utf8;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_lookup_db(GlyrQuery *s, GlyrDatabase *db)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_lookup_db (GlyrQuery * s, GlyrDatabase * db)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-if(db != NULL) {
-s->local_db = db;
-return GLYRE_OK;
-}
-return GLYRE_BAD_VALUE;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    if (db != NULL)
+    {
+        s->local_db = db;
+        return GLYRE_OK;
+    }
+    return GLYRE_BAD_VALUE;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_db_autowrite(GlyrQuery *s, bool db_autowrite)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_db_autowrite (GlyrQuery * s, bool db_autowrite)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->db_autowrite = db_autowrite;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->db_autowrite = db_autowrite;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_db_autoread(GlyrQuery *s, bool db_autoread)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_db_autoread (GlyrQuery * s, bool db_autoread)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->db_autoread = db_autoread;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->db_autoread = db_autoread;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_ERROR glyr_opt_normalize(GlyrQuery *s, GLYR_NORMALIZATION norm)
+__attribute__ ( (visibility ("default") ) )
+GLYR_ERROR glyr_opt_normalize (GlyrQuery * s, GLYR_NORMALIZATION norm)
 {
-if(s == NULL) {
-return GLYRE_EMPTY_STRUCT;
-}
-s->normalization = norm;
-return GLYRE_OK;
+    if (s == NULL) return GLYRE_EMPTY_STRUCT;
+    s->normalization = norm;
+    return GLYRE_OK;
 }
 
 /////////////////////////////////
 /////////////////////////////////
 /////////////////////////////////
 
-static void set_query_on_defaults(GlyrQuery *glyrs)
+static void set_query_on_defaults (GlyrQuery * glyrs)
 {
-if(glyrs == NULL) {
-return;
-}
-
-/* Initialize free pointer pool */
-memset(glyrs, 0, sizeof(GlyrQuery));
-
-glyrs->type = GLYR_GET_UNKNOWN;
-glyrs->artist = NULL;
-glyrs->album  = NULL;
-glyrs->title  = NULL;
-glyrs->local_db = NULL;
-glyrs->callback.download = NULL;
-glyrs->callback.user_pointer = NULL;
-glyrs->musictree_path = NULL;
-glyrs->q_errno = GLYRE_OK;
-
-glyrs->db_autoread = GLYR_DEFAULT_DB_AUTOREAD;
-glyrs->db_autowrite = GLYR_DEFAULT_DB_AUTOWRITE;
-glyrs->from   = GLYR_DEFAULT_FROM;
-glyrs->img_min_size = GLYR_DEFAULT_CMINSIZE;
-glyrs->img_max_size = GLYR_DEFAULT_CMAXSIZE;
-glyrs->number = GLYR_DEFAULT_NUMBER;
-glyrs->parallel  = GLYR_DEFAULT_PARALLEL;
-glyrs->redirects = GLYR_DEFAULT_REDIRECTS;
-glyrs->timeout   = GLYR_DEFAULT_TIMEOUT;
-glyrs->verbosity = GLYR_DEFAULT_VERBOSITY;
-glyrs->plugmax = GLYR_DEFAULT_PLUGMAX;
-glyrs->download = GLYR_DEFAULT_DOWNLOAD;
-glyrs->fuzzyness = GLYR_DEFAULT_FUZZYNESS;
-glyrs->proxy = GLYR_DEFAULT_PROXY;
-glyrs->qsratio = GLYR_DEFAULT_QSRATIO;
-glyrs->allowed_formats = GLYR_DEFAULT_ALLOWED_FORMATS;
-glyrs->useragent = GLYR_DEFAULT_USERAGENT;
-glyrs->force_utf8 = GLYR_DEFAULT_FORCE_UTF8;
-glyrs->lang = GLYR_DEFAULT_LANG;
-glyrs->lang_aware_only = GLYR_DEFAULT_LANG_AWARE_ONLY;
-glyrs->normalization = GLYR_NORMALIZE_AGGRESSIVE | GLYR_NORMALIZE_ALL;
-glyrs->signal_exit = FALSE;
-glyrs->itemctr = 0;
-
-/* Set on a very specific value, so we can pretty sure,
-   we are not accessing bad memory - feels little hackish.. */
-glyrs->is_initalized = QUERY_INITIALIZER;
-}
-
-/////////////////////////////////
+    if (glyrs == NULL)
+    {
+        return;
+    }
 
-__attribute__((visibility("default")))
-void glyr_query_init(GlyrQuery *glyrs)
-{
-if(glyrs != NULL) {
-set_query_on_defaults(glyrs);
-}
+    /* Initialize free pointer pool */
+    memset (glyrs,0,sizeof (GlyrQuery) );
+
+    glyrs->type = GLYR_GET_UNKNOWN;
+    glyrs->artist = NULL;
+    glyrs->album  = NULL;
+    glyrs->title  = NULL;
+    glyrs->local_db = NULL;
+    glyrs->callback.download = NULL;
+    glyrs->callback.user_pointer = NULL;
+    glyrs->musictree_path = NULL;
+    glyrs->q_errno = GLYRE_OK;
+
+    glyrs->db_autoread = GLYR_DEFAULT_DB_AUTOREAD;
+    glyrs->db_autowrite = GLYR_DEFAULT_DB_AUTOWRITE;
+    glyrs->from   = GLYR_DEFAULT_FROM;
+    glyrs->img_min_size = GLYR_DEFAULT_CMINSIZE;
+    glyrs->img_max_size = GLYR_DEFAULT_CMAXSIZE;
+    glyrs->number = GLYR_DEFAULT_NUMBER;
+    glyrs->parallel  = GLYR_DEFAULT_PARALLEL;
+    glyrs->redirects = GLYR_DEFAULT_REDIRECTS;
+    glyrs->timeout   = GLYR_DEFAULT_TIMEOUT;
+    glyrs->verbosity = GLYR_DEFAULT_VERBOSITY;
+    glyrs->plugmax = GLYR_DEFAULT_PLUGMAX;
+    glyrs->download = GLYR_DEFAULT_DOWNLOAD;
+    glyrs->fuzzyness = GLYR_DEFAULT_FUZZYNESS;
+    glyrs->proxy = GLYR_DEFAULT_PROXY;
+    glyrs->qsratio = GLYR_DEFAULT_QSRATIO;
+    glyrs->allowed_formats = GLYR_DEFAULT_ALLOWED_FORMATS;
+    glyrs->useragent = GLYR_DEFAULT_USERAGENT;
+    glyrs->force_utf8 = GLYR_DEFAULT_FORCE_UTF8;
+    glyrs->lang = GLYR_DEFAULT_LANG;
+    glyrs->lang_aware_only = GLYR_DEFAULT_LANG_AWARE_ONLY;
+    glyrs->normalization = GLYR_NORMALIZE_AGGRESSIVE | GLYR_NORMALIZE_ALL;
+    glyrs->signal_exit = FALSE;
+    glyrs->itemctr = 0;
+
+    /* Set on a very specific value, so we can pretty sure,
+       we are not accessing bad memory - feels little hackish.. */
+    glyrs->is_initalized = QUERY_INITIALIZER;
+}
+
+/////////////////////////////////
+
+__attribute__ ( (visibility ("default") ) )
+void glyr_query_init (GlyrQuery * glyrs)
+{
+    if (glyrs != NULL)
+    {
+        set_query_on_defaults (glyrs);
+    }
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_query_destroy(GlyrQuery *sets)
+__attribute__ ( (visibility ("default") ) )
+void glyr_query_destroy (GlyrQuery * sets)
 {
-if(sets != NULL && QUERY_IS_INITALIZED(sets)) {
-for(gsize i = 0; i < 10; i++) {
-if(sets->info[i] != NULL) {
-g_free((char *) sets->info[i]);
-sets->info[i] = NULL;
-}
-}
+    if (sets != NULL && QUERY_IS_INITALIZED (sets) )
+    {
+        for (gsize i = 0; i < 10; i++)
+        {
+            if (sets->info[i] != NULL)
+            {
+                g_free ( (char*) sets->info[i]);
+                sets->info[i] = NULL;
+            }
+        }
 
-/* Reset query so it can be used again */
-set_query_on_defaults(sets);
-}
+        /* Reset query so it can be used again */
+        set_query_on_defaults (sets);
+    }
 
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GlyrMemCache *glyr_download(const char *url, GlyrQuery *s)
+__attribute__ ( (visibility ("default") ) )
+GlyrMemCache * glyr_download (const char * url, GlyrQuery * s)
 {
-return download_single(url, s, NULL);
+    return download_single (url,s,NULL);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_free_list(GlyrMemCache *head)
+__attribute__ ( (visibility ("default") ) )
+void glyr_free_list (GlyrMemCache * head)
 {
-if(head != NULL) {
-GlyrMemCache *next = head;
-GlyrMemCache *prev = head->prev;
+    if (head != NULL)
+    {
+        GlyrMemCache * next = head;
+        GlyrMemCache * prev = head->prev;
 
-while(next != NULL) {
-GlyrMemCache *p = next;
-next = next->next;
-DL_free(p);
-}
+        while (next != NULL)
+        {
+            GlyrMemCache * p = next;
+            next = next->next;
+            DL_free (p);
+        }
 
-while(prev != NULL) {
-GlyrMemCache *p = prev;
-prev = prev->prev;
-DL_free(p);
-}
-}
+        while (prev != NULL)
+        {
+            GlyrMemCache * p = prev;
+            prev = prev->prev;
+            DL_free (p);
+        }
+    }
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_cache_free(GlyrMemCache *c)
+__attribute__ ( (visibility ("default") ) )
+void glyr_cache_free (GlyrMemCache * c)
 {
-DL_free(c);
+    DL_free (c);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GlyrMemCache *glyr_cache_new(void)
+__attribute__ ( (visibility ("default") ) )
+GlyrMemCache * glyr_cache_new (void)
 {
-return DL_init();
+    return DL_init();
 }
 
 /////////////////////////////////
 
 // !! NOT THREADSAFE !! //
-__attribute__((visibility("default")))
-void glyr_init(void)
-{
-/* Protect agains double initialization */
-if(is_initalized == FALSE) {
-/* Set loghandler */
-g_log_set_handler(G_LOG_DOMAIN, G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL
-| G_LOG_FLAG_RECURSION,
-glyr_internal_log, NULL);
-
-if(curl_global_init(CURL_GLOBAL_ALL)) {
-glyr_message(-1, NULL, "Fatal: libcurl failed to init\n");
-}
+__attribute__ ( (visibility ("default") ) )
+void glyr_init (void)
+{
+    /* Protect agains double initialization */
+    if (is_initalized == FALSE)
+    {
+        /* Set loghandler */
+        g_log_set_handler (G_LOG_DOMAIN, G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL
+                           | G_LOG_FLAG_RECURSION,
+                           glyr_internal_log, NULL);
+
+        if (curl_global_init (CURL_GLOBAL_ALL) )
+        {
+            glyr_message (-1,NULL,"Fatal: libcurl failed to init\n");
+        }
 
-/* Locale */
-if(setlocale(LC_ALL, "") == NULL) {
-glyr_message(-1, NULL, "Cannot set locale!\n");
-}
+        /* Locale */
+        if (setlocale (LC_ALL, "") == NULL)
+        {
+            glyr_message (-1,NULL,"Cannot set locale!\n");
+        }
 
-/* Register plugins */
-register_fetcher_plugins();
+        /* Register plugins */
+        register_fetcher_plugins();
 
-/* Init the smallest blacklist in the world :-) */
-blacklist_build();
+        /* Init the smallest blacklist in the world :-) */
+        blacklist_build();
 
-is_initalized = TRUE;
-}
+        is_initalized = TRUE;
+    }
 }
 
 
 /////////////////////////////////
 
 // !! NOT THREADSAFE !! //
-__attribute__((visibility("default")))
-void glyr_cleanup(void)
+__attribute__ ( (visibility ("default") ) )
+void glyr_cleanup (void)
 {
-if(is_initalized == TRUE) {
-/* Curl no longer needed */
-curl_global_cleanup();
+    if (is_initalized == TRUE)
+    {
+        /* Curl no longer needed */
+        curl_global_cleanup();
 
-/* Destroy all fetchers */
-unregister_fetcher_plugins();
+        /* Destroy all fetchers */
+        unregister_fetcher_plugins();
 
-/* Kill it again */
-blacklist_destroy();
+        /* Kill it again */
+        blacklist_destroy();
 
-is_initalized = FALSE;
-}
+        is_initalized = FALSE;
+    }
 }
 
 
@@ -801,67 +780,68 @@ is_initalized = FALSE;
 /////////////////////////////////
 
 /* Sets parallel field depending on the get_type */
-static void auto_detect_parallel(MetaDataFetcher *fetcher, GlyrQuery *query)
-{
-if(query->parallel <= 0) {
-if(fetcher->default_parallel <= 0) {
-gint div = (int)(1.0 / (CLAMP(query->qsratio, 0.01, 0.99) * 2));
-query->parallel = (div == 0) ? 3 : g_list_length(fetcher->provider) / div;
-} else {
-query->parallel = fetcher->default_parallel;
-}
-}
+static void auto_detect_parallel (MetaDataFetcher * fetcher, GlyrQuery * query)
+{
+    if (query->parallel <= 0)
+    {
+        if (fetcher->default_parallel <= 0)
+        {
+            gint div = (int) (1.0/ (CLAMP (query->qsratio,0.01,0.99) * 2) );
+            query->parallel = (div == 0) ? 3 : g_list_length (fetcher->provider) / div;
+        }
+        else
+        {
+            query->parallel = fetcher->default_parallel;
+        }
+    }
 }
 
 /////////////////////////////////
 
-static gboolean check_if_valid(GlyrQuery *q, MetaDataFetcher *fetch)
+static gboolean check_if_valid (GlyrQuery * q, MetaDataFetcher * fetch)
 {
-gboolean isValid = TRUE;
-if(fetch->reqs & GLYR_REQUIRES_ARTIST && q->artist == NULL) {
-glyr_message(2, q, "Artist is required for this getter\n");
-isValid = FALSE;
-}
+    gboolean isValid = TRUE;
+    if (fetch->reqs & GLYR_REQUIRES_ARTIST && q->artist == NULL)
+    {
+        glyr_message (2,q,"Artist is required for this getter\n");
+        isValid = FALSE;
+    }
 
-if(fetch->reqs & GLYR_REQUIRES_ALBUM && q->album == NULL) {
-glyr_message(2, q, "Albumname is required for this getter\n");
-isValid = FALSE;
-}
+    if (fetch->reqs & GLYR_REQUIRES_ALBUM && q->album == NULL)
+    {
+        glyr_message (2,q,"Albumname is required for this getter\n");
+        isValid = FALSE;
+    }
 
-if(fetch->reqs & GLYR_REQUIRES_TITLE && q->title == NULL) {
-glyr_message(2, q, "Songname is required for this getter\n");
-isValid = FALSE;
-}
+    if (fetch->reqs & GLYR_REQUIRES_TITLE && q->title == NULL)
+    {
+        glyr_message (2,q,"Songname is required for this getter\n");
+        isValid = FALSE;
+    }
 
-if(isValid == FALSE && fetch->reqs > GLYR_REQUIRES_TITLE) {
-char *f1 = "", * f2 = "", * f3 = "";
-if(fetch->reqs & GLYR_OPTIONAL_ARTIST) {
-f1 = "Artist ";
-}
-if(fetch->reqs & GLYR_OPTIONAL_ALBUM) {
-f2 = "Album ";
-}
-if(fetch->reqs & GLYR_OPTIONAL_TITLE) {
-f3 = "Songtitle ";
-}
+    if (isValid == FALSE && fetch->reqs > GLYR_REQUIRES_TITLE)
+    {
+        char * f1 = "",* f2 = "", * f3 = "";
+        if (fetch->reqs & GLYR_OPTIONAL_ARTIST) f1 = "Artist ";
+        if (fetch->reqs & GLYR_OPTIONAL_ALBUM)  f2 = "Album ";
+        if (fetch->reqs & GLYR_OPTIONAL_TITLE)  f3 = "Songtitle ";
 
-if(*f1 || *f2 || *f3) {
-glyr_message(2, q, "\nFollowing fields are optional: %s%s%s\n", f1, f2, f3);
-}
-}
-return isValid;
+        if (*f1 || *f2 || *f3)
+        {
+            glyr_message (2,q,"\nFollowing fields are optional: %s%s%s\n",f1,f2,f3);
+        }
+    }
+    return isValid;
 }
 
 /////////////////////////////////
 
-static void set_error(GLYR_ERROR err_in, GlyrQuery *query, GLYR_ERROR *err_out)
+static void set_error (GLYR_ERROR err_in, GlyrQuery * query, GLYR_ERROR * err_out)
 {
-if(query) {
-query->q_errno = err_in;
-}
-if(err_out) {
-*err_out = err_in;
-}
+    if (query)
+        query->q_errno = err_in;
+    if (err_out)
+        *err_out = err_in;
 }
 
 /////////////////////////////////
@@ -879,385 +859,439 @@ if(err_out) {
         }                                                   \
     }                                                       \
 
-__attribute__((visibility("default")))
-GlyrMemCache *glyr_get(GlyrQuery *query, GLYR_ERROR *e, int *length)
+__attribute__ ( (visibility ("default") ) )
+GlyrMemCache * glyr_get (GlyrQuery * query, GLYR_ERROR * e, int * length)
 {
-if(is_initalized == FALSE || QUERY_IS_INITALIZED(query) == FALSE) {
-glyr_message(-1, NULL, "Warning: Either query or library is not initialized.\n");
-if(e != NULL) {
-set_error(GLYRE_NO_INIT, query, e);
-}
-return NULL;
-}
-
-set_error(GLYRE_OK, query, e);
-
-if(query != NULL) {
-if(g_ascii_strncasecmp(query->lang, "auto", 4) == 0) {
-glyr_opt_lang(query, "auto");
-}
-
-GList *result = NULL;
-set_error(GLYRE_UNKNOWN_GET, query, e);
-
-for(GList *elem = r_getFList(); elem; elem = elem->next) {
-MetaDataFetcher *item = elem->data;
-if(query->type == item->type) {
-if(check_if_valid(query, item) == TRUE) {
-/* Print some user info, always useful */
-if(query->normalization & GLYR_NORMALIZE_ARTIST) {
-PRINT_NORMALIZED_ATTR("- Artist   : ", query->normalization, query->artist);
-} else {
-PRINT_NORMALIZED_ATTR("- Artist   : ", GLYR_NORMALIZE_NONE, query->artist);
-}
-
-if(query->normalization & GLYR_NORMALIZE_ALBUM) {
-PRINT_NORMALIZED_ATTR("- Album    : ", query->normalization, query->album);
-} else {
-PRINT_NORMALIZED_ATTR("- Album    : ", GLYR_NORMALIZE_NONE, query->album);
-}
-
-if(query->normalization & GLYR_NORMALIZE_TITLE) {
-PRINT_NORMALIZED_ATTR("- Title    : ", query->normalization, query->title);
-} else {
-PRINT_NORMALIZED_ATTR("- Title    : ", GLYR_NORMALIZE_NONE, query->title);
-}
-
-if(query->lang != NULL) {
-glyr_message(2, query, "- Language : ");
-glyr_message(2, query, "%s\n", query->lang);
-}
-
-set_error(GLYRE_OK, query, e);
-glyr_message(2, query, "- Type     : %s\n\n", item->name);
-
-/* Lookup what we search for here: Images (url, or raw) or text */
-query->imagejob = !(item->full_data);
+    if (is_initalized == FALSE || QUERY_IS_INITALIZED (query) == FALSE)
+    {
+        glyr_message (-1,NULL,"Warning: Either query or library is not initialized.\n");
+        if (e != NULL)
+        {
+            set_error (GLYRE_NO_INIT, query, e);
+        }
+        return NULL;
+    }
 
-/* If ->parallel is <= 0, it gets autodetected */
-auto_detect_parallel(item, query);
+    set_error (GLYRE_OK, query, e);
 
-/* Now start your engines, gentlemen */
-result = start_engine(query, item, e);
-break;
-} else {
-set_error(GLYRE_INSUFF_DATA, query, e);
-}
-}
-}
-
-/* Make this query reusable */
-query->itemctr = 0;
+    if (query != NULL)
+    {
+        if (g_ascii_strncasecmp (query->lang,"auto",4) == 0)
+        {
+            glyr_opt_lang (query,"auto");
+        }
 
-/* Start of the returned list */
-GlyrMemCache *head = NULL;
+        GList * result = NULL;
+        set_error (GLYRE_UNKNOWN_GET, query, e);
+
+        for (GList * elem = r_getFList(); elem; elem = elem->next)
+        {
+            MetaDataFetcher * item = elem->data;
+            if (query->type == item->type)
+            {
+                if (check_if_valid (query,item) == TRUE)
+                {
+                    /* Print some user info, always useful */
+                    if (query->normalization & GLYR_NORMALIZE_ARTIST) {
+                        PRINT_NORMALIZED_ATTR("- Artist   : ", query->normalization, query->artist);
+                    } else {
+                        PRINT_NORMALIZED_ATTR("- Artist   : ", GLYR_NORMALIZE_NONE, query->artist);
+                    }
+
+                    if (query->normalization & GLYR_NORMALIZE_ALBUM) {
+                        PRINT_NORMALIZED_ATTR("- Album    : ", query->normalization, query->album);
+                    } else {
+                        PRINT_NORMALIZED_ATTR("- Album    : ", GLYR_NORMALIZE_NONE, query->album);
+                    }
+
+                    if (query->normalization & GLYR_NORMALIZE_TITLE) {
+                        PRINT_NORMALIZED_ATTR("- Title    : ", query->normalization, query->title);
+                    } else {
+                        PRINT_NORMALIZED_ATTR("- Title    : ", GLYR_NORMALIZE_NONE, query->title);
+                    }
+
+                    if (query->lang != NULL)
+                    {
+                        glyr_message (2,query,"- Language : ");
+                        glyr_message (2,query,"%s\n",query->lang);
+                    }
+
+                    set_error (GLYRE_OK, query, e);
+                    glyr_message (2,query,"- Type     : %s\n\n",item->name);
+
+                    /* Lookup what we search for here: Images (url, or raw) or text */
+                    query->imagejob = ! (item->full_data);
+
+                    /* If ->parallel is <= 0, it gets autodetected */
+                    auto_detect_parallel (item, query);
+
+                    /* Now start your engines, gentlemen */
+                    result = start_engine (query,item,e);
+                    break;
+                }
+                else
+                {
+                    set_error (GLYRE_INSUFF_DATA, query, e);
+                }
+            }
+        }
 
-/* Librarby was stopped, just return NULL. */
-if(result != NULL && GET_ATOMIC_SIGNAL_EXIT(query)) {
-for(GList *elem = result; elem; elem = elem->next) {
-DL_free(elem->data);
-}
+        /* Make this query reusable */
+        query->itemctr = 0;
 
-g_list_free(result);
-result = NULL;
+        /* Start of the returned list */
+        GlyrMemCache * head = NULL;
 
-set_error(GLYRE_WAS_STOPPED, query, e);
-}
+        /* Librarby was stopped, just return NULL. */
+        if (result != NULL && GET_ATOMIC_SIGNAL_EXIT (query) )
+        {
+            for (GList * elem = result; elem; elem = elem->next)
+                DL_free (elem->data);
 
-/* Set the length */
-if(length != NULL) {
-*length = g_list_length(result);
-}
+            g_list_free (result);
+            result = NULL;
 
-/* free if empty */
-if(result != NULL) {
-/* Count inserstions */
-gint db_inserts = 0;
+            set_error (GLYRE_WAS_STOPPED, query, e);
+        }
 
-/* link caches to each other */
-for(GList *elem = result; elem; elem = elem->next) {
-GlyrMemCache *item = elem->data;
-item->next = (elem->next) ? elem->next->data : NULL;
-item->prev = (elem->prev) ? elem->prev->data : NULL;
+        /* Set the length */
+        if (length != NULL)
+        {
+            *length = g_list_length (result);
+        }
 
-if(query->db_autowrite && query->local_db && item->cached == FALSE) {
-db_inserts++;
-glyr_db_insert(query->local_db, query, item);
-}
-}
+        /* free if empty */
+        if (result != NULL)
+        {
+            /* Count inserstions */
+            gint db_inserts = 0;
+
+            /* link caches to each other */
+            for (GList * elem = result; elem; elem = elem->next)
+            {
+                GlyrMemCache * item = elem->data;
+                item->next = (elem->next) ? elem->next->data : NULL;
+                item->prev = (elem->prev) ? elem->prev->data : NULL;
+
+                if (query->db_autowrite && query->local_db && item->cached == FALSE)
+                {
+                    db_inserts++;
+                    glyr_db_insert (query->local_db,query,item);
+                }
+            }
 
-if(db_inserts > 0) {
-glyr_message(2, query, "--- Inserted %d item%s into db.\n", db_inserts, (db_inserts == 1) ? "" : "s");
-}
+            if (db_inserts > 0)
+            {
+                glyr_message (2,query,"--- Inserted %d item%s into db.\n",db_inserts, (db_inserts == 1) ? "" : "s");
+            }
 
-/* Finish. */
-if(g_list_first(result)) {
-head = g_list_first(result)->data;
-}
+            /* Finish. */
+            if (g_list_first (result) )
+            {
+                head = g_list_first (result)->data;
+            }
 
-g_list_free(result);
-result = NULL;
-}
+            g_list_free (result);
+            result = NULL;
+        }
 
-/* Done! */
-SET_ATOMIC_SIGNAL_EXIT(query, 0);
-return head;
-}
+        /* Done! */
+        SET_ATOMIC_SIGNAL_EXIT (query,0);
+        return head;
+    }
 
-set_error(GLYRE_EMPTY_STRUCT, query, e);
-SET_ATOMIC_SIGNAL_EXIT(query, 0);
-return NULL;
+    set_error (GLYRE_EMPTY_STRUCT, query, e);
+    SET_ATOMIC_SIGNAL_EXIT (query,0);
+    return NULL;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-int glyr_cache_write(GlyrMemCache *data, const char *path)
+__attribute__ ( (visibility ("default") ) )
+int glyr_cache_write (GlyrMemCache * data, const char * path)
 {
-int bytes = -1;
-if(path) {
-if(!g_ascii_strcasecmp(path, "null")) {
-bytes = 0;
-} else if(!g_ascii_strcasecmp(path, "stdout")) {
-bytes = fwrite(data->data, 1, data->size, stdout);
-fputc('\n', stdout);
-} else if(!g_ascii_strcasecmp(path, "stderr")) {
-bytes = fwrite(data->data, 1, data->size, stderr);
-fputc('\n', stderr);
-} else {
-FILE *fp = fopen(path, "w");
-if(fp) {
-if(data->data != NULL) {
-bytes = fwrite(data->data, 1, data->size, fp);
-}
-fclose(fp);
-} else {
-glyr_message(-1, NULL, "glyr_cache_write: Unable to write to '%s'!\n", path);
-}
-}
-}
-return bytes;
+    int bytes = -1;
+    if (path)
+    {
+        if (!g_ascii_strcasecmp (path,"null") )
+        {
+            bytes = 0;
+        }
+        else if (!g_ascii_strcasecmp (path,"stdout") )
+        {
+            bytes=fwrite (data->data,1,data->size,stdout);
+            fputc ('\n',stdout);
+        }
+        else if (!g_ascii_strcasecmp (path,"stderr") )
+        {
+            bytes=fwrite (data->data,1,data->size,stderr);
+            fputc ('\n',stderr);
+        }
+        else
+        {
+            FILE * fp = fopen (path,"w");
+            if (fp)
+            {
+                if (data->data != NULL)
+                {
+                    bytes=fwrite (data->data,1,data->size,fp);
+                }
+                fclose (fp);
+            }
+            else
+            {
+                glyr_message (-1,NULL,"glyr_cache_write: Unable to write to '%s'!\n",path);
+            }
+        }
+    }
+    return bytes;
 }
 
 /////////////////////////////////
 
-static int glyr_set_info(GlyrQuery *s, int at, const char *arg)
+static int glyr_set_info (GlyrQuery * s, int at, const char * arg)
 {
-gint result = GLYRE_OK;
-if(s && arg && at >= 0 && at < 10) {
-if(s->info[at] != NULL) {
-g_free((char *) s->info[at]);
-}
+    gint result = GLYRE_OK;
+    if (s && arg && at >= 0 && at < 10)
+    {
+        if (s->info[at] != NULL)
+        {
+            g_free ( (char*) s->info[at]);
+        }
 
-s->info[at] = g_strdup(arg);
-switch(at) {
-case 0:
-s->artist = (gchar *) s->info[at];
-break;
-case 1:
-s->album = (gchar *) s->info[at];
-break;
-case 2:
-s->title = (gchar *) s->info[at];
-break;
-case 3:
-s->proxy = s->info[at];
-break;
-case 4:
-s->from = (gchar *) s->info[at];
-break;
-case 5:
-s->allowed_formats = (gchar *) s->info[at];
-break;
-case 6:
-s->useragent = (gchar *) s->info[at];
-break;
-case 7:
-s->lang = (gchar *) s->info[at];
-break;
-case 8:
-s->musictree_path = (gchar *) s->info[at];
-break;
-default:
-glyr_message(2, s, "Warning: wrong <at> for glyr_info_at!\n");
-}
-} else {
-result = GLYRE_BAD_VALUE;
-}
-return result;
+        s->info[at] = g_strdup (arg);
+        switch (at)
+        {
+        case 0:
+            s->artist = (gchar*) s->info[at];
+            break;
+        case 1:
+            s->album = (gchar*) s->info[at];
+            break;
+        case 2:
+            s->title = (gchar*) s->info[at];
+            break;
+        case 3:
+            s->proxy = s->info[at];
+            break;
+        case 4:
+            s->from = (gchar*) s->info[at];
+            break;
+        case 5:
+            s->allowed_formats = (gchar*) s->info[at];
+            break;
+        case 6:
+            s->useragent = (gchar*) s->info[at];
+            break;
+        case 7:
+            s->lang = (gchar*) s->info[at];
+            break;
+        case 8:
+            s->musictree_path = (gchar * ) s->info[at];
+            break;
+        default:
+            glyr_message (2,s,"Warning: wrong <at> for glyr_info_at!\n");
+        }
+    }
+    else
+    {
+        result = GLYRE_BAD_VALUE;
+    }
+    return result;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-const char *glyr_get_type_to_string(GLYR_GET_TYPE type)
+__attribute__ ( (visibility ("default") ) )
+const char * glyr_get_type_to_string (GLYR_GET_TYPE type)
 {
-const gchar *result = "unknown";
+    const gchar * result = "unknown";
 
-GList *fetcher_list = r_getFList();
-for(GList *elem = fetcher_list; elem != NULL; elem = elem->next) {
-MetaDataFetcher *fetch = elem->data;
-if(fetch->type == type) {
-result = fetch->name;
-break;
-}
-}
+    GList * fetcher_list = r_getFList();
+    for (GList * elem = fetcher_list; elem != NULL; elem = elem->next)
+    {
+        MetaDataFetcher * fetch = elem->data;
+        if (fetch->type == type)
+        {
+            result = fetch->name;
+            break;
+        }
+    }
 
-return result;
+    return result;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_GET_TYPE glyr_string_to_get_type(const char *string)
+__attribute__ ( (visibility ("default") ) )
+GLYR_GET_TYPE glyr_string_to_get_type (const char * string)
 {
-if(string != NULL) {
-GList *fetcher_list = r_getFList();
-for(GList *elem = fetcher_list; elem != NULL; elem = elem->next) {
-MetaDataFetcher *fetch = elem->data;
-if(g_ascii_strcasecmp(fetch->name, string) == 0) {
-return fetch->type;
-break;
-}
-}
-}
-return GLYR_GET_UNKNOWN;
+    if (string != NULL)
+    {
+        GList * fetcher_list = r_getFList();
+        for (GList * elem = fetcher_list; elem != NULL; elem = elem->next)
+        {
+            MetaDataFetcher * fetch = elem->data;
+            if (g_ascii_strcasecmp (fetch->name,string) == 0)
+            {
+                return fetch->type;
+                break;
+            }
+        }
+    }
+    return GLYR_GET_UNKNOWN;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-const char *glyr_data_type_to_string(GLYR_DATA_TYPE type)
+__attribute__ ( (visibility ("default") ) )
+const char * glyr_data_type_to_string (GLYR_DATA_TYPE type)
 {
-if(type > 0 && type < (sizeof(type_strings) / sizeof(const char *))) {
-return type_strings[type];
-} else {
-return type_strings[GLYR_TYPE_UNKNOWN];
-}
+    if (type > 0 && type < (sizeof (type_strings) /sizeof (const char*) ) )
+    {
+        return type_strings[type];
+    }
+    else
+    {
+        return type_strings[GLYR_TYPE_UNKNOWN];
+    }
 }
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_DATA_TYPE glyr_string_to_data_type(const char *string)
+__attribute__ ( (visibility ("default") ) )
+GLYR_DATA_TYPE glyr_string_to_data_type (const char * string)
 {
-if(string != NULL) {
-gsize table_size = (sizeof(type_strings) / sizeof(const char *));
-for(gsize i = 0; i < table_size; i++) {
-if(g_ascii_strcasecmp(string, type_strings[i]) == 0) {
-return i;
-}
-}
-}
-return GLYR_TYPE_UNKNOWN;
+    if (string != NULL)
+    {
+        gsize table_size = (sizeof (type_strings) /sizeof (const char*) );
+        for (gsize i = 0; i < table_size; i++)
+        {
+            if (g_ascii_strcasecmp (string,type_strings[i]) == 0)
+                return i;
+        }
+    }
+    return GLYR_TYPE_UNKNOWN;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_cache_print(GlyrMemCache *cacheditem)
+__attribute__ ( (visibility ("default") ) )
+void glyr_cache_print (GlyrMemCache * cacheditem)
 {
-if(cacheditem != NULL) {
-glyr_message(-1, NULL, "FROM: <%s>\n", cacheditem->dsrc);
-glyr_message(-1, NULL, "PROV: %s\n", cacheditem->prov);
-glyr_message(-1, NULL, "SIZE: %d Bytes\n", (int) cacheditem->size);
-glyr_message(-1, NULL, "MSUM: ");
+    if (cacheditem != NULL)
+    {
+        glyr_message (-1,NULL,"FROM: <%s>\n",cacheditem->dsrc);
+        glyr_message (-1,NULL,"PROV: %s\n",cacheditem->prov);
+        glyr_message (-1,NULL,"SIZE: %d Bytes\n", (int) cacheditem->size);
+        glyr_message (-1,NULL,"MSUM: ");
 
 
-/* Print md5sum */
-for(int i = 0; i < 16; i++) {
-fprintf(stderr, "%02x", cacheditem->md5sum[i]);
-}
-
-// Each cache identified it's data by a constant
-glyr_message(-1, NULL, "\nTYPE: ");
-if(cacheditem->type == GLYR_TYPE_TRACK) {
-glyr_message(-1, NULL, "[%02d:%02d] ", cacheditem->duration / 60, cacheditem->duration % 60);
-}
-glyr_message(-1, NULL, "%s", glyr_data_type_to_string(cacheditem->type));
-
-glyr_message(-1, NULL, "\nSAFE: %s", (cacheditem->cached) ? "Yes" : "No");
-glyr_message(-1, NULL, "\nRATE: %d", cacheditem->rating);
-glyr_message(-1, NULL, "\nSTMP: %f", cacheditem->timestamp);
+        /* Print md5sum */
+        for (int i = 0; i < 16; i++)
+        {
+            fprintf (stderr,"%02x", cacheditem->md5sum[i]);
+        }
 
-/* Print the actual data.
- * This might have funny results if using cover/photos
- */
-if(cacheditem->is_image == FALSE) {
-glyr_message(-1, NULL, "\nDATA: \n%s", cacheditem->data);
-} else {
-glyr_message(-1, NULL, "\nFRMT: %s", cacheditem->img_format);
-glyr_message(-1, NULL, "\nDATA: <not printable>");
-}
-glyr_message(-1, NULL, "\n");
-}
+        // Each cache identified it's data by a constant
+        glyr_message (-1,NULL,"\nTYPE: ");
+        if (cacheditem->type == GLYR_TYPE_TRACK)
+        {
+            glyr_message (-1,NULL,"[%02d:%02d] ",cacheditem->duration/60, cacheditem->duration%60);
+        }
+        glyr_message (-1,NULL,"%s",glyr_data_type_to_string (cacheditem->type) );
+
+        glyr_message (-1,NULL,"\nSAFE: %s", (cacheditem->cached) ? "Yes" : "No");
+        glyr_message (-1,NULL,"\nRATE: %d",cacheditem->rating);
+        glyr_message (-1,NULL,"\nSTMP: %f",cacheditem->timestamp);
+
+        /* Print the actual data.
+         * This might have funny results if using cover/photos
+         */
+        if (cacheditem->is_image == FALSE)
+        {
+            glyr_message (-1,NULL,"\nDATA: \n%s",cacheditem->data);
+        }
+        else
+        {
+            glyr_message (-1,NULL,"\nFRMT: %s",cacheditem->img_format);
+            glyr_message (-1,NULL,"\nDATA: <not printable>");
+        }
+        glyr_message (-1,NULL,"\n");
+    }
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GlyrFetcherInfo *glyr_info_get(void)
+__attribute__ ( (visibility ("default") ) )
+GlyrFetcherInfo * glyr_info_get (void)
 {
-return get_plugin_info();
+    return get_plugin_info();
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_info_free(GlyrFetcherInfo *info)
+__attribute__ ( (visibility ("default") ) )
+void glyr_info_free (GlyrFetcherInfo * info)
 {
-free_plugin_info(info);
+    free_plugin_info (info);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-char *glyr_md5sum_to_string(unsigned char *md5sum)
+__attribute__ ( (visibility ("default") ) )
+char * glyr_md5sum_to_string (unsigned char * md5sum)
 {
-gchar *md5str = NULL;
-if(md5sum != NULL) {
-const gchar *hex = "0123456789abcdef";
-md5str = g_malloc0(33);
-for(int i = 0; i < 16; i++) {
-gint index = i * 2;
-md5str[index + 0] = hex[md5sum[i] / 16];
-md5str[index + 1] = hex[md5sum[i] % 16];
-}
-}
-return md5str;
+    gchar * md5str = NULL;
+    if (md5sum != NULL)
+    {
+        const gchar * hex = "0123456789abcdef";
+        md5str = g_malloc0 (33);
+        for (int i = 0; i < 16; i++)
+        {
+            gint index = i * 2;
+            md5str[index + 0] = hex[md5sum[i] / 16];
+            md5str[index + 1] = hex[md5sum[i] % 16];
+        }
+    }
+    return md5str;
 }
 
 /////////////////////////////////
 
 #define CHAR_TO_NUM(c) (unsigned char)(g_ascii_isdigit(c) ? c - '0' : (c - 'a') + 10)
 
-__attribute__((visibility("default")))
-void glyr_string_to_md5sum(const char *string, unsigned char *md5sum)
+__attribute__ ( (visibility ("default") ) )
+void glyr_string_to_md5sum (const char * string, unsigned char * md5sum)
 {
-if(string != NULL && strlen(string) >= 32 && md5sum) {
-for(gint i = 0; i < 16; i++) {
-gint index = i * 2;
-md5sum[i] = (CHAR_TO_NUM(string[index]) << 4) + CHAR_TO_NUM(string[index + 1]);
-}
-}
+    if (string != NULL && strlen (string) >= 32 && md5sum)
+    {
+        for (gint i = 0; i < 16; i++)
+        {
+            gint index = i * 2;
+            md5sum[i] = (CHAR_TO_NUM (string[index]) << 4) + CHAR_TO_NUM (string[index+1]);
+        }
+    }
 }
 #undef CHAR_TO_NUM
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GLYR_FIELD_REQUIREMENT glyr_get_requirements(GLYR_GET_TYPE type)
+__attribute__ ( (visibility ("default") ) )
+GLYR_FIELD_REQUIREMENT glyr_get_requirements (GLYR_GET_TYPE type)
 {
-GLYR_FIELD_REQUIREMENT result = 0;
-GlyrFetcherInfo *info = glyr_info_get();
-GlyrFetcherInfo *head = info;
-while(head != NULL) {
-if(type == head->type) {
-result = head->reqs;
-}
-head = head->next;
-}
-glyr_info_free(info);
-return result;
+    GLYR_FIELD_REQUIREMENT result = 0;
+    GlyrFetcherInfo * info = glyr_info_get();
+    GlyrFetcherInfo * head = info;
+    while (head != NULL)
+    {
+        if (type == head->type)
+        {
+            result = head->reqs;
+        }
+        head = head->next;
+    }
+    glyr_info_free (info);
+    return result;
 }
 
 /* ---------------------------------------------------------
@@ -1278,54 +1312,52 @@ return result;
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_cache_set_dsrc(GlyrMemCache *cache, const char *download_source)
+__attribute__ ( (visibility ("default") ) )
+void glyr_cache_set_dsrc (GlyrMemCache * cache, const char * download_source)
 {
-SET_CACHE_STRING(cache, cache->dsrc, download_source);
+    SET_CACHE_STRING (cache,cache->dsrc,download_source);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_cache_set_prov(GlyrMemCache *cache, const char *provider)
+__attribute__ ( (visibility ("default") ) )
+void glyr_cache_set_prov (GlyrMemCache * cache, const char * provider)
 {
-SET_CACHE_STRING(cache, cache->prov, provider);
+    SET_CACHE_STRING (cache,cache->prov,provider);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_cache_set_img_format(GlyrMemCache *cache, const char *img_format)
+__attribute__ ( (visibility ("default") ) )
+void glyr_cache_set_img_format (GlyrMemCache * cache, const char * img_format)
 {
-SET_CACHE_STRING(cache, cache->img_format, img_format);
+    SET_CACHE_STRING (cache,cache->img_format,img_format);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_cache_set_type(GlyrMemCache *cache, GLYR_DATA_TYPE type)
+__attribute__ ( (visibility ("default") ) )
+void glyr_cache_set_type (GlyrMemCache * cache, GLYR_DATA_TYPE type)
 {
-if(cache != NULL) {
-cache->type = MAX(type, GLYR_TYPE_UNKNOWN);
-}
+    if (cache != NULL)
+        cache->type = MAX (type,GLYR_TYPE_UNKNOWN);
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-void glyr_cache_set_rating(GlyrMemCache *cache, int rating)
+__attribute__ ( (visibility ("default") ) )
+void glyr_cache_set_rating (GlyrMemCache * cache, int rating)
 {
-if(cache != NULL) {
-cache->rating = rating;
-}
+    if (cache != NULL)
+        cache->rating = rating;
 }
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-bool glyr_type_is_image(GLYR_GET_TYPE type)
+__attribute__ ( (visibility ("default") ) )
+bool glyr_type_is_image (GLYR_GET_TYPE type)
 {
-return TYPE_IS_IMAGE(type);
+    return TYPE_IS_IMAGE (type);
 }
 
 /////////////////////////////////
diff --git a/lib/intern/ainfo.c b/lib/intern/ainfo.c
index 921fe6b..fa63475 100644
--- a/lib/intern/ainfo.c
+++ b/lib/intern/ainfo.c
@@ -24,27 +24,30 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
     /* Fix up messy text, escape chars etc.  */
-    for(GList *elem = list; elem; elem = elem->next) {
-        GlyrMemCache *item = elem->data;
-        if(item != NULL) {
+    for (GList * elem = list; elem; elem = elem->next)
+    {
+        GlyrMemCache * item = elem->data;
+        if (item != NULL)
+        {
 
-            gchar *temp = beautify_string(item->data);
-            g_free(item->data);
+            gchar * temp = beautify_string (item->data);
+            g_free (item->data);
             item->data = temp;
-            item->size = (item->data) ? strlen(item->data) : 0;
+            item->size = (item->data) ? strlen (item->data) : 0;
         }
     }
 
-    return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_ARTIST_BIO, result_list);
+    return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_ARTIST_BIO,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_artistbio = {
+MetaDataFetcher glyrFetcher_artistbio =
+{
     .name = "artistbio",
     .type = GLYR_GET_ARTIST_BIO,
     .default_data_type = GLYR_TYPE_ARTIST_BIO,
diff --git a/lib/intern/ainfo/bbcmusic.c b/lib/intern/ainfo/bbcmusic.c
index 6ffa32e..8d8914f 100644
--- a/lib/intern/ainfo/bbcmusic.c
+++ b/lib/intern/ainfo/bbcmusic.c
@@ -29,42 +29,47 @@
 #define CONTENT_BEGIN "<content>"
 #define CONTENT_ENDIN "</content>"
 
-static GlyrMemCache *parse_bbc_xml(GlyrMemCache *input)
+static GlyrMemCache * parse_bbc_xml (GlyrMemCache * input)
 {
-    GlyrMemCache *result = NULL;
-    char *content = get_search_value(input->data, CONTENT_BEGIN, CONTENT_ENDIN);
-    if(content != NULL) {
+    GlyrMemCache * result = NULL;
+    char * content = get_search_value (input->data, CONTENT_BEGIN, CONTENT_ENDIN);
+    if (content != NULL)
+    {
         result = DL_init();
         result->data = content;
-        result->dsrc = g_strdup(input->dsrc);
-        result->size = strlen(content);
+        result->dsrc = g_strdup (input->dsrc);
+        result->size = strlen (content);
     }
     return result;
 }
 
 /////////////////////////////////
 
-static const char *ainfo_bbcmusic_url(GlyrQuery *qry)
+static const char * ainfo_bbcmusic_url (GlyrQuery * qry)
 {
     return "http://musicbrainz.org/ws/2/artist?query=artist:${artist}";
 }
 
 /////////////////////////////////
 
-static GList *ainfo_bbcmusic_parse(cb_object *capo)
+static GList * ainfo_bbcmusic_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
+    GList * result_list = NULL;
 
-    char *mbid = mbid_parse_data(capo->cache, "artist", "name", capo->s->artist, capo->s);
+    char * mbid = mbid_parse_data (capo->cache, "artist", "name", capo->s->artist, capo->s);
 
-    if(mbid != NULL) {
-        char *full_url = g_strdup_printf(API_ROOT, mbid);
-        if(full_url != NULL) {
-            GlyrMemCache *bbc_xml = download_single(full_url, capo->s, NULL);
-            if(bbc_xml != NULL) {
-                GlyrMemCache *item = parse_bbc_xml(bbc_xml);
-                if(item != NULL) {
-                    result_list = g_list_prepend(result_list, item);
+    if (mbid != NULL)
+    {
+        char * full_url = g_strdup_printf (API_ROOT, mbid);
+        if (full_url != NULL)
+        {
+            GlyrMemCache * bbc_xml = download_single (full_url, capo->s, NULL);
+            if (bbc_xml != NULL)
+            {
+                GlyrMemCache * item = parse_bbc_xml (bbc_xml);
+                if (item != NULL)
+                {
+                    result_list = g_list_prepend (result_list, item);
                 }
                 DL_free(bbc_xml);
             }
@@ -78,7 +83,8 @@ static GList *ainfo_bbcmusic_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource ainfo_bbcmusic_src = {
+MetaDataSource ainfo_bbcmusic_src =
+{
     .name      = "bbcmusic",
     .key       = 'b',
     .free_url  = false,
diff --git a/lib/intern/ainfo/echonest.c b/lib/intern/ainfo/echonest.c
index 48a8f64..b7c6c22 100644
--- a/lib/intern/ainfo/echonest.c
+++ b/lib/intern/ainfo/echonest.c
@@ -24,21 +24,21 @@
 /* JSON Parsing */
 #include "../../jsmn/jsmn.h"
 
-static const gchar *ainfo_echonest_url(GlyrQuery *s)
+static const gchar * ainfo_echonest_url (GlyrQuery * s)
 {
     return "http://developer.echonest.com/api/v4/artist/biographies?api_key="API_KEY_ECHONEST"&results=${number}&format=json&name=${artist}";
 }
 
 /////////////////////////////////
 
-static char *echonest_strip_escapes(char *src, char *dest, int len)
+static char * echonest_strip_escapes(char * src, char * dest, int len) 
 {
     int offset = 0;
 
-    for(int i = 0; i < len; ++i) {
-        if(src[i] == '\\') {
+    for (int i = 0; i < len; ++i) {
+        if (src[i] == '\\') {
             ++i;
-            if(src[i] == 'n') {
+            if (src[i] == 'n') {
                 dest[offset++] = '\n';
                 continue;
             }
@@ -51,10 +51,10 @@ static char *echonest_strip_escapes(char *src, char *dest, int len)
 
 /////////////////////////////////
 
-static bool echonest_check_if_text_is_valid(char *text, int len)
+static bool echonest_check_if_text_is_valid(char * text, int len) 
 {
     bool rc = false;
-    if(len >= 125) {
+    if (len >= 125) {
         return true;
     }
 
@@ -63,13 +63,13 @@ static bool echonest_check_if_text_is_valid(char *text, int len)
 
 /////////////////////////////////
 
-static GList *ainfo_echonest_parse(cb_object *capo)
+static GList * ainfo_echonest_parse (cb_object * capo)
 {
-    char *json = capo->cache->data;
+    char * json = capo->cache->data;
     bool is_text = false;
     const int num_tokens = 512;
-
-    GList *results = NULL;
+    
+    GList * results = NULL;
 
     /* jasmin stuff */
     jsmn_parser parser;
@@ -85,30 +85,30 @@ static GList *ainfo_echonest_parse(cb_object *capo)
     /* Parse the json text */
     error = jsmn_parse(&parser, capo->cache->data, tokens, num_tokens);
 
-    if(error == JSMN_SUCCESS) {
-        for(int i = 0; i < num_tokens; ++i) {
-            jsmntok_t *tok = &tokens[i];
+    if (error == JSMN_SUCCESS) {
+        for (int i = 0; i < num_tokens; ++i) {
+            jsmntok_t * tok = &tokens[i];
             size_t len = tok->end - tok->start;
-            char *text_off = json + tok->start;
-
+            char * text_off = json + tok->start;
+            
             /* End of tokens? */
             if(tok->start == 0 && tok->end == 0) {
                 break;
             }
 
             /* Check for the "text" field. */
-            if(tok->type == JSMN_STRING) {
-                if(len == 4 && g_ascii_strncasecmp(text_off, "text", len) == 0) {
+            if (tok->type == JSMN_STRING) {
+                if (len == 4 && g_ascii_strncasecmp(text_off, "text", len) == 0) {
                     is_text = true;
                     continue;
                 }
             }
 
             /* Interesting part! */
-            if(is_text == true && tok->type == JSMN_STRING) {
-                if(echonest_check_if_text_is_valid(text_off, len)) {
-                    GlyrMemCache *cache = DL_init();
-                    if(cache != NULL) {
+            if (is_text == true && tok->type == JSMN_STRING) {
+                if (echonest_check_if_text_is_valid(text_off, len)) {
+                    GlyrMemCache * cache = DL_init();
+                    if (cache != NULL) {
                         cache->data = g_strndup(text_off, len);
                         cache->data = echonest_strip_escapes(cache->data, cache->data, len);
                         cache->size = len;
@@ -128,7 +128,8 @@ static GList *ainfo_echonest_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource ainfo_echonest_src = {
+MetaDataSource ainfo_echonest_src =
+{
     .name      = "echonest",
     .key       = 'e',
     .free_url  = false,
@@ -138,5 +139,5 @@ MetaDataSource ainfo_echonest_src = {
     .quality   = 95,
     .speed     = 85,
     .endmarker = NULL,
-    .lang_aware = false
+    .lang_aware = false 
 };
diff --git a/lib/intern/ainfo/lastfm.c b/lib/intern/ainfo/lastfm.c
index 17e464d..7cd90f1 100644
--- a/lib/intern/ainfo/lastfm.c
+++ b/lib/intern/ainfo/lastfm.c
@@ -26,59 +26,67 @@
 #define CDATA_BEGIN "<![CDATA["
 
 /* Locales that are just mapped to 'en' */
-const char *locale_map_to_en = "ca|uk|us";
+const char * locale_map_to_en = "ca|uk|us";
 
-static const gchar *ainfo_lastfm_url(GlyrQuery *s)
+static const gchar * ainfo_lastfm_url (GlyrQuery * s)
 {
-    gchar *url = NULL;
-    gchar *right_artist = strreplace(s->artist, " ", "+");
-    if(right_artist != NULL) {
-        gchar *lang = "en";
+    gchar * url = NULL;
+    gchar * right_artist = strreplace (s->artist," ","+");
+    if (right_artist != NULL)
+    {
+        gchar * lang = "en";
 
         /* Check if this is an allowed language */
-        if(strstr(GLYR_DEFAULT_SUPPORTED_LANGS, s->lang) != NULL) {
-            lang = (gchar *) s->lang;
+        if (strstr (GLYR_DEFAULT_SUPPORTED_LANGS,s->lang) != NULL)
+        {
+            lang = (gchar*) s->lang;
         }
 
         /* Do we need to map a language to 'en'? */
-        if(strstr(locale_map_to_en, s->lang) != NULL) {
+        if (strstr (locale_map_to_en,s->lang) != NULL)
+        {
             lang = "en";
         }
 
-        url = g_strdup_printf("http://ws.audioscrobbler.com/2.0/?method=artist.getinfo&autocorrect=1&artist=%s&lang=%s&api_key="API_KEY_LASTFM, right_artist, lang);
-        g_free(right_artist);
+        url = g_strdup_printf ("http://ws.audioscrobbler.com/2.0/?method=artist.getinfo&autocorrect=1&artist=%s&lang=%s&api_key="API_KEY_LASTFM,right_artist,lang);
+        g_free (right_artist);
     }
     return url;
 }
 
 /////////////////////////////////
 
-static GList *ainfo_lastfm_parse(cb_object *capo)
+static GList * ainfo_lastfm_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *content_begin = strstr(capo->cache->data, CONTENT_BEGIN);
+    GList * result_list = NULL;
+    gchar * content_begin = strstr (capo->cache->data,CONTENT_BEGIN);
 
-    if(content_begin != NULL) {
-        gchar *content_endin = strstr(capo->cache->data, CONTENT_ENDIN);
+    if (content_begin != NULL)
+    {
+        gchar * content_endin = strstr (capo->cache->data,CONTENT_ENDIN);
 
-        if(content_endin == NULL) {
-            content_endin = strstr(capo->cache->data, OTHER_ENDIN);
+        if (content_endin == NULL)
+        {
+            content_endin = strstr (capo->cache->data,OTHER_ENDIN);
         }
 
-        if(content_endin != NULL) {
+        if (content_endin != NULL)
+        {
             content_begin += (sizeof CONTENT_BEGIN) - 1;
 
-            char *skip_cdata = strstr(content_begin, CDATA_BEGIN);
-            if(skip_cdata != NULL) {
+            char * skip_cdata = strstr(content_begin, CDATA_BEGIN);
+            if (skip_cdata != NULL)
+            {
                 content_begin = skip_cdata + (sizeof CDATA_BEGIN) - 1;
             }
 
-            gchar *content = copy_value(content_begin, content_endin);
-            if(content != NULL) {
-                GlyrMemCache *result = DL_init();
+            gchar * content = copy_value (content_begin,content_endin);
+            if (content != NULL)
+            {
+                GlyrMemCache * result = DL_init();
                 result->data = content;
-                result->size = strlen(result->data);
-                result_list = g_list_prepend(result_list, result);
+                result->size = strlen (result->data);
+                result_list = g_list_prepend (result_list,result);
             }
         }
     }
@@ -87,7 +95,8 @@ static GList *ainfo_lastfm_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource ainfo_lastfm_src = {
+MetaDataSource ainfo_lastfm_src =
+{
     .name      = "lastfm",
     .key       = 'l',
     .free_url  = true,
diff --git a/lib/intern/ainfo/lyricsreg.c b/lib/intern/ainfo/lyricsreg.c
index 05f245b..4ed6866 100644
--- a/lib/intern/ainfo/lyricsreg.c
+++ b/lib/intern/ainfo/lyricsreg.c
@@ -26,36 +26,41 @@
 #define INFO_ENDIN "</div>"
 /////////////////////////////////
 
-static const gchar *ainfo_lyricsreg_url(GlyrQuery *s)
+static const gchar * ainfo_lyricsreg_url (GlyrQuery * s)
 {
     return "http://www.lyricsreg.com/biography/${artist}/";
 }
 
 /////////////////////////////////
 
-static GList *ainfo_lyricsreg_parse(cb_object *capo)
+static GList * ainfo_lyricsreg_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *point_to_start = strstr(capo->cache->data, INFO_BEGIN);
-    if(point_to_start != NULL) {
-        gchar *opt_begin = strstr(point_to_start, OPTN_BEGIN);
+    GList * result_list = NULL;
+    gchar * point_to_start = strstr (capo->cache->data,INFO_BEGIN);
+    if (point_to_start != NULL)
+    {
+        gchar * opt_begin = strstr (point_to_start,OPTN_BEGIN);
         gsize skip_len = (sizeof INFO_BEGIN) - 1;
-        if(opt_begin != NULL) {
+        if (opt_begin != NULL)
+        {
             point_to_start = opt_begin;
             skip_len = (sizeof OPTN_BEGIN) - 1;
         }
 
         point_to_start += skip_len;
-        gchar *end = strstr(point_to_start, INFO_ENDIN);
-        if(end != NULL) {
+        gchar * end = strstr (point_to_start, INFO_ENDIN);
+        if (end != NULL)
+        {
             gsize info_len = end - point_to_start;
-            if(info_len > 200) {
-                gchar *info = copy_value(point_to_start, end);
-                if(info != NULL) {
-                    GlyrMemCache *result = DL_init();
+            if (info_len > 200)
+            {
+                gchar * info = copy_value (point_to_start, end);
+                if (info != NULL)
+                {
+                    GlyrMemCache * result = DL_init();
                     result->data = info;
                     result->size = info_len;
-                    result_list = g_list_prepend(result_list, result);
+                    result_list = g_list_prepend (result_list,result);
                 }
             }
         }
@@ -65,7 +70,8 @@ static GList *ainfo_lyricsreg_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource ainfo_lyricsreg_src = {
+MetaDataSource ainfo_lyricsreg_src =
+{
     .name      = "lyricsreg",
     .key       = 'r',
     .free_url  = false,
diff --git a/lib/intern/albumlist.c b/lib/intern/albumlist.c
index 14a8705..1df737a 100644
--- a/lib/intern/albumlist.c
+++ b/lib/intern/albumlist.c
@@ -24,15 +24,16 @@
 
 //-------------------------------------
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
-    return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_ALBUMLIST, result_list);
+    return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_ALBUMLIST,result_list);
 }
 
 //-------------------------------------
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_albumlist = {
+MetaDataFetcher glyrFetcher_albumlist =
+{
     .name = "albumlist",
     .type = GLYR_GET_ALBUMLIST,
     .default_data_type = GLYR_TYPE_ALBUMLIST,
diff --git a/lib/intern/albumlist/musicbrainz.c b/lib/intern/albumlist/musicbrainz.c
index c8c2874..f60c13b 100644
--- a/lib/intern/albumlist/musicbrainz.c
+++ b/lib/intern/albumlist/musicbrainz.c
@@ -21,7 +21,7 @@
 #include "../../stringlib.h"
 #include "../../core.h"
 
-static const gchar *albumlist_musicbrainz_url(GlyrQuery *sets)
+static const gchar * albumlist_musicbrainz_url (GlyrQuery * sets)
 {
     return "http://musicbrainz.org/ws/1/release/?type=xml&artist=${artist}&limit=100";
 }
@@ -42,13 +42,16 @@ static const gchar *albumlist_musicbrainz_url(GlyrQuery *sets)
 
 /////////////////////////////////////////////////////////////
 
-static bool is_in_list(GList *list, const char *to_cmp)
+static bool is_in_list (GList * list, const char * to_cmp)
 {
     bool rc = false;
-    for(GList *elem = list; elem; elem = elem->next) {
-        GlyrMemCache *item = elem->data;
-        if(item != NULL) {
-            if(g_ascii_strcasecmp(item->data, to_cmp) == 0) {
+    for (GList * elem = list; elem; elem = elem->next)
+    {
+        GlyrMemCache * item = elem->data;
+        if (item != NULL)
+        {
+            if (g_ascii_strcasecmp (item->data,to_cmp) == 0)
+            {
                 rc = true;
                 break;
             }
@@ -60,14 +63,13 @@ static bool is_in_list(GList *list, const char *to_cmp)
 
 /////////////////////////////////////////////////////////////
 
-static bool type_is_valid(const char *type)
+static bool type_is_valid (const char * type)
 {
     bool result = FALSE;
-    if(type == NULL) {
+    if (type == NULL)
         return result;
-    }
 
-    static const char *valid_types[] = {
+    static const char * valid_types[] = {
         "Single Official",
         "Album Official",
         NULL
@@ -75,7 +77,7 @@ static bool type_is_valid(const char *type)
 
     int check_idx = 0;
     while(valid_types[check_idx]) {
-        if(g_strcmp0(valid_types[check_idx], type) == 0) {
+        if (g_strcmp0(valid_types[check_idx], type) == 0) {
             result = TRUE;
             break;
         }
@@ -87,42 +89,48 @@ static bool type_is_valid(const char *type)
 
 /////////////////////////////////////////////////////////////
 
-static GList *albumlist_musicbrainz_parse(cb_object *capo)
+static GList * albumlist_musicbrainz_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *node = capo->cache->data;
+    GList * result_list = NULL;
+    gchar * node = capo->cache->data;
 
-    while(continue_search(g_list_length(result_list), capo->s) &&
-            (node = strstr(node + 1, ALBUM_BEGIN)) != NULL) {
-        gchar *type = get_search_value(node, TYPE_BEGIN, TYPE_ENDIN);
-        if(type_is_valid(type)) {
-            gchar *artist = get_search_value(node, ARTIST_BEGIN, ARTIST_ENDIN);
-            if(artist != NULL &&
-                    levenshtein_strnormcmp(capo->s, capo->s->artist, artist) <= capo->s->fuzzyness) {
+    while (continue_search (g_list_length (result_list),capo->s) &&
+            (node = strstr (node + 1, ALBUM_BEGIN) ) != NULL)
+    {
+        gchar * type = get_search_value (node, TYPE_BEGIN, TYPE_ENDIN);
+        if (type_is_valid (type)) 
+        {
+            gchar * artist = get_search_value (node,ARTIST_BEGIN, ARTIST_ENDIN);
+            if (artist != NULL && 
+                    levenshtein_strnormcmp (capo->s, capo->s->artist, artist) <= capo->s->fuzzyness) {
 
 
-                gchar *name = get_search_value(node, TITLE_BEGIN, TITLE_ENDIN);
+                gchar * name = get_search_value (node,TITLE_BEGIN,TITLE_ENDIN);
 
-                if(name != NULL && is_in_list(result_list, name) == false) {
-                    GlyrMemCache *result = DL_init();
+                if (name != NULL && is_in_list (result_list,name) == false)
+                {
+                    GlyrMemCache * result = DL_init();
                     result->data = name;
-                    result->size = (result->data) ? strlen(result->data) : 0;
-                    result_list = g_list_prepend(result_list, result);
-                } else {
-                    g_free(name);
+                    result->size = (result->data) ? strlen (result->data) : 0;
+                    result_list = g_list_prepend (result_list,result);
+                }
+                else 
+                {
+                    g_free (name);
                 }
             }
-            g_free(artist);
+            g_free (artist);
         }
 
-        g_free(type);
+        g_free (type);
     }
     return result_list;
 }
 
 /////////////////////////////////////////////////////////////
 
-MetaDataSource albumlist_musicbrainz_src = {
+MetaDataSource albumlist_musicbrainz_src =
+{
     .name = "musicbrainz",
     .key = 'm',
     .free_url = false,
diff --git a/lib/intern/backdrops.c b/lib/intern/backdrops.c
index 4fbced8..3671644 100644
--- a/lib/intern/backdrops.c
+++ b/lib/intern/backdrops.c
@@ -23,15 +23,16 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
-    return generic_img_finalizer(s, list, stop_me, GLYR_TYPE_BACKDROPS, result_list);
+    return generic_img_finalizer (s,list,stop_me,GLYR_TYPE_BACKDROPS,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_backdrops = {
+MetaDataFetcher glyrFetcher_backdrops =
+{
     .name = "backdrops",
     .type = GLYR_GET_BACKDROPS,
     .default_data_type = GLYR_TYPE_BACKDROPS,
diff --git a/lib/intern/backdrops/htbackdrops.c b/lib/intern/backdrops/htbackdrops.c
index 97fd2b4..cbb912c 100644
--- a/lib/intern/backdrops/htbackdrops.c
+++ b/lib/intern/backdrops/htbackdrops.c
@@ -26,31 +26,33 @@
     "/searchXML?keywords=${artist}&default_operator=and&"  \
     "fields=title&inc=mb_name&limit=%d&dmax_w=%d&dmin_h=%d"
 
-static const gchar *backdrops_htbackdrops_url(GlyrQuery *q)
+static const gchar * backdrops_htbackdrops_url (GlyrQuery * q)
 {
-    gchar *result = g_strdup_printf(HTBACKDROPS_URL, API_KEY_HTBACK, q->number * 20,
-                                    (q->img_max_size < 0) ? (gint) 1e10 : q->img_max_size,
-                                    (q->img_min_size < 0) ? 0          : q->img_min_size);
+    gchar * result = g_strdup_printf (HTBACKDROPS_URL, API_KEY_HTBACK,q->number * 20,
+                                      (q->img_max_size < 0) ? (gint) 1e10 : q->img_max_size,
+                                      (q->img_min_size < 0) ? 0          : q->img_min_size);
 
     return result;
 }
 
 /////////////////////////////////
 
-static gboolean check_size(GlyrQuery *query, const gchar *size_string)
+static gboolean check_size (GlyrQuery * query, const gchar * size_string)
 {
     gboolean result = FALSE;
-    if(size_string != NULL && query != NULL) {
-        /* "1024x1024" -> ["1024", 1024"] */
-        gchar **strv = g_strsplit(size_string, "x", 0);
-        if(strv && strv[0] && strv[1]) {
-            gint width  = strtol(strv[0], NULL, 10);
-            gint height = strtol(strv[1], NULL, 10);
+    if (size_string != NULL && query != NULL)
+    {
+        /* "1024x1024" -> ["1024","1024"] */
+        gchar ** strv = g_strsplit (size_string,"x",0);
+        if (strv && strv[0] && strv[1])
+        {
+            gint width  = strtol (strv[0],NULL,10);
+            gint height = strtol (strv[1],NULL,10);
             gint img_size = (width + height) / 2;
 
-            result = size_is_okay(img_size, query->img_min_size, query->img_max_size);
+            result = size_is_okay (img_size, query->img_min_size, query->img_max_size);
         }
-        g_strfreev(strv);
+        g_strfreev (strv);
     }
     return result;
 }
@@ -59,31 +61,36 @@ static gboolean check_size(GlyrQuery *query, const gchar *size_string)
 
 #define NODE "<image>"
 
-static GList *backdrops_htbackdrops_parse(cb_object *capo)
+static GList * backdrops_htbackdrops_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *img_list_start = strstr(capo->cache->data, "<images>");
-    if(img_list_start != NULL) {
-        gchar *node = img_list_start;
-        while(continue_search(g_list_length(result_list), capo->s) && (node = strstr(node, NODE))) {
+    GList * result_list = NULL;
+    gchar * img_list_start = strstr (capo->cache->data,"<images>");
+    if (img_list_start != NULL)
+    {
+        gchar * node = img_list_start;
+        while (continue_search (g_list_length (result_list),capo->s) && (node = strstr (node,NODE) ) )
+        {
             node += sizeof NODE;
 
-            gchar *dimensions = get_search_value(node, "<dimensions>", "</dimensions>");
-            if(check_size(capo->s, dimensions) == TRUE) {
-                gchar *validate_artist = get_search_value(node, "<mb_name>", "</mb_name>");
-                if(levenshtein_strnormcmp(capo->s, validate_artist, capo->s->artist) <= capo->s->fuzzyness) {
-                    gchar *id = get_search_value(node, "<id>", "</id>");
-                    if(id != NULL) {
-                        GlyrMemCache *result = DL_init();
-                        result->data = g_strdup_printf("http://htbackdrops.org/api/"API_KEY_HTBACK"/download/%s/fullsize", id);
-                        result->size = strlen(result->data);
-                        result_list  = g_list_prepend(result_list, result);
-                        g_free(id);
+            gchar * dimensions = get_search_value (node,"<dimensions>","</dimensions>");
+            if (check_size (capo->s,dimensions) == TRUE)
+            {
+                gchar * validate_artist = get_search_value (node,"<mb_name>","</mb_name>");
+                if (levenshtein_strnormcmp (capo->s,validate_artist,capo->s->artist) <= capo->s->fuzzyness)
+                {
+                    gchar * id = get_search_value (node,"<id>","</id>");
+                    if (id != NULL)
+                    {
+                        GlyrMemCache * result = DL_init();
+                        result->data = g_strdup_printf ("http://htbackdrops.org/api/"API_KEY_HTBACK"/download/%s/fullsize",id);
+                        result->size = strlen (result->data);
+                        result_list  = g_list_prepend (result_list,result);
+                        g_free (id);
                     }
                 }
-                g_free(validate_artist);
+                g_free (validate_artist);
             }
-            g_free(dimensions);
+            g_free (dimensions);
         }
     }
     return result_list;
@@ -91,7 +98,8 @@ static GList *backdrops_htbackdrops_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource backdrops_htbackdrops_src = {
+MetaDataSource backdrops_htbackdrops_src =
+{
     .name = "htbackdrops",
     .key  = 'h',
     .parser    = backdrops_htbackdrops_parse,
diff --git a/lib/intern/cache/db_provider.c b/lib/intern/cache/db_provider.c
index 1bc12f8..c5593ac 100644
--- a/lib/intern/cache/db_provider.c
+++ b/lib/intern/cache/db_provider.c
@@ -22,22 +22,27 @@
 
 /////////////////////////////////
 
-static GList *local_provider_parse(cb_object *capo)
+static GList * local_provider_parse (cb_object * capo)
 {
-    GList *converter_list = NULL;
-    if(capo->s && capo->s->local_db != NULL) {
+    GList * converter_list = NULL;
+    if (capo->s && capo->s->local_db != NULL)
+    {
         gint counter = 0;
-        GlyrMemCache *head = glyr_db_lookup(capo->s->local_db, capo->s);
-        while(head != NULL) {
-            if(counter < capo->s->number) {
-                converter_list = g_list_prepend(converter_list, head);
+        GlyrMemCache * head = glyr_db_lookup (capo->s->local_db,capo->s);
+        while (head != NULL)
+        {
+            if (counter < capo->s->number)
+            {
+                converter_list = g_list_prepend (converter_list,head);
                 head->cached = TRUE;
                 head = head->next;
                 counter++;
-            } else {
-                GlyrMemCache *to_delete = head;
+            }
+            else
+            {
+                GlyrMemCache * to_delete = head;
                 head = head->next;
-                DL_free(to_delete);
+                DL_free (to_delete);
             }
         }
     }
@@ -46,14 +51,15 @@ static GList *local_provider_parse(cb_object *capo)
 
 /////////////////////////////////
 
-static const gchar *local_provider_url(GlyrQuery *sets)
+static const gchar * local_provider_url (GlyrQuery * sets)
 {
     return OFFLINE_PROVIDER;
 }
 
 /////////////////////////////////
 
-MetaDataSource local_provider_src = {
+MetaDataSource local_provider_src =
+{
     .name = "local",
     .key  = 'l',
     .parser    = local_provider_parse,
diff --git a/lib/intern/common/amazon.c b/lib/intern/common/amazon.c
index b7f9869..fcba773 100644
--- a/lib/intern/common/amazon.c
+++ b/lib/intern/common/amazon.c
@@ -27,28 +27,29 @@
 
 #define ACCESS_KEY API_KEY_AMAZON
 #define rg_markup "__RESPONSE_GROUP__"
-const gchar *generic_amazon_url(GlyrQuery *sets, const gchar *response_group)
+const gchar * generic_amazon_url (GlyrQuery * sets, const gchar * response_group)
 {
-    const char *lang_link = NULL;
-    if(sets->img_min_size <= 500 || sets->img_min_size) {
-        if(!strcmp(sets->lang, "us")) {
+    const char * lang_link = NULL;
+    if (sets->img_min_size <= 500 || sets->img_min_size)
+    {
+        if (!strcmp (sets->lang,"us") )
             lang_link = "http://free.apisigning.com/onca/xml?Service=AWSECommerceService&AWSAccessKeyId="ACCESS_KEY"&Operation=ItemSearch&SearchIndex=Music&ResponseGroup="rg_markup"&Keywords=${artist}+${album}\0";
-        } else if(!strcmp(sets->lang, "ca")) {
+        else if (!strcmp (sets->lang,"ca") )
             lang_link = "http://ca.free.apisigning.com/onca/xml?Service=AWSECommerceService&AWSAccessKeyId="ACCESS_KEY"&Operation=ItemSearch&SearchIndex=Music&ResponseGroup="rg_markup"&Keywords=${artist}+${album}\0";
-        } else if(!strcmp(sets->lang, "uk")) {
+        else if (!strcmp (sets->lang,"uk") )
             lang_link = "http://co.uk.free.apisigning.com/onca/xml?Service=AWSECommerceService&AWSAccessKeyId="ACCESS_KEY"&Operation=ItemSearch&SearchIndex=Music&ResponseGroup="rg_markup"&Keywords=${artist}+${album}\0";
-        } else if(!strcmp(sets->lang, "fr")) {
+        else if (!strcmp (sets->lang,"fr") )
             lang_link = "http://fr.free.apisigning.com/onca/xml?Service=AWSECommerceService&AWSAccessKeyId="ACCESS_KEY"&Operation=ItemSearch&SearchIndex=Music&ResponseGroup="rg_markup"&Keywords=${artist}+${album}\0";
-        } else if(!strcmp(sets->lang, "de")) {
+        else if (!strcmp (sets->lang,"de") )
             lang_link = "http://de.free.apisigning.com/onca/xml?Service=AWSECommerceService&AWSAccessKeyId="ACCESS_KEY"&Operation=ItemSearch&SearchIndex=Music&ResponseGroup="rg_markup"&Keywords=${artist}+${album}\0";
-        } else if(!strcmp(sets->lang, "jp")) {
+        else if (!strcmp (sets->lang,"jp") )
             lang_link = "http://co.jp.free.apisigning.com/onca/xml?Service=AWSECommerceService&AWSAccessKeyId="ACCESS_KEY"&Operation=ItemSearch&SearchIndex=Music&ResponseGroup="rg_markup"&Keywords=${artist}+${album}\0";
-        } else {
+        else
             lang_link = "http://free.apisigning.com/onca/xml?Service=AWSECommerceService&AWSAccessKeyId="ACCESS_KEY"&Operation=ItemSearch&SearchIndex=Music&ResponseGroup="rg_markup"&Keywords=${artist}+${album}\0";
-        }
     }
-    if(lang_link != NULL) {
-        return strreplace(lang_link, rg_markup, response_group);
+    if (lang_link != NULL)
+    {
+        return strreplace (lang_link,rg_markup,response_group);
     }
     return NULL;
 }
diff --git a/lib/intern/common/google.c b/lib/intern/common/google.c
index 38e6fd9..f99f08a 100644
--- a/lib/intern/common/google.c
+++ b/lib/intern/common/google.c
@@ -25,43 +25,55 @@
 /////////////////////////////////
 
 /* Methods used by more than one provider go here */
-const gchar *generic_google_url(GlyrQuery *sets, const gchar *searchterm)
+const gchar * generic_google_url (GlyrQuery * sets, const gchar * searchterm)
 {
-    const gchar *lang = NULL;
-    if(!g_ascii_strncasecmp(sets->lang, "us", 2)) {
+    const gchar * lang = NULL;
+    if (!g_ascii_strncasecmp (sets->lang,"us",2) )
         lang = "com"  ;
-    } else if(!g_ascii_strncasecmp(sets->lang, "ca", 2)) {
+    else if (!g_ascii_strncasecmp (sets->lang,"ca",2) )
         lang = "ca"   ;
-    } else if(!g_ascii_strncasecmp(sets->lang, "uk", 2)) {
+    else if (!g_ascii_strncasecmp (sets->lang,"uk",2) )
         lang = "co.uk";
-    } else if(!g_ascii_strncasecmp(sets->lang, "fr", 2)) {
+    else if (!g_ascii_strncasecmp (sets->lang,"fr",2) )
         lang = "fr"   ;
-    } else if(!g_ascii_strncasecmp(sets->lang, "de", 2)) {
+    else if (!g_ascii_strncasecmp (sets->lang,"de",2) )
         lang = "de"   ;
-    } else if(!g_ascii_strncasecmp(sets->lang, "jp", 2)) {
+    else if (!g_ascii_strncasecmp (sets->lang,"jp",2) )
         lang = "co.jp";
-    } else {
+    else
         lang = "com";
-    }
 
-    const gchar *back = NULL;
-    if(sets->img_min_size == -1) {
+    const gchar * back = NULL;
+    if (sets->img_min_size == -1)
+    {
         back = "";
-    } else if(sets->img_min_size < 75) {
+    }
+    else if (sets->img_min_size < 75)
+    {
         back = "&tbs=isz:i";
-    } else if(sets->img_min_size < 300) {
+    }
+    else if (sets->img_min_size < 300)
+    {
         back = "&tbs=isz:m";
-    } else if(sets->img_min_size < 450) {
-        back = "&tbs=isz:lt, slt:qsvga";
-    } else if(sets->img_min_size < 550) {
-        back = "&tbs=isz:lt, slt:vg/a";
-    } else if(sets->img_min_size < 700) {
-        back = "&tbs=isz:lt, slt:svga";
-    } else { /* High enough. */
-        back = "&tbs=isz:lt, slt:xga";
+    }
+    else if (sets->img_min_size < 450)
+    {
+        back = "&tbs=isz:lt,islt:qsvga";
+    }
+    else if (sets->img_min_size < 550)
+    {
+        back = "&tbs=isz:lt,islt:vg/a";
+    }
+    else if (sets->img_min_size < 700)
+    {
+        back = "&tbs=isz:lt,islt:svga";
+    }
+    else /* High enough. */
+    {
+        back = "&tbs=isz:lt,islt:xga";
     }
 
-    return g_strdup_printf("http://www.google.%s/images?q=%s&safe=off%s%s", lang, searchterm, (back != NULL) ? "" : "&", back);
+    return g_strdup_printf ("http://www.google.%s/images?q=%s&safe=off%s%s",lang,searchterm, (back!=NULL) ? "" : "&", back);
 }
 
 /////////////////////////////////
@@ -71,18 +83,20 @@ const gchar *generic_google_url(GlyrQuery *sets, const gchar *searchterm)
 #define HEIGHT_START  "&amp;h="
 #define MAX_NUM_BUF   16
 
-static gint google_get_size_value(gchar *ref, gchar *name)
+static gint google_get_size_value (gchar * ref, gchar * name)
 {
     gint number = 0;
-    gchar *start = g_strstr_len(ref, 256, name);
-    if(start != NULL) {
-        start += strlen(name);
-        gchar *end = strchr(start, ' ');
-        if(end != NULL) {
+    gchar * start = g_strstr_len (ref,256,name);
+    if (start != NULL)
+    {
+        start += strlen (name);
+        gchar * end = strchr (start,' ');
+        if (end != NULL)
+        {
             gchar numbuf[MAX_NUM_BUF] = {};
-            gsize span = MIN(end - start, MAX_NUM_BUF - 1);
-            strncpy(numbuf, start, span);
-            number = strtol(numbuf, NULL, 10);
+            gsize span = MIN (end - start,MAX_NUM_BUF-1);
+            strncpy (numbuf,start,span);
+            number = strtol (numbuf,NULL,10);
         }
     }
     return number;
@@ -90,16 +104,17 @@ static gint google_get_size_value(gchar *ref, gchar *name)
 
 /////////////////////////////////
 
-static gboolean google_check_image_size(GlyrQuery *s, gchar *ref)
+static gboolean google_check_image_size (GlyrQuery * s, gchar * ref)
 {
     gboolean result = FALSE;
-    gchar *img_src_after = strstr(ref, IMG_SRC_START);
-    if(img_src_after != NULL) {
-        gint width  = google_get_size_value(img_src_after, WIDTH_START);
-        gint height = google_get_size_value(img_src_after, HEIGHT_START);
-        gint ratio  = (width + height) / 2;
+    gchar * img_src_after = strstr (ref,IMG_SRC_START);
+    if (img_src_after != NULL)
+    {
+        gint width  = google_get_size_value (img_src_after,WIDTH_START);
+        gint height = google_get_size_value (img_src_after,HEIGHT_START);
+        gint ratio  = (width+height) /2;
 
-        result = size_is_okay(ratio, s->img_min_size, s->img_max_size);
+        result = size_is_okay (ratio,s->img_min_size,s->img_max_size);
     }
     return result;
 }
@@ -108,22 +123,26 @@ static gboolean google_check_image_size(GlyrQuery *s, gchar *ref)
 
 #define FIRST_RESULT "<a href=\"/imgres?imgurl="
 #define END_OF_URL "&amp;imgrefurl="
-GList *generic_google_parse(cb_object *capo)
+GList * generic_google_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *find = capo->cache->data;
+    GList * result_list = NULL;
+    gchar * find = capo->cache->data;
 
-    while(continue_search(g_list_length(result_list), capo->s) && (find =  strstr(find + 1, FIRST_RESULT)) != NULL) {
-        gchar *end_of_url = NULL;
-        find += strlen(FIRST_RESULT);
-        if((end_of_url = strstr(find, END_OF_URL)) != NULL) {
-            if(google_check_image_size(capo->s, find) == TRUE) {
-                gchar *url = copy_value(find, end_of_url);
-                if(url != NULL) {
-                    GlyrMemCache *result = DL_init();
+    while (continue_search (g_list_length (result_list),capo->s) && (find =  strstr (find+1,FIRST_RESULT) ) != NULL)
+    {
+        gchar * end_of_url = NULL;
+        find += strlen (FIRST_RESULT);
+        if ( (end_of_url = strstr (find, END_OF_URL) ) != NULL)
+        {
+            if (google_check_image_size (capo->s,find) == TRUE)
+            {
+                gchar * url = copy_value (find,end_of_url);
+                if (url != NULL)
+                {
+                    GlyrMemCache * result = DL_init();
                     result->data = url;
                     result->size = end_of_url - find;
-                    result_list = g_list_prepend(result_list, result);
+                    result_list = g_list_prepend (result_list,result);
                 }
             }
         }
diff --git a/lib/intern/common/mbid_lookup.c b/lib/intern/common/mbid_lookup.c
index 0502f5b..644d2fe 100644
--- a/lib/intern/common/mbid_lookup.c
+++ b/lib/intern/common/mbid_lookup.c
@@ -23,29 +23,31 @@
 
 //////////////////////////////////
 
-char *mbid_parse_data(GlyrMemCache *data, const char *lookup_entity, const char *find_entity, const char *compre_entity, GlyrQuery *qry)
+char * mbid_parse_data (GlyrMemCache * data, const char * lookup_entity, const char * find_entity, const char * compre_entity, GlyrQuery * qry)
 {
-    char *key = g_strdup_printf("<%s ", lookup_entity);
-    size_t keylen = strlen(key);
-    char *node = data->data;
-    char *result = NULL;
-
-    char *find_ent_start = g_strdup_printf("<%s>", find_entity);
-    char *find_ent_end   = g_strdup_printf("</%s>", find_entity);
-
-    while((node = strstr(node + keylen, key))) {
-        char *name = get_search_value(node, find_ent_start, find_ent_end);
-        if(name && levenshtein_strnormcmp(qry, name, compre_entity) <= qry->fuzzyness) {
-            result = get_search_value(node, "id=\"", "\"");
-            g_free(name);
+    char * key = g_strdup_printf ("<%s ", lookup_entity);
+    size_t keylen = strlen (key);
+    char * node = data->data;
+    char * result = NULL;
+
+    char * find_ent_start = g_strdup_printf ("<%s>", find_entity);
+    char * find_ent_end   = g_strdup_printf ("</%s>", find_entity);
+
+    while ( (node = strstr (node + keylen, key) ) )
+    {
+        char * name = get_search_value (node, find_ent_start, find_ent_end);
+        if (name && levenshtein_strnormcmp (qry, name, compre_entity) <= qry->fuzzyness)
+        {
+            result = get_search_value (node, "id=\"", "\"");
+            g_free (name);
             break;
         }
-        g_free(name);
+        g_free (name);
     }
 
-    g_free(find_ent_start);
-    g_free(find_ent_end);
-    g_free(key);
+    g_free (find_ent_start);
+    g_free (find_ent_end);
+    g_free (key);
     return result;
 }
 
@@ -56,18 +58,18 @@ char *mbid_parse_data(GlyrMemCache *data, const char *lookup_entity, const char
 
 //////////////////////////////////
 
-char *mbid_lookup(const char *query, GLYR_DATA_TYPE type, GlyrQuery *qry)
+char * mbid_lookup (const char * query, GLYR_DATA_TYPE type, GlyrQuery * qry)
 {
-    char *result_mbid = NULL;
-    if(query == NULL) {
+    char * result_mbid = NULL;
+    if (query == NULL)
         return result_mbid;
-    }
 
-    const char *lookup_entity = "";
-    const char *compre_entity = qry->artist;
-    const char *find_entity = "name";
+    const char * lookup_entity = "";
+    const char * compre_entity = qry->artist;
+    const char * find_entity = "name";
 
-    switch(type) {
+    switch (type)
+    {
     case GLYR_TYPE_TAG_ARTIST:
         lookup_entity = "artist";
         compre_entity = qry->artist;
@@ -88,14 +90,15 @@ char *mbid_lookup(const char *query, GLYR_DATA_TYPE type, GlyrQuery *qry)
         break;
     }
 
-    char *lookup_url = g_strdup_printf(LOOKUP_QUERY, lookup_entity, lookup_entity, query);
-    GlyrMemCache *parseable_data = download_single(lookup_url, qry, NULL);
-    if(parseable_data != NULL) {
-        result_mbid = mbid_parse_data(parseable_data, lookup_entity, find_entity, compre_entity, qry);
-        DL_free(parseable_data);
+    char * lookup_url = g_strdup_printf (LOOKUP_QUERY, lookup_entity, lookup_entity, query);
+    GlyrMemCache * parseable_data = download_single (lookup_url, qry, NULL);
+    if (parseable_data != NULL)
+    {
+        result_mbid = mbid_parse_data (parseable_data, lookup_entity, find_entity, compre_entity, qry);
+        DL_free (parseable_data);
     }
 
-    g_free(lookup_url);
+    g_free (lookup_url);
     return result_mbid;
 }
 
diff --git a/lib/intern/common/musicbrainz.c b/lib/intern/common/musicbrainz.c
index a219ab7..439329c 100644
--- a/lib/intern/common/musicbrainz.c
+++ b/lib/intern/common/musicbrainz.c
@@ -25,43 +25,43 @@
 /////////////////////////////////
 
 /* 'please' is important. gcc won't compile without. */
-gint please_what_type(GlyrQuery *s)
+gint please_what_type (GlyrQuery * s)
 {
     int result = -1;
-    if(s->artist && !s->album && !s->title) {
+    if (s->artist && !s->album && !s->title)
         result = GLYR_TYPE_TAG_ARTIST;
-    } else if(!s->artist && !s->album && s->title) {
+    else if (!s->artist && !s->album && s->title)
         result = GLYR_TYPE_TAG_TITLE;
-    } else if(!s->artist && s->album && !s->title) {
+    else if (!s->artist && s->album && !s->title)
         result = GLYR_TYPE_TAG_ALBUM;
-    } else if(s->artist && s->album && s->title) {
+    else if (s->artist && s->album && s->title)
         result = GLYR_TYPE_TAG_TITLE;
-    } else if(s->artist && !s->album && s->title) {
+    else if (s->artist && !s->album && s->title)
         result = GLYR_TYPE_TAG_TITLE;
-    } else if(s->artist && s->album && !s->title) {
+    else if (s->artist && s->album && !s->title)
         result = GLYR_TYPE_TAG_ALBUM;
-    } else {
+    else
         result = -1;
-    }
 
     return result;
 }
 
 /////////////////////////////////
 
-const gchar *generic_musicbrainz_url(GlyrQuery *sets)
+const gchar * generic_musicbrainz_url (GlyrQuery * sets)
 {
-    const gchar *wrap_a = sets->artist ? "${artist}" : "";
-    const gchar *wrap_b = sets->album  ? "${album}"  : "";
-    const gchar *wrap_t = sets->title  ? "${title}"  : "";
+    const gchar * wrap_a = sets->artist ? "${artist}" : "";
+    const gchar * wrap_b = sets->album  ? "${album}"  : "";
+    const gchar * wrap_t = sets->title  ? "${title}"  : "";
 
-    switch(please_what_type(sets)) {
+    switch (please_what_type (sets) )
+    {
     case GLYR_TYPE_TAG_TITLE :
-        return g_strdup_printf("http://musicbrainz.org/ws/1/track/?type=xml&title=%s&artist=%s&release=%s", wrap_t, wrap_a, wrap_b);
+        return g_strdup_printf ("http://musicbrainz.org/ws/1/track/?type=xml&title=%s&artist=%s&release=%s",wrap_t,wrap_a,wrap_b);
     case GLYR_TYPE_TAG_ALBUM :
-        return g_strdup_printf("http://musicbrainz.org/ws/1/release/?type=xml&title=%s&artist=%s", wrap_b, wrap_a);
+        return g_strdup_printf ("http://musicbrainz.org/ws/1/release/?type=xml&title=%s&artist=%s",wrap_b,wrap_a);
     case GLYR_TYPE_TAG_ARTIST:
-        return g_strdup_printf("http://musicbrainz.org/ws/1/artist/?type=xml&name=%s", wrap_a);
+        return g_strdup_printf ("http://musicbrainz.org/ws/1/artist/?type=xml&name=%s",wrap_a);
     default:
         return NULL;
     }
@@ -70,17 +70,17 @@ const gchar *generic_musicbrainz_url(GlyrQuery *sets)
 /////////////////////////////////
 
 #define ID_BEGIN "id=\""
-const gchar *get_mbid_from_xml(GlyrQuery *s, GlyrMemCache *c, gint *offset)
+const gchar * get_mbid_from_xml (GlyrQuery * s, GlyrMemCache * c, gint * offset)
 {
-    if(c == NULL || s == NULL || offset == NULL) {
+    if (c==NULL || s==NULL || offset==NULL)
         return NULL;
-    }
 
-    const gchar *searchterm  = NULL;
-    const gchar *checkstring = NULL;
-    const gchar *comparestr  = NULL;
+    const gchar * searchterm  = NULL;
+    const gchar * checkstring = NULL;
+    const gchar * comparestr  = NULL;
 
-    switch(please_what_type(s)) {
+    switch (please_what_type (s) )
+    {
     case GLYR_TYPE_TAG_TITLE:
         checkstring = "<title>";
         searchterm  = "<track ";
@@ -97,32 +97,34 @@ const gchar *get_mbid_from_xml(GlyrQuery *s, GlyrMemCache *c, gint *offset)
         comparestr  = s->artist;
         break;
     default:
-        glyr_message(1, s, "Warning: (tags/musicbrainz.c) Unable to determine type.\n");
+        glyr_message (1,s,"Warning: (tags/musicbrainz.c) Unable to determine type.\n");
     }
 
-    const gchar *mbid = NULL;
-    if(searchterm != NULL) {
-        gchar *node = c->data + *offset;
-        gchar *search_check = NULL;
+    const gchar * mbid = NULL;
+    if (searchterm != NULL)
+    {
+        gchar * node = c->data + *offset;
+        gchar * search_check = NULL;
         gsize nlen = (sizeof ID_BEGIN) - 1;
-        gsize clen = strlen(checkstring);
+        gsize clen = strlen (checkstring);
 
-        while(node && (node = strstr(node, searchterm)) && mbid == NULL) {
-            if(!(node = strstr(node, ID_BEGIN))) {
+        while (node && (node = strstr (node,searchterm) ) && mbid == NULL)
+        {
+            if (! (node = strstr (node,ID_BEGIN) ) )
                 break;
-            }
 
-            if(!(search_check = strstr(node, checkstring))) {
+            if (! (search_check = strstr (node,checkstring) ) )
                 break;
-            }
 
             search_check += clen;
-            gchar *to_compare = copy_value(search_check, strstr(search_check, "</"));
-            if(to_compare != NULL) {
-                if(levenshtein_strnormcmp(s, to_compare, comparestr) <= s->fuzzyness) {
-                    mbid = (gchar *) copy_value(node + nlen, strchr(node + nlen, '"'));
+            gchar * to_compare = copy_value (search_check,strstr (search_check,"</") );
+            if (to_compare != NULL)
+            {
+                if (levenshtein_strnormcmp (s,to_compare,comparestr) <= s->fuzzyness)
+                {
+                    mbid = (gchar*) copy_value (node+nlen,strchr (node+nlen,'"') );
                 }
-                g_free(to_compare);
+                g_free (to_compare);
             }
             node += (sizeof ID_BEGIN) - 1;
         }
@@ -134,16 +136,19 @@ const gchar *get_mbid_from_xml(GlyrQuery *s, GlyrMemCache *c, gint *offset)
 /////////////////////////////////
 
 /* Returns only a parseable memcache */
-GlyrMemCache *generic_musicbrainz_parse(cb_object *capo, gint *last_mbid, const gchar *include)
+GlyrMemCache * generic_musicbrainz_parse (cb_object * capo, gint * last_mbid, const gchar * include)
 {
     gsize offset = 0;
-    const gchar *mbid = NULL;
-    GlyrMemCache *info = NULL;
-
-    while(offset < capo->cache->size && info == NULL && (mbid = get_mbid_from_xml(capo->s, capo->cache, last_mbid))) {
-        if(mbid != NULL) {
-            const gchar *type = NULL;
-            switch(please_what_type(capo->s)) {
+    const gchar * mbid = NULL;
+    GlyrMemCache * info = NULL;
+
+    while (offset < capo->cache->size && info==NULL && (mbid = get_mbid_from_xml (capo->s,capo->cache,last_mbid) ) )
+    {
+        if (mbid != NULL)
+        {
+            const gchar * type = NULL;
+            switch (please_what_type (capo->s) )
+            {
             case GLYR_TYPE_TAG_TITLE:
                 type = "track";
                 break;
@@ -155,12 +160,13 @@ GlyrMemCache *generic_musicbrainz_parse(cb_object *capo, gint *last_mbid, const
                 break;
             }
 
-            gchar *info_page_url = g_strdup_printf("http://musicbrainz.org/ws/1/%s/%s?type=xml&inc=%s", type, mbid, include);
-            if(info_page_url) {
-                info = download_single(info_page_url, capo->s, NULL);
-                g_free(info_page_url);
+            gchar * info_page_url = g_strdup_printf ("http://musicbrainz.org/ws/1/%s/%s?type=xml&inc=%s",type,mbid,include);
+            if (info_page_url)
+            {
+                info = download_single (info_page_url,capo->s,NULL);
+                g_free (info_page_url);
             }
-            g_free((gchar *) mbid);
+            g_free ( (gchar*) mbid);
         }
     }
     return info;
diff --git a/lib/intern/common/picsearch.c b/lib/intern/common/picsearch.c
index 6947419..4e9713a 100644
--- a/lib/intern/common/picsearch.c
+++ b/lib/intern/common/picsearch.c
@@ -21,22 +21,24 @@
 #include "../../stringlib.h"
 #include "picsearch.h"
 
-const gchar *generic_picsearch_url(GlyrQuery *s, const char *fmt)
+const gchar * generic_picsearch_url (GlyrQuery * s, const char * fmt)
 {
     /* picsearch offers a nice way to set img_min / img_max */
-    gchar *base_url = "http://www.picsearch.com/index.cgi?q=%s&face=both&orientation=square&size=%dt%d";
+    gchar * base_url = "http://www.picsearch.com/index.cgi?q=%s&face=both&orientation=square&size=%dt%d";
 
     gint img_min_size = s->img_min_size;
-    if(img_min_size == -1) {
+    if (img_min_size == -1)
+    {
         img_min_size = 0;
     }
 
     gint img_max_size = s->img_max_size;
-    if(img_max_size == -1) {
+    if (img_max_size == -1)
+    {
         img_max_size = INT_MAX;
     }
 
-    return g_strdup_printf(base_url, fmt, img_min_size, img_max_size);
+    return g_strdup_printf (base_url, fmt, img_min_size, img_max_size);
 }
 
 /////////////////////////////////
@@ -45,18 +47,21 @@ const gchar *generic_picsearch_url(GlyrQuery *s, const char *fmt)
 #define IMG_HOOK_BEGIN "<a rel=\"nofollow\" href=\""
 #define IMG_HOOK_ENDIN "\"><img src=\""
 
-static GlyrMemCache *parse_details_page(GlyrMemCache *to_parse)
+static GlyrMemCache * parse_details_page (GlyrMemCache * to_parse)
 {
-    GlyrMemCache *result = NULL;
-    if(to_parse != NULL) {
-        char *start = strstr(to_parse->data, IMG_HOOK);
-        if(start != NULL) {
-            char *img_url = get_search_value(start, IMG_HOOK_BEGIN, IMG_HOOK_ENDIN);
-            if(img_url != NULL) {
+    GlyrMemCache * result = NULL;
+    if (to_parse != NULL)
+    {
+        char * start = strstr (to_parse->data,IMG_HOOK);
+        if (start != NULL)
+        {
+            char * img_url = get_search_value (start,IMG_HOOK_BEGIN,IMG_HOOK_ENDIN);
+            if (img_url != NULL)
+            {
                 result = DL_init();
                 result->data = img_url;
-                result->size = strlen(img_url);
-                result->dsrc = g_strdup(to_parse->dsrc);
+                result->size = strlen (img_url);
+                result->dsrc = g_strdup (to_parse->dsrc);
             }
         }
     }
@@ -68,38 +73,43 @@ static GlyrMemCache *parse_details_page(GlyrMemCache *to_parse)
 #define NODE "<div class=\"imgContainer\">"
 #define NODE_NEEDS_TO_BEGIN "/imageDetail.cgi"
 
-GList *generic_picsearch_parse(cb_object *capo)
+GList * generic_picsearch_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
+    GList * result_list = NULL;
 
-    gchar *node = capo->cache->data;
+    gchar * node = capo->cache->data;
     gint nodelen = (sizeof NODE) - 1;
 
-    node = strstr(node, "<div id=\"results_table\">");
+    node = strstr (node,"<div id=\"results_table\">");
 
     int items = 0, tries = 0;
     const int MAX_TRIES = capo->s->number * 4;
 
-    while(continue_search(items, capo->s)         &&
-            (node = strstr(node, "<a href=\""))  &&
-            tries++ < MAX_TRIES) {
+    while (continue_search (items,capo->s)         &&
+            (node = strstr (node, "<a href=\"") )  &&
+            tries++ < MAX_TRIES)
+    {
         node += nodelen;
-        gchar *details_url = get_search_value(node, "<a href=\"", "\" ");
-        if(details_url != NULL && strncmp(details_url, NODE_NEEDS_TO_BEGIN, sizeof(NODE_NEEDS_TO_BEGIN) - 1) == 0) {
-            gchar *full_url = g_strdup_printf("www.picsearch.com%s", details_url);
-            if(full_url != NULL) {
-                GlyrMemCache *to_parse = download_single(full_url, capo->s, NULL);
-                if(to_parse != NULL) {
-                    GlyrMemCache *result = parse_details_page(to_parse);
-                    if(result != NULL) {
-                        result_list = g_list_prepend(result_list, result);
+        gchar * details_url = get_search_value (node,"<a href=\"","\" ");
+        if (details_url != NULL && strncmp (details_url,NODE_NEEDS_TO_BEGIN,sizeof (NODE_NEEDS_TO_BEGIN)-1) == 0)
+        {
+            gchar * full_url = g_strdup_printf ("www.picsearch.com%s",details_url);
+            if (full_url != NULL)
+            {
+                GlyrMemCache * to_parse = download_single (full_url,capo->s,NULL);
+                if (to_parse != NULL)
+                {
+                    GlyrMemCache * result = parse_details_page (to_parse);
+                    if (result != NULL)
+                    {
+                        result_list = g_list_prepend (result_list,result);
                         items++;
                     }
-                    DL_free(to_parse);
+                    DL_free (to_parse);
                 }
-                g_free(full_url);
+                g_free (full_url);
             }
-            g_free(details_url);
+            g_free (details_url);
         }
     }
     return result_list;
diff --git a/lib/intern/cover.c b/lib/intern/cover.c
index 48acdee..e76693e 100644
--- a/lib/intern/cover.c
+++ b/lib/intern/cover.c
@@ -24,15 +24,16 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
-    return generic_img_finalizer(s, list, stop_me, GLYR_TYPE_COVERART, result_list);
+    return generic_img_finalizer (s,list,stop_me,GLYR_TYPE_COVERART,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_cover = {
+MetaDataFetcher glyrFetcher_cover =
+{
     .name = "cover",
     .type = GLYR_GET_COVERART,
     .default_data_type = GLYR_TYPE_COVERART,
diff --git a/lib/intern/cover/albumart.c b/lib/intern/cover/albumart.c
index 4979cb0..168d856 100644
--- a/lib/intern/cover/albumart.c
+++ b/lib/intern/cover/albumart.c
@@ -21,12 +21,13 @@
 #include "../../core.h"
 #include "../../stringlib.h"
 
-static const gchar *cover_albumart_url(GlyrQuery *sets)
+static const gchar * cover_albumart_url (GlyrQuery * sets)
 {
     gint i = sets->img_min_size;
     gint e = sets->img_max_size;
 
-    if((e >= 50 || e == -1) && (i == -1 || i < 450)) {
+    if ( (e >= 50 || e == -1) && (i == -1 || i < 450) )
+    {
         return "http://www.albumart.org/index.php?searchkey=${artist}&itempage=1&newsearch=1&searchindex=Music";
     }
     return NULL;
@@ -39,42 +40,50 @@ static const gchar *cover_albumart_url(GlyrQuery *sets)
 #define AMZ "http://ecx.images-amazon.com/images/"
 #define IMG_FORMAT ".jpg"
 
-static GList *cover_albumart_parse(cb_object *capo)
+static GList * cover_albumart_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *node = strstr(capo->cache->data, NODE_START);
-    if(node != NULL) {
+    GList * result_list = NULL;
+    gchar * node = strstr (capo->cache->data,NODE_START);
+    if (node != NULL)
+    {
         /* Decide what size we want */
         gsize size_it = 2;
-        if(capo->s->img_max_size < 450 && capo->s->img_max_size != -1 && capo->s->img_min_size < 160) {
+        if (capo->s->img_max_size < 450 && capo->s->img_max_size != -1 && capo->s->img_min_size < 160)
+        {
             size_it = 1;
         }
 
         /* Go through all nodes */
-        while(continue_search(g_list_length(result_list), capo->s) && (node = strstr(node + (sizeof NODE_NEXT) - 1, NODE_NEXT))) {
-            gchar *img_tag = node;
-            gchar *img_end = NULL;
+        while (continue_search (g_list_length (result_list),capo->s) && (node = strstr (node + (sizeof NODE_NEXT) - 1,NODE_NEXT) ) )
+        {
+            gchar * img_tag = node;
+            gchar * img_end = NULL;
 
-            gchar *album_name = get_search_value(node, "title=\"", "\"");
-            if(levenshtein_strnormcmp(capo->s, album_name, capo->s->album) <= capo->s->fuzzyness) {
-                for(gsize it = 0; it < size_it; it++, img_tag += (sizeof AMZ) - 1) {
-                    if((img_tag = strstr(img_tag, AMZ)) == NULL) {
+            gchar * album_name = get_search_value (node,"title=\"","\"");
+            if (levenshtein_strnormcmp (capo->s,album_name,capo->s->album) <= capo->s->fuzzyness)
+            {
+                for (gsize it = 0; it < size_it; it++, img_tag += (sizeof AMZ) - 1)
+                {
+                    if ( (img_tag = strstr (img_tag,AMZ) ) == NULL)
+                    {
                         break;
                     }
                 }
 
-                if((img_end  = strstr(img_tag, IMG_FORMAT)) != NULL) {
-                    gchar *img_url = copy_value(img_tag, img_end);
-                    if(img_url != NULL) {
-                        GlyrMemCache *result = DL_init();
-                        result->data = g_strdup_printf(AMZ"%s"IMG_FORMAT, img_url);
-                        result->size = strlen(result->data);
-                        result_list = g_list_prepend(result_list, result);
-                        g_free(img_url);
+                if ( (img_end  = strstr (img_tag,IMG_FORMAT) ) != NULL)
+                {
+                    gchar * img_url = copy_value (img_tag,img_end);
+                    if (img_url != NULL)
+                    {
+                        GlyrMemCache * result = DL_init();
+                        result->data = g_strdup_printf (AMZ"%s"IMG_FORMAT, img_url);
+                        result->size = strlen (result->data);
+                        result_list = g_list_prepend (result_list,result);
+                        g_free (img_url);
                     }
                 }
             }
-            g_free(album_name);
+            g_free (album_name);
         }
     }
     return result_list;
@@ -82,7 +91,8 @@ static GList *cover_albumart_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource cover_albumart_src = {
+MetaDataSource cover_albumart_src =
+{
     .name      = "albumart",
     .key       = 'b',
     .parser    = cover_albumart_parse,
diff --git a/lib/intern/cover/amazon.c b/lib/intern/cover/amazon.c
index be55aac..204d56f 100644
--- a/lib/intern/cover/amazon.c
+++ b/lib/intern/cover/amazon.c
@@ -59,9 +59,9 @@ http://ecx.images-amazon.com/images/I/51rnlRwtsiL.jpg
 // as an fallback there is the albumart and coverhunt plugin which implement a search on amazon (on serverside)
 /////////////////////////////////
 
-static const gchar *cover_amazon_url(GlyrQuery *sets)
+static const gchar * cover_amazon_url (GlyrQuery * sets)
 {
-    return generic_amazon_url(sets, "Images");
+    return generic_amazon_url (sets,"Images");
 }
 
 /////////////////////////////////
@@ -70,29 +70,32 @@ static const gchar *cover_amazon_url(GlyrQuery *sets)
 #define C_MAX(X) (capo->s->img_max_size <  X && capo->s->img_max_size != -1)
 #define C_MIN(X) (capo->s->img_min_size >= X && capo->s->img_min_size != -1)
 
-static GList *cover_amazon_parse(cb_object *capo)
+static GList * cover_amazon_parse (cb_object *capo)
 {
     const gchar *tag_ssize = (capo->s->img_max_size == -1 && capo->s->img_min_size == -1) ? "<LargeImage>"  :
-                             (C_MAX(30) && C_MIN(-1)) ? "<SwatchImage>" :
-                             (C_MAX(70) && C_MIN(30)) ? "<SmallImage>"  :
-                             (C_MAX(150) && C_MIN(70)) ? "<MediumImage>" :
+                             (C_MAX ( 30) && C_MIN (-1) ) ? "<SwatchImage>" :
+                             (C_MAX ( 70) && C_MIN (30) ) ? "<SmallImage>"  :
+                             (C_MAX (150) && C_MIN (70) ) ? "<MediumImage>" :
                              "<LargeImage>"  ;
 
-    GList *result_list = NULL;
-    gchar *find = capo->cache->data;
-    while(continue_search(g_list_length(result_list), capo->s) && (find = strstr(find + strlen(tag_ssize), tag_ssize)) != NULL) {
+    GList * result_list = NULL;
+    gchar * find = capo->cache->data;
+    while (continue_search (g_list_length (result_list),capo->s) && (find = strstr (find + strlen (tag_ssize), tag_ssize) ) != NULL)
+    {
         /* Next two XML tags not relevant */
-        nextTag(find);
-        nextTag(find);
+        nextTag (find);
+        nextTag (find);
 
-        gchar *endTag = NULL;
-        if((endTag = strstr(find, END_OF_URL)) != NULL) {
-            gchar *result_url = copy_value(find, endTag);
-            if(result_url != NULL) {
-                GlyrMemCache *result = DL_init();
+        gchar * endTag = NULL;
+        if ( (endTag = strstr (find, END_OF_URL) ) != NULL)
+        {
+            gchar * result_url = copy_value (find,endTag);
+            if (result_url != NULL)
+            {
+                GlyrMemCache * result = DL_init();
                 result->data = result_url;
                 result->size = endTag - find;
-                result_list = g_list_prepend(result_list, result);
+                result_list = g_list_prepend (result_list,result);
             }
         }
     }
@@ -101,7 +104,8 @@ static GList *cover_amazon_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource cover_amazon_src = {
+MetaDataSource cover_amazon_src =
+{
     .name      = "amazon",
     .key       = 'a',
     .parser    = cover_amazon_parse,
diff --git a/lib/intern/cover/coverartarchive.c b/lib/intern/cover/coverartarchive.c
index c91c07b..a24626a 100644
--- a/lib/intern/cover/coverartarchive.c
+++ b/lib/intern/cover/coverartarchive.c
@@ -25,7 +25,7 @@
 
 //////////////////////////////////////////////////
 
-static const char *cover_coverartarchive_url(GlyrQuery *qry)
+static const char * cover_coverartarchive_url (GlyrQuery * qry)
 {
     /* Return a search for the mbid, later we'll search for the cover */
     return "http://musicbrainz.org/ws/2/release?query=artist:${artist}%20AND%20release:${album}";
@@ -36,20 +36,22 @@ static const char *cover_coverartarchive_url(GlyrQuery *qry)
 #define IMAGE_NODE "\"image\":\""
 
 /* This should work, but apparently there is no real data yet there... */
-static GList *parse_archive_json(GlyrMemCache *input, GlyrQuery *qry)
+static GList * parse_archive_json (GlyrMemCache * input, GlyrQuery * qry)
 {
-    GList *result_list = NULL;
-    char *node = input->data;
-
-    while((node = strstr(node + sizeof(IMAGE_NODE), IMAGE_NODE))) {
-        char *url = copy_value(node, strstr(node + sizeof(IMAGE_NODE), "\""));
-        if(url != NULL) {
-            GlyrMemCache *item = DL_init();
+    GList * result_list = NULL;
+    char * node = input->data;
+
+    while ( (node = strstr (node + sizeof (IMAGE_NODE), IMAGE_NODE) ) )
+    {
+        char * url = copy_value (node, strstr (node + sizeof (IMAGE_NODE), "\"") );
+        if (url != NULL)
+        {
+            GlyrMemCache * item = DL_init();
             item->data = url;
-            item->size = strlen(url);
-            item->dsrc = g_strdup(input->dsrc);
+            item->size = strlen (url);
+            item->dsrc = g_strdup (input->dsrc);
 
-            result_list = g_list_prepend(result_list, item);
+            result_list = g_list_prepend (result_list, item);
         }
     }
     return result_list;
@@ -62,19 +64,22 @@ static GList *parse_archive_json(GlyrMemCache *input, GlyrQuery *qry)
 
 //////////////////////////////////////////////////
 
-static GList *cover_coverartarchive_parse(cb_object *capo)
+static GList * cover_coverartarchive_parse (cb_object * capo)
 {
     GList *result_list = NULL;
-    char *mbid = mbid_parse_data(capo->cache, "release", "title", capo->s->album, capo->s);
-    if(mbid != NULL) {
-        char *full_url = g_strdup_printf(API_ROOT, mbid);
-        if(full_url != NULL) {
-            GlyrMemCache *json_data = download_single(full_url, capo->s, NULL);
-            if(json_data != NULL) {
-                result_list = parse_archive_json(json_data, capo->s);
-                DL_free(json_data);
+    char * mbid = mbid_parse_data (capo->cache, "release", "title", capo->s->album, capo->s);
+    if (mbid != NULL)
+    {
+        char * full_url = g_strdup_printf (API_ROOT, mbid);
+        if (full_url != NULL)
+        {
+            GlyrMemCache * json_data = download_single (full_url, capo->s, NULL);
+            if (json_data != NULL)
+            {
+                result_list = parse_archive_json (json_data, capo->s);
+                DL_free (json_data);
             }
-            g_free(full_url);
+            g_free (full_url);
         }
     }
     return result_list;
@@ -82,7 +87,8 @@ static GList *cover_coverartarchive_parse(cb_object *capo)
 
 //////////////////////////////////////////////////
 
-MetaDataSource cover_coverartarchive_src = {
+MetaDataSource cover_coverartarchive_src =
+{
     .name      = "coverartarchive",
     .key       = 'z',
     .parser    = cover_coverartarchive_parse,
diff --git a/lib/intern/cover/coverhunt.c b/lib/intern/cover/coverhunt.c
index 0a90a8b..ff80932 100644
--- a/lib/intern/cover/coverhunt.c
+++ b/lib/intern/cover/coverhunt.c
@@ -25,28 +25,30 @@
  * Coverhunt seems to have some load problems at time of writing...
  */
 
-static const gchar *cover_coverhunt_url(GlyrQuery *sets)
+static const gchar * cover_coverhunt_url (GlyrQuery * sets)
 {
-    if(sets->img_min_size <= 500 || sets->img_min_size == -1) {
+    if (sets->img_min_size <= 500 || sets->img_min_size == -1)
+    {
         return "http://www.coverhunt.com/index.php?query=${artist}+${album}&action=Find+my+CD+Covers";
     }
     return NULL;
 }
 
-static gboolean check_size(const char *art_root, const char *hw, cb_object *capo)
+static gboolean check_size (const char * art_root, const char *hw, cb_object * capo)
 {
-    gchar *begin = strstr(art_root, hw);
-    if(begin != NULL) {
-        gchar *end = strchr(begin, ' ');
-        gchar *buf = copy_value(begin + strlen(hw), end);
-        if(buf != NULL) {
-            gint atoid = strtol(buf, NULL, 10);
-            g_free(buf);
+    gchar * begin = strstr (art_root,hw);
+    if (begin != NULL)
+    {
+        gchar * end = strchr (begin,' ');
+        gchar * buf = copy_value (begin+strlen (hw),end);
+        if (buf != NULL)
+        {
+            gint atoid = strtol (buf,NULL,10);
+            g_free (buf);
 
-            if((atoid >= capo->s->img_min_size || capo->s->img_min_size == -1) &&
-                    (atoid <= capo->s->img_max_size || capo->s->img_max_size == -1)) {
+            if ( (atoid >= capo->s->img_min_size || capo->s->img_min_size == -1) &&
+                    (atoid <= capo->s->img_max_size || capo->s->img_max_size == -1)  )
                 return TRUE;
-            }
         }
     }
     return FALSE;
@@ -60,51 +62,62 @@ static gboolean check_size(const char *art_root, const char *hw, cb_object *capo
  * coverhunt sadly offers  no way to check if the
  * image is really related to the query we're searching for
  */
-static GList *cover_coverhunt_parse(cb_object *capo)
+static GList * cover_coverhunt_parse (cb_object *capo)
 {
-    GList *result_list = NULL;
+    GList * result_list = NULL;
 
     /* navigate to start of search results */
-    gchar *table_start;
-    if((table_start = strstr(capo->cache->data, SEARCH_RESULT_BEGIN)) == NULL) {
+    gchar * table_start;
+    if ( (table_start = strstr (capo->cache->data,SEARCH_RESULT_BEGIN) ) == NULL)
+    {
         /* Whoops, nothing to see here */
         return NULL;
     }
 
-    while(continue_search(g_list_length(result_list), capo->s) && (table_start = strstr(table_start + 1, NODE_BEGIN))) {
-        gchar *table_end = NULL;
-        if((table_end = strstr(table_start, "\">")) != NULL) {
-            gchar *go_url = copy_value(table_start + strlen(NODE_BEGIN), table_end);
-            if(go_url) {
-                gchar *real_url = g_strdup_printf("http://www.coverhunt.com/go/%s", go_url);
-                if(real_url != NULL) {
-                    GlyrMemCache *search_buf = download_single(real_url, capo->s, "<div id=\"right\">");
-                    if(search_buf != NULL) {
-                        gchar *artwork = strstr(search_buf->data, "<div class=\"artwork\">");
-                        if(artwork != NULL) {
-                            if(check_size(artwork, "height=", capo) && check_size(artwork, "width=", capo)) {
-                                gchar *img_start = strstr(artwork, IMG_START);
-                                if(img_start != NULL) {
+    while (continue_search (g_list_length (result_list),capo->s) && (table_start = strstr (table_start + 1,NODE_BEGIN) ) )
+    {
+        gchar * table_end = NULL;
+        if ( (table_end = strstr (table_start,"\">") ) != NULL)
+        {
+            gchar * go_url = copy_value (table_start + strlen (NODE_BEGIN),table_end);
+            if (go_url)
+            {
+                gchar * real_url = g_strdup_printf ("http://www.coverhunt.com/go/%s",go_url);
+                if (real_url != NULL)
+                {
+                    GlyrMemCache * search_buf = download_single (real_url,capo->s,"<div id=\"right\">");
+                    if (search_buf != NULL)
+                    {
+                        gchar * artwork = strstr (search_buf->data, "<div class=\"artwork\">");
+                        if (artwork != NULL)
+                        {
+                            if (check_size (artwork,"height=",capo) && check_size (artwork,"width=",capo) )
+                            {
+                                gchar * img_start = strstr (artwork,IMG_START);
+                                if (img_start != NULL)
+                                {
                                     img_start += (sizeof IMG_START) - 1;
-                                    gchar *img_end = strstr(img_start, "\" ");
-                                    if(img_end != NULL) {
-                                        gchar *url = copy_value(img_start, img_end);
-                                        if(url != NULL) {
-                                            GlyrMemCache *shell = DL_init();
+                                    gchar * img_end = strstr (img_start,"\" ");
+                                    if (img_end != NULL)
+                                    {
+                                        gchar * url = copy_value (img_start,img_end);
+                                        if (url != NULL)
+                                        {
+                                            GlyrMemCache * shell = DL_init();
                                             shell->data = url;
                                             shell->size = img_end - img_start;
-                                            shell->dsrc = g_strdup(real_url);
-                                            result_list = g_list_prepend(result_list, shell);
+                                            shell->dsrc = g_strdup (real_url);
+                                            result_list = g_list_prepend (result_list,shell);
                                         }
                                     }
                                 }
                             }
                         }
-                        DL_free(search_buf);
+                        DL_free (search_buf);
                     }
-                    g_free(real_url);
+                    g_free (real_url);
                 }
-                g_free(go_url);
+                g_free (go_url);
             }
         }
     }
@@ -112,7 +125,8 @@ static GList *cover_coverhunt_parse(cb_object *capo)
 }
 
 /* Queued last, as long coverhunt is down */
-MetaDataSource cover_coverhunt_src = {
+MetaDataSource cover_coverhunt_src =
+{
     .name      = "coverhunt",
     .key       = 'c',
     .parser    = cover_coverhunt_parse,
diff --git a/lib/intern/cover/discogs.c b/lib/intern/cover/discogs.c
index dc95c53..4b03191 100644
--- a/lib/intern/cover/discogs.c
+++ b/lib/intern/cover/discogs.c
@@ -52,47 +52,51 @@
 #define THUMB_SUBDNOE "\"thumb\": \""
 #define FOLLR_SUBNODE "\"uri\": \""
 #define NODE THUMB_SUBDNOE
-#define ENDOF_SUBNODE "\", 
+#define ENDOF_SUBNODE "\","
 
 
 /////////////////////////////////////////////////////
 
-static bool check_artist_album(GlyrQuery *q, const char *artist_album)
+static bool check_artist_album (GlyrQuery * q, const char * artist_album)
 {
     bool rc = false;
 
-    char **split = g_strsplit(artist_album, " - ", 2);
-    if(split && split[0] && split[1]) {
-        rc = levenshtein_strnormcmp(q, q->artist, split[0]) <= q->fuzzyness &&
-             levenshtein_strnormcmp(q, q->album, split[1]) <= q->fuzzyness;
+    char ** split = g_strsplit (artist_album," - ",2);
+    if (split && split[0] && split[1])
+    {
+        rc = levenshtein_strnormcmp (q,q->artist,split[0]) <= q->fuzzyness &&
+             levenshtein_strnormcmp (q,q->album, split[1]) <= q->fuzzyness;
     }
 
-    g_strfreev(split);
+    g_strfreev (split);
     return rc;
 }
 
 /////////////////////////////////////////////////////
 
-static GlyrMemCache *transform_url(cb_object *s, const char *url)
+static GlyrMemCache * transform_url (cb_object * s, const char * url)
 {
-    GlyrMemCache *rc = NULL;
-    size_t rc_size = strlen(url);
-    char *rc_url  = g_strdup(url);
-
-    if(rc_url != NULL) {
-        char *slash = strrchr(rc_url, '/');
-        if(slash != NULL) {
-            char *sp = strchr(slash, '-');
-            if(sp != NULL) {
-                char *ep = strchr(sp + 1, '-');
+    GlyrMemCache * rc = NULL;
+    size_t rc_size = strlen (url);
+    char * rc_url  = g_strdup (url);
+
+    if (rc_url != NULL)
+    {
+        char * slash = strrchr (rc_url,'/');
+        if (slash != NULL)
+        {
+            char * sp = strchr (slash,'-');
+            if (sp != NULL)
+            {
+                char * ep = strchr (sp + 1, '-');
                 if(ep != NULL) {
                     size_t rest_len = rc_size - (ep - rc_url) + 1;
-                    memmove(sp, ep, rest_len);
+                    memmove (sp,ep,rest_len);
 
                     rc = DL_init();
-                    rc->data = (char *) rc_url;
-                    rc->size = strlen(url);
-                    rc->dsrc = g_strdup(s->url);
+                    rc->data = (char*) rc_url;
+                    rc->size = strlen (url);
+                    rc->dsrc = g_strdup (s->url);
                 }
             }
         }
@@ -104,38 +108,42 @@ static GlyrMemCache *transform_url(cb_object *s, const char *url)
 /////////////////////////////////////////////////////
 /////////////////////////////////////////////////////
 
-static const char *cover_discogs_url(GlyrQuery *q)
+static const char * cover_discogs_url (GlyrQuery * q)
 {
     return API_ENTRY;
 }
 
 /////////////////////////////////////////////////////
 
-static GList *cover_discogs_parse(cb_object *capo)
+static GList * cover_discogs_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
+    GList * result_list = NULL;
 
     /* Jump to the very first node 'directly' */
-    gchar *node = capo->cache->data;
+    gchar * node = capo->cache->data;
 
-    while(continue_search(g_list_length(result_list), capo->s)
-            && (node = strstr(node + (sizeof NODE) - 1, NODE)) != NULL) {
+    while (continue_search (g_list_length (result_list),capo->s)
+            && (node = strstr (node + (sizeof NODE) - 1,NODE) ) != NULL)
+    {
 
-        char *artist_album = get_search_value(node, TITLE_SUBNODE, ENDOF_SUBNODE);
+        char * artist_album = get_search_value (node,TITLE_SUBNODE,ENDOF_SUBNODE);
 
-        if(artist_album && check_artist_album(capo->s, artist_album)) {
+        if (artist_album && check_artist_album (capo->s,artist_album) )
+        {
 
-            char *thumb_url = get_search_value(node, THUMB_SUBDNOE, ENDOF_SUBNODE);
-            if(thumb_url) {
+            char * thumb_url = get_search_value (node,THUMB_SUBDNOE,ENDOF_SUBNODE);
+            if (thumb_url)
+            {
 
-                GlyrMemCache *p = transform_url(capo, thumb_url);
-                if(p != NULL) {
-                    result_list = g_list_prepend(result_list, p);
+                GlyrMemCache * p = transform_url (capo,thumb_url);
+                if (p != NULL)
+                {
+                    result_list = g_list_prepend (result_list,p);
                 }
-                g_free(thumb_url);
+                g_free (thumb_url);
             }
         }
-        g_free(artist_album);
+        g_free (artist_album);
     }
 
     return result_list;
@@ -143,7 +151,8 @@ static GList *cover_discogs_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource cover_discogs_src = {
+MetaDataSource cover_discogs_src =
+{
     .name      = "discogs",
     .key       = 'd',
     .parser    = cover_discogs_parse,
diff --git a/lib/intern/cover/google.c b/lib/intern/cover/google.c
index 9c68e83..ff39008 100644
--- a/lib/intern/cover/google.c
+++ b/lib/intern/cover/google.c
@@ -23,27 +23,29 @@
 
 /////////////////////////////////
 
-static const gchar *cover_google_url(GlyrQuery *s)
+static const gchar * cover_google_url (GlyrQuery * s)
 {
-    const gchar *result = NULL;
-    gchar *searchterm = g_strdup("${artist}+${album}+album");
-    if(searchterm != NULL) {
-        result = generic_google_url(s, searchterm);
-        g_free(searchterm);
+    const gchar * result = NULL;
+    gchar * searchterm = g_strdup ("${artist}+${album}+album");
+    if (searchterm != NULL)
+    {
+        result = generic_google_url (s,searchterm);
+        g_free (searchterm);
     }
     return result;
 }
 
 /////////////////////////////////
 
-static GList *cover_google_parse(cb_object *capo)
+static GList * cover_google_parse (cb_object * capo)
 {
-    return generic_google_parse(capo);
+    return generic_google_parse (capo);
 }
 
 /////////////////////////////////
 
-MetaDataSource cover_google_src = {
+MetaDataSource cover_google_src =
+{
     .name      = "google",
     .key       = 'g',
     .parser    = cover_google_parse,
diff --git a/lib/intern/cover/jamendo.c b/lib/intern/cover/jamendo.c
index 1969368..da4215f 100644
--- a/lib/intern/cover/jamendo.c
+++ b/lib/intern/cover/jamendo.c
@@ -27,26 +27,27 @@
 #define RESULT_URL "http://www.jamendo.com/get/album/id/album/artworkurl/redirect/%s/?artwork_size=%d"
 #define SOURCE_URL "http://api.jamendo.com/get2/id+name+artist_name/album/plain/?order=searchweight_desc&n=100&searchquery=${album}"
 
-static int get_cover_size(GlyrQuery *query);
-static bool check_values(GlyrQuery *query, char *artist, char *album);
+static int get_cover_size (GlyrQuery * query);
+static bool check_values (GlyrQuery * query, char * artist, char * album);
 
 /////////////////////////////////
 
-static const char *cover_jamendo_url(GlyrQuery *sets)
+static const char * cover_jamendo_url (GlyrQuery * sets)
 {
     return SOURCE_URL;
 }
 
 /////////////////////////////////
 
-void do_line_split(char **p_arr, char *line)
+void do_line_split (char ** p_arr, char * line)
 {
-    g_return_if_fail(p_arr && line);
+    g_return_if_fail (p_arr && line);
 
-    char *hop = line;
+    char * hop = line;
     *p_arr = line;
 
-    while((hop = strchr(hop, '\t')) != NULL) {
+    while ( (hop = strchr (hop,'\t') ) != NULL)
+    {
         p_arr++;
 
         *hop = 0;
@@ -56,32 +57,37 @@ void do_line_split(char **p_arr, char *line)
 
 /////////////////////////////////
 
-static GList *cover_jamendo_parse(cb_object *capo)
+static GList * cover_jamendo_parse (cb_object *capo)
 {
     // A nice parser with zero memory overhead..
 
-    GList *result_list = NULL;
-    gchar *line = capo->cache->data;
+    GList * result_list = NULL;
+    gchar * line = capo->cache->data;
 
-    while(continue_search(g_list_length(result_list), capo->s)) {
-        char *line_end;
+    while (continue_search (g_list_length (result_list),capo->s) )
+    {
+        char * line_end;
 
-        if((line_end = strchr(line, '\n')) != NULL) {
+        if ( (line_end = strchr (line,'\n') ) != NULL)
+        {
             *line_end = 0;
 
-            char *line_split[3] = {0, 0, 0};
-            do_line_split(line_split, line);
+            char * line_split[3] = {0,0,0};
+            do_line_split (line_split,line);
 
-            if(check_values(capo->s, line_split[2], line_split[1])) {
-                char *url =  g_strdup_printf(RESULT_URL, line_split[0], get_cover_size(capo->s));
-                GlyrMemCache *result = DL_init();
+            if (check_values (capo->s,line_split[2],line_split[1]) )
+            {
+                char * url =  g_strdup_printf (RESULT_URL,line_split[0],get_cover_size (capo->s) );
+                GlyrMemCache * result = DL_init();
                 result->data = url;
-                result->size = strlen(url);
-                result_list = g_list_prepend(result_list, result);
+                result->size = strlen (url);
+                result_list = g_list_prepend (result_list,result);
             }
 
             line = ++line_end;
-        } else {
+        }
+        else
+        {
             break;
         }
     }
@@ -90,10 +96,11 @@ static GList *cover_jamendo_parse(cb_object *capo)
 
 /////////////////////////////////
 
-static bool check_values(GlyrQuery *query, char *artist, char *album)
+static bool check_values (GlyrQuery * query, char * artist, char * album)
 {
-    if(levenshtein_strnormcmp(query, query->artist, artist) <= query->fuzzyness
-            && levenshtein_strnormcmp(query, query->album, album) <= query->fuzzyness) {
+    if (levenshtein_strnormcmp (query, query->artist, artist) <= query->fuzzyness
+            && levenshtein_strnormcmp (query, query->album,album) <= query->fuzzyness)
+    {
         return true;
     }
     return false;
@@ -101,17 +108,22 @@ static bool check_values(GlyrQuery *query, char *artist, char *album)
 
 /////////////////////////////////
 
-static int get_cover_size(GlyrQuery *query)
+static int get_cover_size (GlyrQuery * query)
 {
-    int cover_size[] = {50, 50, 100, 200, 300, 400, 600, INT_MAX};
-    int array_len = (sizeof(cover_size) / sizeof(int));
+    int cover_size[] = {50,50,100,200,300,400,600,INT_MAX};
+    int array_len = (sizeof (cover_size) /sizeof (int) );
 
-    if(query->img_max_size == -1) {
+    if (query->img_max_size == -1)
+    {
         return 400;
-    } else {
-        for(int i = 1; i < array_len; i++) {
-            if(query->img_max_size <= cover_size[i]) {
-                return cover_size[i - 1];
+    }
+    else
+    {
+        for (int i=1; i<array_len; i++)
+        {
+            if (query->img_max_size <= cover_size[i])
+            {
+                return cover_size[i-1];
             }
         }
     }
@@ -121,7 +133,8 @@ static int get_cover_size(GlyrQuery *query)
 
 /////////////////////////////////
 
-MetaDataSource cover_jamendo_src = {
+MetaDataSource cover_jamendo_src =
+{
     .name      = "jamendo",
     .key       = 'j',
     .parser    = cover_jamendo_parse,
diff --git a/lib/intern/cover/lastfm.c b/lib/intern/cover/lastfm.c
index 4ae417e..9272000 100644
--- a/lib/intern/cover/lastfm.c
+++ b/lib/intern/cover/lastfm.c
@@ -23,7 +23,7 @@
 
 /////////////////////////////////
 
-static const char *cover_lastfm_url(GlyrQuery *sets)
+static const char * cover_lastfm_url (GlyrQuery * sets)
 {
     return "http://ws.audioscrobbler.com/2.0/?method=album.search&autocorrect=1&album=${artist}+${album}&api_key="API_KEY_LASTFM;
 }
@@ -33,62 +33,68 @@ static const char *cover_lastfm_url(GlyrQuery *sets)
 #define ALBUM_NODE "<album>"
 #define BAD_DEFAULT_IMAGE "http://cdn.last.fm/flatness/catalogue/noimage/2/default_album_medium.png"
 
-static GList *cover_lastfm_parse(cb_object *capo)
+static GList * cover_lastfm_parse (cb_object *capo)
 {
     /* Handle size requirements (Default to large) */
-    const gchar *tag_ssize = NULL ;
-    const gchar *tag_esize = "</image>";
+    const gchar * tag_ssize = NULL ;
+    const gchar * tag_esize = "</image>";
 
     /* find desired size */
-    if(size_is_okay(300, capo->s->img_min_size, capo->s->img_max_size)) {
+    if ( size_is_okay (300,capo->s->img_min_size,capo->s->img_max_size) )
         tag_ssize = "<image size=\"extralarge\">";
-    } else if(size_is_okay(125, capo->s->img_min_size, capo->s->img_max_size)) {
+    else if ( size_is_okay (125,capo->s->img_min_size,capo->s->img_max_size) )
         tag_ssize = "<image size=\"large\">";
-    } else if(size_is_okay(64, capo->s->img_min_size, capo->s->img_max_size)) {
+    else if ( size_is_okay (64, capo->s->img_min_size,capo->s->img_max_size) )
         tag_ssize = "<image size=\"middle\">";
-    } else if(size_is_okay(34, capo->s->img_min_size, capo->s->img_max_size)) {
+    else if ( size_is_okay (34, capo->s->img_min_size,capo->s->img_max_size) )
         tag_ssize = "<image size=\"small\">";
-    } else if(true || false) {
+    else if ( true || false )
         tag_ssize = "<image size=\"extralarge\">";
-    }
 
     /* The result (perhaps) */
-    GList *result_list = NULL;
-    gchar *find  = capo->cache->data;
+    GList * result_list = NULL;
+    gchar * find  = capo->cache->data;
 
-    while(continue_search(g_list_length(result_list), capo->s) && (find = strstr(find + sizeof(ALBUM_NODE), ALBUM_NODE)) != NULL) {
-        gchar *artist = get_search_value(find, "<artist>", "</artist>");
-        gchar *album  = get_search_value(find, "<name>", "</name>");
+    while (continue_search (g_list_length (result_list),capo->s) && (find = strstr (find + sizeof(ALBUM_NODE), ALBUM_NODE) ) != NULL)
+    {
+        gchar * artist = get_search_value (find, "<artist>", "</artist>");
+        gchar * album  = get_search_value (find, "<name>", "</name>");
 
-        if(levenshtein_strnormcmp(capo->s, artist, capo->s->artist) <= capo->s->fuzzyness &&
-                levenshtein_strnormcmp(capo->s, album,  capo->s->album) <= capo->s->fuzzyness) {
+        if (levenshtein_strnormcmp (capo->s, artist, capo->s->artist) <= capo->s->fuzzyness &&
+            levenshtein_strnormcmp (capo->s, album,  capo->s->album) <= capo->s->fuzzyness) {
 
-            gchar *img_start = strstr(find, tag_ssize);
+            gchar * img_start = strstr(find, tag_ssize);
 
-            if(img_start != NULL) {
-                gchar *url = get_search_value(find, (gchar *) tag_ssize, (gchar *) tag_esize);
-                if(url != NULL) {
-                    if(strcmp(url, BAD_DEFAULT_IMAGE) != 0) {
-                        GlyrMemCache *result = DL_init();
+            if (img_start != NULL)
+            {
+                gchar * url = get_search_value (find, (gchar*) tag_ssize, (gchar*) tag_esize);
+                if (url != NULL)
+                {
+                    if (strcmp (url,BAD_DEFAULT_IMAGE) != 0)
+                    {
+                        GlyrMemCache * result = DL_init();
                         result->data = url;
-                        result->size = strlen(url);
-                        result_list = g_list_prepend(result_list, result);
-                    } else {
-                        g_free(url);
+                        result->size = strlen (url);
+                        result_list = g_list_prepend (result_list,result);
+                    }
+                    else
+                    {
+                        g_free (url);
                     }
                 }
             }
         }
 
-        g_free(artist);
-        g_free(album);
+        g_free (artist);
+        g_free (album);
     }
     return result_list;
 }
 
 /////////////////////////////////
 
-MetaDataSource cover_lastfm_src = {
+MetaDataSource cover_lastfm_src =
+{
     .name      = "lastfm",
     .key       = 'l',
     .parser    = cover_lastfm_parse,
diff --git a/lib/intern/cover/lyricswiki.c b/lib/intern/cover/lyricswiki.c
index a102f23..a150226 100644
--- a/lib/intern/cover/lyricswiki.c
+++ b/lib/intern/cover/lyricswiki.c
@@ -21,10 +21,11 @@
 #include "../../stringlib.h"
 #include "../../core.h"
 
-const gchar *cover_lyricswiki_url(GlyrQuery *sets)
+const gchar * cover_lyricswiki_url (GlyrQuery * sets)
 {
-    const gchar *url = NULL;
-    if(sets->img_min_size < 650) {
+    const gchar * url = NULL;
+    if (sets->img_min_size < 650)
+    {
         url = "http://lyrics.wikia.com/api.php?format=xml&action=query&list=allimages&aiprefix=${artist}";
     }
     return url;
@@ -32,27 +33,30 @@ const gchar *cover_lyricswiki_url(GlyrQuery *sets)
 
 /////////////////////////////////
 
-static gboolean check_file_format(GlyrQuery *query, gchar *filename)
+static gboolean check_file_format (GlyrQuery * query, gchar * filename)
 {
     gboolean result = FALSE;
-    gsize length = strlen(filename);
+    gsize length = strlen (filename);
     gsize offset = 0;
     gchar *token = NULL;
 
-    gchar **token_list = g_strsplit(query->allowed_formats, GLYR_DEFAULT_FROM_ARGUMENT_DELIM, 0);
-    while((token = token_list[offset]) != NULL) {
-        if(g_str_has_suffix(filename, token) == TRUE) {
+    gchar ** token_list = g_strsplit (query->allowed_formats,GLYR_DEFAULT_FROM_ARGUMENT_DELIM,0);
+    while ( (token = token_list[offset]) != NULL)
+    {
+        if (g_str_has_suffix (filename,token) == TRUE)
+        {
             result = TRUE;
-            gsize format_pos = length - strlen(token);
+            gsize format_pos = length - strlen (token);
             filename[format_pos] = '\0';
-            if(format_pos != 0 && filename[format_pos - 1] == '.') {
-                filename[format_pos - 1] = '\0';
+            if (format_pos != 0 && filename[format_pos-1] == '.')
+            {
+                filename[format_pos-1] = '\0';
             }
             break;
         }
         offset++;
     }
-    g_strfreev(token_list);
+    g_strfreev (token_list);
     return result;
 }
 
@@ -71,55 +75,58 @@ static gboolean check_file_format(GlyrQuery *query, gchar *filename)
 #define URL_END "\" descriptionurl="
 #define NEXT_NAME "<img name=\""
 
-GList *cover_lyricswiki_parse(cb_object *capo)
+GList * cover_lyricswiki_parse (cb_object * capo)
 {
-    gchar *find = capo->cache->data;
-    gchar *endTag   = NULL;
-    GList *result_list = NULL;
+    gchar * find = capo->cache->data;
+    gchar * endTag   = NULL;
+    GList * result_list = NULL;
 
-    gchar *escaped_album_name = strreplace(capo->s->album, " ", "_");
-    if(escaped_album_name != NULL) {
+    gchar * escaped_album_name = strreplace (capo->s->album," ","_");
+    if (escaped_album_name != NULL)
+    {
         /* Go through all names and compare them with Levenshtein */
-        while(continue_search(g_list_length(result_list), capo->s) && (find = strstr(find + (sizeof IMG_TAG) - 1, IMG_TAG)) != NULL) {
+        while (continue_search (g_list_length (result_list),capo->s) && (find = strstr (find+ (sizeof IMG_TAG) - 1,IMG_TAG) ) != NULL)
+        {
             /* Find end & start of the name */
             find  += (sizeof IMG_TAG) - 1;
-            endTag = strstr(find, END_TAG);
+            endTag = strstr (find,END_TAG);
 
-            if(endTag == NULL || endTag <= find) {
+            if (endTag == NULL || endTag <= find)
                 continue;
-            }
 
             /* Copy the name of the current album */
-            gchar *name = copy_value(find, endTag);
-            if(name != NULL) {
-                if(check_file_format(capo->s, name) && levenshtein_strnormcmp(capo->s, escaped_album_name, name) <= capo->s->fuzzyness) {
-                    gchar *url = get_search_value(endTag, URL_MARKER, URL_END);
-                    if(url != NULL) {
-                        GlyrMemCache *result = DL_init();
+            gchar * name = copy_value (find,endTag);
+            if (name != NULL)
+            {
+                if (check_file_format (capo->s,name) && levenshtein_strnormcmp (capo->s,escaped_album_name,name) <= capo->s->fuzzyness)
+                {
+                    gchar * url = get_search_value (endTag, URL_MARKER, URL_END);
+                    if (url != NULL)
+                    {
+                        GlyrMemCache * result = DL_init();
                         result->data = url;
-                        result->size = strlen(url);
-                        result_list = g_list_prepend(result_list, result);
+                        result->size = strlen (url);
+                        result_list = g_list_prepend (result_list,result);
                     }
                 }
 
                 /* Get next img tag */
-                find = strstr(endTag, NEXT_NAME);
-                g_free(name);
+                find = strstr (endTag,NEXT_NAME);
+                g_free (name);
 
                 /* Whoops, right into nonexistence.. */
-                if(find == NULL) {
-                    break;
-                }
+                if (find == NULL) break;
             }
         }
-        g_free(escaped_album_name);
+        g_free (escaped_album_name);
     }
     return result_list;
 }
 
 /////////////////////////////////
 
-MetaDataSource cover_lyricswiki_src = {
+MetaDataSource cover_lyricswiki_src =
+{
     .name      = "lyricswiki",
     .key       = 'w',
     .parser    = cover_lyricswiki_parse,
diff --git a/lib/intern/cover/musicbrainz.c b/lib/intern/cover/musicbrainz.c
index 61f1474..1ea903c 100644
--- a/lib/intern/cover/musicbrainz.c
+++ b/lib/intern/cover/musicbrainz.c
@@ -23,7 +23,7 @@
 
 /////////////////////////////////
 
-static const char *cover_musicbrainz_url(GlyrQuery *q)
+static const char * cover_musicbrainz_url (GlyrQuery * q)
 {
     return "http://musicbrainz.org/ws/2/release?query=${album}&limit=10&offset=0";
 }
@@ -37,24 +37,28 @@ static const char *cover_musicbrainz_url(GlyrQuery *q)
  * This is silly overall,
  * but coverartarchive.org does not seem to work fully yet.
  */
-static GlyrMemCache *parse_web_page(GlyrMemCache *page)
+static GlyrMemCache * parse_web_page (GlyrMemCache * page)
 {
-    GlyrMemCache *retv = NULL;
-    if(page && page->data) {
-        char *begin = strstr(page->data, COVERART);
-        if(begin != NULL) {
-            char *amz_url = strstr(begin, AMZ_URL_START);
-            if(amz_url != NULL) {
-                char *img_url = get_search_value(amz_url, "\"", "\"");
-                if(img_url != NULL) {
+    GlyrMemCache * retv = NULL;
+    if (page && page->data)
+    {
+        char * begin = strstr (page->data,COVERART);
+        if (begin != NULL)
+        {
+            char * amz_url = strstr (begin,AMZ_URL_START);
+            if (amz_url != NULL)
+            {
+                char * img_url = get_search_value (amz_url,"\"","\"");
+                if (img_url != NULL)
+                {
                     retv = DL_init();
-                    retv->dsrc = g_strdup(page->dsrc);
+                    retv->dsrc = g_strdup (page->dsrc);
                     retv->data  = img_url;
-                    retv->size  = strlen(img_url);
+                    retv->size  = strlen (img_url);
                 }
             }
         }
-        DL_free(page);
+        DL_free (page);
     }
     return retv;
 }
@@ -66,35 +70,40 @@ static GlyrMemCache *parse_web_page(GlyrMemCache *page)
 
 /////////////////////////////////
 
-static GList *cover_musicbrainz_parse(cb_object *capo)
+static GList * cover_musicbrainz_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-
-    char *node = capo->cache->data;
-
-    while(continue_search(g_list_length(result_list), capo->s) && (node = strstr(node + 1, NODE))) {
-        char *album  = get_search_value(node, "<title>", "</title>");
-        char *artist = get_search_value(node, "<name>" , "</name>");
-
-
-        if(levenshtein_strnormcmp(capo->s, artist, capo->s->artist) <= capo->s->fuzzyness &&
-                levenshtein_strnormcmp(capo->s, album , capo->s->album) <= capo->s->fuzzyness) {
-
-            char *ID = get_search_value(node, "id=\"", "\" ");
-            if(ID != NULL) {
-                char *url = g_strdup_printf(DL_URL, ID);
-                if(url != NULL) {
-                    GlyrMemCache *item = parse_web_page(download_single(url, capo->s, NULL));
-                    if(item != NULL) {
-                        result_list = g_list_prepend(result_list, item);
+    GList * result_list = NULL;
+
+    char * node = capo->cache->data;
+
+    while (continue_search (g_list_length (result_list),capo->s) && (node = strstr (node + 1,NODE) ) )
+    {
+        char * album  = get_search_value (node,"<title>","</title>");
+        char * artist = get_search_value (node,"<name>" ,"</name>" );
+
+
+        if (levenshtein_strnormcmp (capo->s,artist,capo->s->artist) <= capo->s->fuzzyness &&
+                levenshtein_strnormcmp (capo->s,album ,capo->s->album ) <= capo->s->fuzzyness)
+        {
+
+            char * ID = get_search_value (node,"id=\"","\" ");
+            if (ID != NULL)
+            {
+                char * url = g_strdup_printf (DL_URL,ID);
+                if (url != NULL)
+                {
+                    GlyrMemCache * item = parse_web_page (download_single (url,capo->s,NULL) );
+                    if (item != NULL)
+                    {
+                        result_list = g_list_prepend (result_list,item);
                     }
                 }
-                g_free(url);
+                g_free (url);
             }
-            g_free(ID);
+            g_free (ID);
         }
-        g_free(artist);
-        g_free(album);
+        g_free (artist);
+        g_free (album);
     }
 
     return result_list;
@@ -102,7 +111,8 @@ static GList *cover_musicbrainz_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource cover_musicbrainz_src = {
+MetaDataSource cover_musicbrainz_src =
+{
     .name      = "musicbrainz",
     .key       = 'z',
     .parser    = cover_musicbrainz_parse,
diff --git a/lib/intern/cover/picsearch.c b/lib/intern/cover/picsearch.c
index a646c53..4faa16d 100644
--- a/lib/intern/cover/picsearch.c
+++ b/lib/intern/cover/picsearch.c
@@ -23,20 +23,21 @@
 
 /////////////////////////////////
 
-static const gchar *cover_picsearch_url(GlyrQuery *s)
+static const gchar * cover_picsearch_url (GlyrQuery * s)
 {
-    return generic_picsearch_url(s, "${artist}+${album}+coverart");
+    return generic_picsearch_url (s,"${artist}+${album}+coverart");
 }
 
 /////////////////////////////////
-static GList *cover_picsearch_parse(cb_object *capo)
+static GList * cover_picsearch_parse (cb_object * capo)
 {
-    return generic_picsearch_parse(capo);
+    return generic_picsearch_parse (capo);
 }
 
 /////////////////////////////////
 
-MetaDataSource cover_picsearch_src = {
+MetaDataSource cover_picsearch_src =
+{
     .name      = "picsearch",
     .key       = 'p',
     .parser    = cover_picsearch_parse,
diff --git a/lib/intern/cover/rhapsody.c b/lib/intern/cover/rhapsody.c
index 972eff3..b62be53 100644
--- a/lib/intern/cover/rhapsody.c
+++ b/lib/intern/cover/rhapsody.c
@@ -23,18 +23,21 @@
 
 /////////////////////////////////
 
-static gchar *translate_string(gchar *string)
+static gchar * translate_string (gchar * string)
 {
-    gchar *result = NULL;
-    if(string != NULL) {
-        gchar *beautiful = beautify_string(string);
-        if(beautiful != NULL) {
-            gchar *downcase = g_utf8_strdown(beautiful, -1);
-            if(downcase != NULL) {
-                result = translate_umlauts(downcase);
-                g_free(downcase);
+    gchar * result = NULL;
+    if (string != NULL)
+    {
+        gchar * beautiful = beautify_string (string);
+        if (beautiful != NULL)
+        {
+            gchar * downcase = g_utf8_strdown (beautiful,-1);
+            if (downcase != NULL)
+            {
+                result = translate_umlauts (downcase);
+                g_free (downcase);
             }
-            g_free(beautiful);
+            g_free (beautiful);
         }
     }
     return result;
@@ -42,34 +45,37 @@ static gchar *translate_string(gchar *string)
 
 /////////////////////////////////
 
-static const gchar *cover_rhapsody_url(GlyrQuery *query)
+static const gchar * cover_rhapsody_url (GlyrQuery * query)
 {
-    gchar *result = NULL;
-    gchar *corrected_artist = translate_string(query->artist);
-    gchar *corrected_album  = translate_string(query->album);
-    if(corrected_artist && corrected_album) {
-        result = g_strdup_printf("http://feeds.rhapsody.com/%s/%s/data.xml", corrected_artist, corrected_album);
+    gchar * result = NULL;
+    gchar * corrected_artist = translate_string (query->artist);
+    gchar * corrected_album  = translate_string (query->album);
+    if (corrected_artist && corrected_album)
+    {
+        result = g_strdup_printf ("http://feeds.rhapsody.com/%s/%s/data.xml",corrected_artist,corrected_album);
     }
-    g_free(corrected_artist);
-    g_free(corrected_album);
+    g_free (corrected_artist);
+    g_free (corrected_album);
     return result;
 }
 
 /////////////////////////////////
 
-static gboolean check_size(GlyrQuery *s, gchar *ref)
+static gboolean check_size (GlyrQuery * s, gchar * ref)
 {
     gboolean result = FALSE;
-    if(ref != NULL) {
-        gchar *width_str  = get_search_value(ref, "width=\"", "\"");
-        gchar *height_str = get_search_value(ref, "height=\"", "\"");
-        if(width_str && height_str) {
-            gint width  = strtol(width_str, NULL, 10);
-            gint height = strtol(height_str, NULL, 10);
-            result = size_is_okay((width + height) / 2, s->img_min_size, s->img_max_size);
+    if (ref != NULL)
+    {
+        gchar * width_str  = get_search_value (ref,"width=\"","\"");
+        gchar * height_str = get_search_value (ref,"height=\"","\"");
+        if (width_str && height_str)
+        {
+            gint width  = strtol (width_str, NULL,10);
+            gint height = strtol (height_str,NULL,10);
+            result = size_is_okay ( (width+height) /2,s->img_min_size,s->img_max_size);
         }
-        g_free(width_str);
-        g_free(height_str);
+        g_free (width_str);
+        g_free (height_str);
     }
     return result;
 }
@@ -82,28 +88,33 @@ static gboolean check_size(GlyrQuery *s, gchar *ref)
 #define HACK_SIZE "170x170"
 #define HIGH_SIZE "500x500"
 
-static GList *cover_rhapsody_parse(cb_object *capo)
+static GList * cover_rhapsody_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *delim_beg = strstr(capo->cache->data, DELIM_BEG);
-    gchar *delim_end = strstr(capo->cache->data, DELIM_END);
-    GlyrMemCache *special_size = NULL;
+    GList * result_list = NULL;
+    gchar * delim_beg = strstr (capo->cache->data,DELIM_BEG);
+    gchar * delim_end = strstr (capo->cache->data,DELIM_END);
+    GlyrMemCache * special_size = NULL;
 
-    if(delim_beg && delim_end) {
-        gchar *node = delim_beg;
+    if (delim_beg && delim_end)
+    {
+        gchar * node = delim_beg;
         gsize nd_len = (sizeof NODE) - 1;
-        while(continue_search(g_list_length(result_list), capo->s) && (node = strstr(node + nd_len, NODE)) && node < delim_end) {
+        while (continue_search (g_list_length (result_list),capo->s) && (node = strstr (node + nd_len, NODE) ) && node < delim_end)
+        {
             node += nd_len;
-            if(check_size(capo->s, node) == TRUE) {
-                gchar *url = get_search_value(node, "src=\"", "\"");
-                if(url != NULL) {
-                    GlyrMemCache *result = DL_init();
+            if (check_size (capo->s,node) == TRUE)
+            {
+                gchar * url = get_search_value (node,"src=\"","\"");
+                if (url != NULL)
+                {
+                    GlyrMemCache * result = DL_init();
                     result->data = url;
-                    result->size = strlen(url);
-                    result_list = g_list_prepend(result_list, result);
+                    result->size = strlen (url);
+                    result_list = g_list_prepend (result_list,result);
 
                     /* A very cool hack. Thanks Bansheeproject! */
-                    if(strstr(result->data, HACK_SIZE) != NULL) {
+                    if (strstr (result->data,HACK_SIZE) != NULL)
+                    {
                         special_size = result;
                     }
                 }
@@ -111,15 +122,16 @@ static GList *cover_rhapsody_parse(cb_object *capo)
         }
 
         /* Awesome hack continues.. */
-        if(special_size != NULL) {
+        if (special_size != NULL)
+        {
             /* Note: Prepend the large size at begin:
              * If only one item requested it will just
              * be thrown away (the small size)
              */
-            GlyrMemCache *result = DL_init();
-            result->data = strreplace(special_size->data, HACK_SIZE, HIGH_SIZE);
-            result->size = strlen(result->data);
-            result_list = g_list_prepend(result_list, result);
+            GlyrMemCache * result = DL_init();
+            result->data = strreplace (special_size->data,HACK_SIZE,HIGH_SIZE);
+            result->size = strlen (result->data);
+            result_list = g_list_prepend (result_list,result);
         }
     }
     return result_list;
@@ -127,7 +139,8 @@ static GList *cover_rhapsody_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource cover_rhapsody_src = {
+MetaDataSource cover_rhapsody_src =
+{
     .name      = "rhapsody",
     .key       = 'r',
     .parser    = cover_rhapsody_parse,
diff --git a/lib/intern/cover/slothradio.c b/lib/intern/cover/slothradio.c
index d888a0a..1f87668 100644
--- a/lib/intern/cover/slothradio.c
+++ b/lib/intern/cover/slothradio.c
@@ -33,12 +33,11 @@
 
 #define STREQ(s1,s2) (g_ascii_strcasecmp(s1,s2) == 0)
 
-static const char *cover_slothradio_url(GlyrQuery *s)
+static const char * cover_slothradio_url (GlyrQuery * s)
 {
-    const char *locale = "us";
-    if(STREQ(s->lang, "uk") || STREQ(s->lang, "de")) {
+    const char * locale = "us";
+    if (STREQ (s->lang,"uk") || STREQ (s->lang,"de") )
         locale = s->lang;
-    }
 
     /*
      * Possible image sizes:
@@ -48,81 +47,82 @@ static const char *cover_slothradio_url(GlyrQuery *s)
      * s = small  (50 **2)
      **/
     char image_size = 'x';
-    if(s->img_max_size != -1) {
-        if(s->img_max_size < 75) {
+    if (s->img_max_size != -1)
+    {
+        if (s->img_max_size < 75)
             image_size = 's';
-        } else if(s->img_max_size < 150) {
+        else if (s->img_max_size < 150)
             image_size = 'm';
-        } else if(s->img_max_size < 350) {
+        else if (s->img_max_size < 350)
             image_size = 'l';
-        }
     }
 
-    return g_strdup_printf(API_URL, s->artist, s->album, image_size, locale);
+    return g_strdup_printf (API_URL,s->artist,s->album,image_size,locale);
 }
 
 ///////////////////////
 
-static bool check_size(GlyrQuery *q, char *node)
+static bool check_size (GlyrQuery * q, char * node)
 {
     bool rc = false;
-    char *width  = get_search_value(node, "width=\"", "\"");
-    char *height = get_search_value(node, "height=\"", "\"");
+    char * width  = get_search_value (node,"width=\"", "\"");
+    char * height = get_search_value (node,"height=\"","\"");
 
-    if(width && height) {
-        int w = strtol(width, NULL, 10);
-        int h = strtol(height, NULL, 10);
+    if (width && height)
+    {
+        int w = strtol (width, NULL,10);
+        int h = strtol (height,NULL,10);
 
-        if(size_is_okay(w, q->img_min_size, q->img_max_size) &&
-                size_is_okay(h, q->img_min_size, q->img_max_size)) {
+        if (size_is_okay (w,q->img_min_size,q->img_max_size) &&
+                size_is_okay (h,q->img_min_size,q->img_max_size) )
             rc = true;
-        }
     }
-    g_free(width);
-    g_free(height);
+    g_free (width);
+    g_free (height);
 
     return rc;
 }
 
 ///////////////////////
 
-static GList *cover_slothradio_parse(cb_object *capo)
+static GList * cover_slothradio_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
+    GList * result_list = NULL;
 
-    const char *bound_start = strstr(capo->cache->data, RESULT_LIST_START);
-    if(bound_start == NULL) {
+    const char * bound_start = strstr (capo->cache->data,RESULT_LIST_START);
+    if (bound_start == NULL)
         return NULL;
-    }
 
-    const char *bound_end  = strstr(bound_start, RESULT_LIST_END);
-    if(bound_end == NULL) {
+    const char * bound_end  = strstr (bound_start,RESULT_LIST_END);
+    if (bound_end == NULL)
         return NULL;
-    }
 
-    char *node = (char *) bound_start;
-    while((node = strstr(node + sizeof(RESULT_ITEM_START), RESULT_ITEM_START)) != NULL) {
-        if(node >= bound_end) {
+    char * node = (char*) bound_start;
+    while ( (node = strstr (node + sizeof (RESULT_ITEM_START),RESULT_ITEM_START) ) != NULL)
+    {
+        if (node >= bound_end)
             break;
-        }
 
-        char *url = get_search_value(node, "img src=\"", "\"");
-        if(url != NULL) {
-            if(check_size(capo->s, node)) {
-                GlyrMemCache *result = DL_init();
-                result->dsrc = g_strdup(capo->url);
+        char * url = get_search_value (node,"img src=\"","\"");
+        if (url != NULL)
+        {
+            if (check_size (capo->s,node) )
+            {
+                GlyrMemCache * result = DL_init();
+                result->dsrc = g_strdup (capo->url);
                 result->data = url;
-                result->size = strlen(url);
+                result->size = strlen (url);
 
-                result_list = g_list_prepend(result_list, result);
-            } else {
-                g_free(url);
+                result_list = g_list_prepend (result_list,result);
+            }
+            else
+            {
+                g_free (url);
             }
         }
 
-        if(continue_search(g_list_length(result_list), capo->s) == false) {
+        if (continue_search (g_list_length (result_list),capo->s) == false)
             break;
-        }
     }
 
     return result_list;
@@ -130,7 +130,8 @@ static GList *cover_slothradio_parse(cb_object *capo)
 
 ///////////////////////
 
-MetaDataSource cover_slothradio_src = {
+MetaDataSource cover_slothradio_src =
+{
     .name      = "slothradio",
     .key       = 's',
     .parser    = cover_slothradio_parse,
diff --git a/lib/intern/generic.c b/lib/intern/generic.c
index f4de573..d8436ab 100644
--- a/lib/intern/generic.c
+++ b/lib/intern/generic.c
@@ -22,48 +22,59 @@
 #include "../core.h"
 #include "../stringlib.h"
 
-struct callback_save_struct {
-    GHashTable *table;
+struct callback_save_struct
+{
+    GHashTable * table;
     GLYR_DATA_TYPE type;
-    GList *results;
+    GList * results;
 };
 
 /////////////////////////////////
 
 /* Simple finalizer template sufficient for most */
-GList *generic_txt_finalizer(GlyrQuery *settings, GList *input_list, gboolean *stop_me, GLYR_DATA_TYPE type, GList **result_list)
+GList * generic_txt_finalizer (GlyrQuery * settings, GList * input_list, gboolean * stop_me, GLYR_DATA_TYPE type, GList ** result_list)
 {
     gboolean add_to_list = TRUE;
-    GList *almost_copied = NULL;
-    for(GList *elem = input_list; elem; elem = elem->next) {
-        GlyrMemCache *item = elem->data;
-        if(is_in_result_list(item, result_list[0]) == FALSE && add_to_list == TRUE) {
+    GList * almost_copied = NULL;
+    for (GList * elem = input_list; elem; elem = elem->next)
+    {
+        GlyrMemCache * item = elem->data;
+        if (is_in_result_list (item,result_list[0]) == FALSE && add_to_list == TRUE)
+        {
             /* Set to some default type */
-            if(item->type == GLYR_TYPE_UNKNOWN) {
+            if (item->type == GLYR_TYPE_UNKNOWN)
+            {
                 item->type = type;
             }
 
             /* call user defined callback */
             GLYR_ERROR response = GLYRE_OK;
-            if(settings->callback.download) {
+            if (settings->callback.download)
+            {
                 /* Call the usercallback */
-                response = settings->callback.download(item, settings);
+                response = settings->callback.download (item,settings);
             }
 
-            if(response != GLYRE_SKIP && response != GLYRE_STOP_PRE) {
-                almost_copied = g_list_prepend(almost_copied, item);
-            } else {
-                DL_free(item);
+            if (response != GLYRE_SKIP && response != GLYRE_STOP_PRE)
+            {
+                almost_copied = g_list_prepend (almost_copied,item);
+            }
+            else
+            {
+                DL_free (item);
                 item = NULL;
             }
 
-            if(response == GLYRE_STOP_POST || response == GLYRE_STOP_PRE) {
+            if (response == GLYRE_STOP_POST || response == GLYRE_STOP_PRE)
+            {
                 add_to_list = FALSE;
                 *stop_me = TRUE;
             }
-        } else {
+        }
+        else
+        {
             settings->itemctr--;
-            DL_free(item);
+            DL_free (item);
             item = NULL;
         }
     }
@@ -72,43 +83,54 @@ GList *generic_txt_finalizer(GlyrQuery *settings, GList *input_list, gboolean *s
 
 /////////////////////////////////
 
-static GList *async_dl_callback(cb_object *capo, void *userptr, bool *stop_download, gint *add_item)
+static GList * async_dl_callback (cb_object * capo, void * userptr, bool * stop_download, gint * add_item)
 {
-    if(capo->cache != NULL && userptr != NULL) {
+    if (capo->cache != NULL && userptr != NULL)
+    {
         /* Sanitize this */
-        struct callback_save_struct *saver = userptr;
-        GHashTable *prov_url_table = saver->table;
+        struct callback_save_struct * saver = userptr;
+        GHashTable * prov_url_table = saver->table;
         capo->cache->is_image = true;
 
-        if(prov_url_table != NULL) {
-            GlyrMemCache *old_cache = g_hash_table_lookup(prov_url_table, capo->cache->dsrc);
+        if (prov_url_table != NULL)
+        {
+            GlyrMemCache * old_cache = g_hash_table_lookup (prov_url_table,capo->cache->dsrc);
             GLYR_ERROR response = GLYRE_OK;
-            if(old_cache != NULL) {
-                update_md5sum(capo->cache);
-                if(is_in_result_list(capo->cache, saver->results) == FALSE) {
-                    capo->cache->prov       = (old_cache->prov != NULL) ? g_strdup(old_cache->prov) : NULL;
-                    capo->cache->img_format = (old_cache->img_format) ? g_strdup(old_cache->img_format) : NULL;
-
-                    if(capo->cache->type == GLYR_TYPE_UNKNOWN) {
+            if (old_cache != NULL)
+            {
+                update_md5sum (capo->cache);
+                if (is_in_result_list (capo->cache,saver->results) == FALSE)
+                {
+                    capo->cache->prov       = (old_cache->prov!=NULL) ? g_strdup (old_cache->prov) : NULL;
+                    capo->cache->img_format = (old_cache->img_format) ? g_strdup (old_cache->img_format) : NULL;
+
+                    if (capo->cache->type == GLYR_TYPE_UNKNOWN)
+                    {
                         capo->cache->type = saver->type;
                     }
 
-                    if(capo->s->callback.download != NULL) {
-                        response = capo->s->callback.download(capo->cache, capo->s);
+                    if (capo->s->callback.download != NULL)
+                    {
+                        response = capo->s->callback.download (capo->cache,capo->s);
                     }
 
                     *add_item = (response != GLYRE_SKIP && response != GLYRE_STOP_PRE);
-                } else {
+                }
+                else
+                {
                     capo->s->itemctr--;
                     *add_item = FALSE;
                 }
             }
 
-            if(response == GLYRE_STOP_POST || response == GLYRE_STOP_PRE) {
+            if (response == GLYRE_STOP_POST || response == GLYRE_STOP_PRE)
+            {
                 *stop_download = TRUE;
             }
-        } else {
-            glyr_message(-1, NULL, "glyr: Warn: Hashtable is empty im image_callback!\n");
+        }
+        else
+        {
+            glyr_message (-1,NULL,"glyr: Warn: Hashtable is empty im image_callback!\n");
         }
     }
     return NULL;
@@ -116,58 +138,66 @@ static GList *async_dl_callback(cb_object *capo, void *userptr, bool *stop_downl
 
 /////////////////////////////////
 
-GList *generic_img_finalizer(GlyrQuery *s, GList *list, gboolean *stop_me, GLYR_DATA_TYPE type, GList **result_list)
+GList * generic_img_finalizer (GlyrQuery * s, GList * list, gboolean * stop_me, GLYR_DATA_TYPE type, GList ** result_list)
 {
     /* Just return URLs */
-    if(s->download == false) {
-        for(GList *elem = list; elem; elem = elem->next) {
-            GlyrMemCache *img = elem->data;
+    if (s->download == false)
+    {
+        for (GList * elem = list; elem; elem = elem->next)
+        {
+            GlyrMemCache * img = elem->data;
             img->is_image = false;
         }
-        return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_IMG_URL, result_list);
-    } else {
+        return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_IMG_URL,result_list);
+    }
+    else
+    {
         /* Convert to a list of URLs first */
-        GList *url_list  = NULL;
+        GList * url_list  = NULL;
 
         /* Hashtable to associate the provider name with the corresponding URL */
-        GHashTable *cache_url_table = g_hash_table_new_full(g_str_hash, g_str_equal,
-                                      NULL,
-                                      (GDestroyNotify) DL_free
-                                                           );
+        GHashTable * cache_url_table = g_hash_table_new_full (g_str_hash,g_str_equal,
+                                       NULL,
+                                       (GDestroyNotify) DL_free
+                                                             );
 
         /* Iterate over all caches and turn them to GList */
-        for(GList *item = list; item; item = item->next) {
-            GlyrMemCache *cache = item->data;
+        for (GList * item = list; item; item = item->next)
+        {
+            GlyrMemCache * cache = item->data;
 
             /* Make a copy, since we free the cache */
-            gchar *url_double = g_strdup(cache->data);
-            url_list  = g_list_prepend(url_list, url_double);
+            gchar * url_double = g_strdup (cache->data);
+            url_list  = g_list_prepend (url_list,url_double);
 
             /* Fill in the URL */
-            g_hash_table_insert(cache_url_table, (gpointer) url_double, (gpointer) cache);
+            g_hash_table_insert (cache_url_table, (gpointer) url_double, (gpointer) cache);
         }
 
         /* We need to pass this to the callback */
-        struct callback_save_struct userptr = {
+        struct callback_save_struct userptr =
+        {
             .table = cache_url_table,
             .type  = type,
             .results = result_list ? result_list[0] : NULL
         };
 
         /* Download images in parallel */
-        GList *dl_raw_images = async_download(url_list, NULL, s, 1, (g_list_length(url_list) / 2), async_dl_callback, &userptr, FALSE);
+        GList * dl_raw_images = async_download (url_list,NULL,s,1, (g_list_length (url_list) /2),async_dl_callback,&userptr,FALSE);
 
         /* Default to the given type */
-        for(GList *elem = dl_raw_images; elem; elem = elem->next) {
-            GlyrMemCache *item = elem->data;
-            if(item && item->type == GLYR_TYPE_UNKNOWN) {
+        for (GList * elem = dl_raw_images; elem; elem = elem->next)
+        {
+            GlyrMemCache * item = elem->data;
+            if (item && item->type == GLYR_TYPE_UNKNOWN)
+            {
                 item->type = type;
             }
         }
 
         /* Freeing Party */
-        g_hash_table_destroy(cache_url_table);
-        glist_free_full(url_list, g_free);
+        g_hash_table_destroy (cache_url_table);
+        glist_free_full (url_list,g_free);
 
         /* Ready to save images */
         return dl_raw_images;
diff --git a/lib/intern/guitartabs.c b/lib/intern/guitartabs.c
index acd2bb1..41c4a87 100644
--- a/lib/intern/guitartabs.c
+++ b/lib/intern/guitartabs.c
@@ -24,27 +24,30 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
     /* Fix up tabs, escape chars etc.  */
-    for(GList *elem = list; elem; elem = elem->next) {
-        GlyrMemCache *item = elem->data;
-        if(item != NULL) {
-            gchar *temp = beautify_string(item->data);
-            g_free(item->data);
+    for (GList * elem = list; elem; elem = elem->next)
+    {
+        GlyrMemCache * item = elem->data;
+        if (item != NULL)
+        {
+            gchar * temp = beautify_string (item->data);
+            g_free (item->data);
             item->data = temp;
-            item->size = (item->data) ? strlen(item->data) : 0;
+            item->size = (item->data) ? strlen (item->data) : 0;
         }
     }
 
     /* Let the rest do by the norma generic finalizer */
-    return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_GUITARTABS, result_list);
+    return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_GUITARTABS,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_guitartabs = {
+MetaDataFetcher glyrFetcher_guitartabs =
+{
     .name = "guitartabs",
     .type = GLYR_GET_GUITARTABS,
     .default_data_type = GLYR_TYPE_GUITARTABS,
diff --git a/lib/intern/guitartabs/chordie_com.c b/lib/intern/guitartabs/chordie_com.c
index 318a8bc..fdbffab 100644
--- a/lib/intern/guitartabs/chordie_com.c
+++ b/lib/intern/guitartabs/chordie_com.c
@@ -27,29 +27,32 @@
 #define RESULTS_ENDIN "<!--results end-->"
 #define NODE "<a class=\"darkblue\" href=\""
 
-static const gchar *guitartabs_chordie_url(GlyrQuery *s)
+static const gchar * guitartabs_chordie_url (GlyrQuery * s)
 {
     return SEARCH_URL;
 }
 
 /////////////////////////////////
 
-static gboolean check_title_value(GlyrQuery *s, const gchar *to_check)
+static gboolean check_title_value (GlyrQuery * s, const gchar * to_check)
 {
     gboolean result = FALSE;
-    if(to_check != NULL) {
-        gchar *artist = g_strrstr(to_check, "(");
-        if(artist != NULL) {
+    if (to_check != NULL)
+    {
+        gchar * artist = g_strrstr (to_check,"(");
+        if (artist != NULL)
+        {
             artist[0] = 0;
             artist++;
 
-            gchar *end_bracket = strchr(artist, ')');
-            if(end_bracket) {
+            gchar * end_bracket = strchr (artist,')');
+            if (end_bracket)
+            {
                 end_bracket[0] = 0;
             }
 
-            result = (levenshtein_strnormcmp(s, artist, s->artist)  <= s->fuzzyness &&
-                      levenshtein_strnormcmp(s, to_check, s->title) <= s->fuzzyness);
+            result = (levenshtein_strnormcmp (s,artist,s->artist)  <= s->fuzzyness &&
+                      levenshtein_strnormcmp (s,to_check,s->title) <= s->fuzzyness);
         }
     }
     return result;
@@ -57,20 +60,23 @@ static gboolean check_title_value(GlyrQuery *s, const gchar *to_check)
 
 /////////////////////////////////
 
-static GlyrMemCache *parse_result_page(GlyrQuery *s, gchar *content_url)
+static GlyrMemCache * parse_result_page (GlyrQuery * s, gchar * content_url)
 {
-    GlyrMemCache *result = NULL;
-    if(content_url != NULL) {
-        GlyrMemCache *dl_cache = download_single(content_url, s, NULL);
-        if(dl_cache != NULL) {
-            gchar *content = get_search_value(dl_cache->data, "<div class=\"song\">", "</div>");
-            if(content != NULL) {
+    GlyrMemCache * result = NULL;
+    if (content_url != NULL)
+    {
+        GlyrMemCache * dl_cache = download_single (content_url,s,NULL);
+        if (dl_cache != NULL)
+        {
+            gchar * content = get_search_value (dl_cache->data,"<div class=\"song\">","</div>");
+            if (content != NULL)
+            {
                 result = DL_init();
                 result->data = content;
-                result->size = strlen(content);
-                result->dsrc = g_strdup(content_url);
+                result->size = strlen (content);
+                result->dsrc = g_strdup (content_url);
             }
-            DL_free(dl_cache);
+            DL_free (dl_cache);
         }
     }
     return result;
@@ -79,29 +85,35 @@ static GlyrMemCache *parse_result_page(GlyrQuery *s, gchar *content_url)
 
 /////////////////////////////////
 
-static GList *guitartabs_chordie_parse(cb_object *capo)
+static GList * guitartabs_chordie_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *search_begin = strstr(capo->cache->data, RESULTS_BEGIN);
-    if(search_begin != NULL) {
-        gchar *search_ending = strstr(search_begin, RESULTS_ENDIN);
-        if(search_ending != NULL) {
-            gchar *node  = search_begin;
+    GList * result_list = NULL;
+    gchar * search_begin = strstr (capo->cache->data,RESULTS_BEGIN);
+    if (search_begin != NULL)
+    {
+        gchar * search_ending = strstr (search_begin,RESULTS_ENDIN);
+        if (search_ending != NULL)
+        {
+            gchar * node  = search_begin;
             gsize nodelen = (sizeof NODE) - 1;
-            while(continue_search(g_list_length(result_list), capo->s) && (node = strstr(node + nodelen, NODE)) != NULL && node >= search_begin && node <= search_ending) {
-                gchar *url = get_search_value(node, NODE, "\" ");
-                if(url != NULL) {
-                    gchar *name_value = get_search_value(node, "\">", "</a>");
-                    if(check_title_value(capo->s, name_value) == TRUE) {
-                        gchar *content_url = g_strdup_printf("%s%s", BASE_URL, url);
-                        GlyrMemCache *result = parse_result_page(capo->s, content_url);
-                        if(result != NULL) {
-                            result_list = g_list_prepend(result_list, result);
+            while (continue_search (g_list_length (result_list),capo->s) && (node = strstr (node + nodelen, NODE) ) != NULL && node >= search_begin && node <= search_ending)
+            {
+                gchar * url = get_search_value (node,NODE,"\" ");
+                if (url != NULL)
+                {
+                    gchar * name_value = get_search_value (node,"\">","</a>");
+                    if (check_title_value (capo->s, name_value) == TRUE)
+                    {
+                        gchar * content_url = g_strdup_printf ("%s%s",BASE_URL,url);
+                        GlyrMemCache * result = parse_result_page (capo->s,content_url);
+                        if (result != NULL)
+                        {
+                            result_list = g_list_prepend (result_list,result);
                         }
-                        g_free(content_url);
+                        g_free (content_url);
                     }
-                    g_free(name_value);
-                    g_free(url);
+                    g_free (name_value);
+                    g_free (url);
                 }
             }
         }
@@ -111,7 +123,8 @@ static GList *guitartabs_chordie_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource guitartabs_chordie_src = {
+MetaDataSource guitartabs_chordie_src =
+{
     .name = "chordie",
     .key  = 'c',
     .parser    = guitartabs_chordie_parse,
diff --git a/lib/intern/guitartabs/guitaretab.c b/lib/intern/guitartabs/guitaretab.c
index f7793bc..9e817d4 100644
--- a/lib/intern/guitartabs/guitaretab.c
+++ b/lib/intern/guitartabs/guitaretab.c
@@ -25,26 +25,28 @@
 
 /////////////////////////////////
 
-static const gchar *gt_guitaretabs_url(GlyrQuery *settings)
+static const gchar * gt_guitaretabs_url (GlyrQuery * settings)
 {
     return GT_URL;
 }
 
 /////////////////////////////////
 
-static GlyrMemCache *parse_single_page(GlyrQuery *s, const gchar *url)
+static GlyrMemCache * parse_single_page (GlyrQuery * s, const gchar * url)
 {
-    GlyrMemCache *result = NULL;
-    GlyrMemCache *tab_cache = download_single(url, s, NULL);
-    if(tab_cache != NULL) {
-        gchar *content = get_search_value(tab_cache->data, "<pre>", "</pre>");
-        if(content != NULL) {
+    GlyrMemCache * result = NULL;
+    GlyrMemCache * tab_cache = download_single (url,s,NULL);
+    if (tab_cache != NULL)
+    {
+        gchar * content = get_search_value (tab_cache->data,"<pre>","</pre>");
+        if (content != NULL)
+        {
             result = DL_init();
             result->data = content;
-            result->size = strlen(content);
-            result->dsrc = g_strdup(url);
+            result->size = strlen (content);
+            result->dsrc = g_strdup (url);
         }
-        DL_free(tab_cache);
+        DL_free (tab_cache);
     }
     return result;
 }
@@ -62,53 +64,62 @@ static GlyrMemCache *parse_single_page(GlyrQuery *s, const gchar *url)
 #define TITLE_BEGIN "\">"
 #define TITLE_ENDIN "</a></li>"
 
-static GList *gt_guitaretabs_parse(cb_object *capo)
+static GList * gt_guitaretabs_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *begin_search = strstr(capo->cache->data, SEARCH_RESULTS_BEGIN);
-    if(begin_search != NULL) {
+    GList * result_list = NULL;
+    gchar * begin_search = strstr (capo->cache->data,SEARCH_RESULTS_BEGIN);
+    if (begin_search != NULL)
+    {
         /* End need to assure we don't get over the search results */
-        gchar *endin_search = strstr(begin_search, SEARCH_RESULTS_ENDIN);
-        if(endin_search != NULL) {
+        gchar * endin_search = strstr (begin_search,SEARCH_RESULTS_ENDIN);
+        if (endin_search != NULL)
+        {
             /* Go through all search results */
-            gchar *node  = begin_search;
+            gchar * node  = begin_search;
             gsize nodelen = (sizeof SEARCH_NODE) - 1;
-            while(continue_search(g_list_length(result_list), capo->s) && (node = strstr(node + nodelen, SEARCH_NODE)) != NULL && node <= endin_search) {
-                gchar *artist = get_search_value(node, ARTIST_BEGIN, ARTIST_END);
-                node = strstr(node + nodelen, SEARCH_NODE);
-                if(node != NULL) {
-                    gchar *url = get_search_value(node, SEARCH_NODE, URL_END);
-                    gchar *title = get_search_value(node, TITLE_BEGIN, TITLE_ENDIN);
-
-                    if(title != NULL) {
-                        gchar *delim = g_strrstr(title, " chords");
-                        if(delim == NULL) {
-                            delim = g_strrstr(title, " tab");
+            while (continue_search (g_list_length (result_list),capo->s) && (node = strstr (node + nodelen, SEARCH_NODE) ) != NULL && node <= endin_search)
+            {
+                gchar * artist = get_search_value (node,ARTIST_BEGIN,ARTIST_END);
+                node = strstr (node + nodelen, SEARCH_NODE);
+                if (node != NULL)
+                {
+                    gchar * url = get_search_value (node,SEARCH_NODE,URL_END);
+                    gchar * title = get_search_value (node,TITLE_BEGIN,TITLE_ENDIN);
+
+                    if (title != NULL)
+                    {
+                        gchar * delim = g_strrstr (title," chords");
+                        if (delim == NULL)
+                        {
+                            delim = g_strrstr (title," tab");
                         }
 
-                        if(delim != NULL) {
+                        if (delim != NULL)
+                        {
                             delim[0] = 0;
                         }
                     }
 
                     /* Check if this is the item we actually search */
-                    if(levenshtein_strnormcmp(capo->s, title, capo->s->title) <= capo->s->fuzzyness &&
-                            levenshtein_strnormcmp(capo->s, artist, capo->s->artist) <= capo->s->fuzzyness) {
+                    if (levenshtein_strnormcmp (capo->s,title, capo->s->title ) <= capo->s->fuzzyness &&
+                            levenshtein_strnormcmp (capo->s,artist,capo->s->artist) <= capo->s->fuzzyness)
+                    {
                         /* Build resulting url */
-                        gchar *result_url = g_strdup_printf("%s%s", GT_BASE, url);
+                        gchar * result_url = g_strdup_printf ("%s%s",GT_BASE,url);
 
                         /* Go and parse it */
-                        GlyrMemCache *result = parse_single_page(capo->s, result_url);
-                        if(result != NULL) {
-                            result_list = g_list_prepend(result_list, result);
+                        GlyrMemCache * result = parse_single_page (capo->s,result_url);
+                        if (result != NULL)
+                        {
+                            result_list = g_list_prepend (result_list,result);
                         }
-                        g_free(result_url);
+                        g_free (result_url);
                     }
-                    g_free(url);
-                    g_free(title);
+                    g_free (url);
+                    g_free (title);
 
                 }
-                g_free(artist);
+                g_free (artist);
             }
         }
     }
@@ -117,7 +128,8 @@ static GList *gt_guitaretabs_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource guitartabs_guitaretab_src = {
+MetaDataSource guitartabs_guitaretab_src =
+{
     .name = "guitaretab",
     .key  = 'g',
     .parser    = gt_guitaretabs_parse,
diff --git a/lib/intern/lyrics.c b/lib/intern/lyrics.c
index ef7d93f..7e84058 100644
--- a/lib/intern/lyrics.c
+++ b/lib/intern/lyrics.c
@@ -24,27 +24,30 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
     /* Fix up lyrics, escape chars etc.  */
-    for(GList *elem = list; elem; elem = elem->next) {
-        GlyrMemCache *item = elem->data;
-        if(item != NULL) {
-            gchar *temp = beautify_string(item->data);
-            g_free(item->data);
+    for (GList * elem = list; elem; elem = elem->next)
+    {
+        GlyrMemCache * item = elem->data;
+        if (item != NULL)
+        {
+            gchar * temp = beautify_string (item->data);
+            g_free (item->data);
             item->data = temp;
-            item->size = (item->data) ? strlen(item->data) : 0;
+            item->size = (item->data) ? strlen (item->data) : 0;
         }
     }
 
     /* Let the rest do by the norma generic finalizer */
-    return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_LYRICS, result_list);
+    return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_LYRICS,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_lyrics = {
+MetaDataFetcher glyrFetcher_lyrics =
+{
     .name = "lyrics",
     .type = GLYR_GET_LYRICS,
     .default_data_type = GLYR_TYPE_LYRICS,
diff --git a/lib/intern/lyrics/chartlyrics.c b/lib/intern/lyrics/chartlyrics.c
index 6c9d82a..088fe5a 100644
--- a/lib/intern/lyrics/chartlyrics.c
+++ b/lib/intern/lyrics/chartlyrics.c
@@ -25,7 +25,7 @@
 
 /////////////////////////////////
 
-static const gchar *lyrics_chartlyrics_url(GlyrQuery *s)
+static const gchar * lyrics_chartlyrics_url (GlyrQuery * s)
 {
     return CL_API_URL;
 }
@@ -35,19 +35,21 @@ static const gchar *lyrics_chartlyrics_url(GlyrQuery *s)
 #define LYRIC_TEXT_BEG "<Lyric>"
 #define LYRIC_TEXT_END "</Lyric>"
 
-static GlyrMemCache *get_lyrics_from_results(GlyrQuery *s, const gchar *url)
+static GlyrMemCache * get_lyrics_from_results (GlyrQuery * s, const gchar * url)
 {
-    GlyrMemCache *result = NULL;
-    GlyrMemCache *dl_cache = download_single(url, s, NULL);
-    if(dl_cache != NULL) {
-        gchar *text = get_search_value(dl_cache->data, LYRIC_TEXT_BEG, LYRIC_TEXT_END);
-        if(text != NULL) {
+    GlyrMemCache * result = NULL;
+    GlyrMemCache * dl_cache = download_single (url,s,NULL);
+    if (dl_cache != NULL)
+    {
+        gchar * text = get_search_value (dl_cache->data,LYRIC_TEXT_BEG,LYRIC_TEXT_END);
+        if (text != NULL)
+        {
             result = DL_init();
             result->data = text;
-            result->size = strlen(text);
-            result->dsrc = g_strdup(url);
+            result->size = strlen (text);
+            result->dsrc = g_strdup (url);
         }
-        DL_free(dl_cache);
+        DL_free (dl_cache);
     }
     return result;
 }
@@ -68,34 +70,38 @@ static GlyrMemCache *get_lyrics_from_results(GlyrQuery *s, const gchar *url)
 #define LYRIC_ID_BEG "<LyricId>"
 #define LYRIC_ID_END "</LyricId>"
 
-static GList *lyrics_chartlyrics_parse(cb_object *capo)
+static GList * lyrics_chartlyrics_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *node = capo->cache->data;
+    GList * result_list = NULL;
+    gchar * node = capo->cache->data;
     gint nodelen = (sizeof LYRIC_NODE) - 1;
 
-    while(continue_search(g_list_length(result_list), capo->s) && (node = strstr(node + nodelen, LYRIC_NODE)) != NULL) {
+    while (continue_search (g_list_length (result_list),capo->s) && (node = strstr (node + nodelen, LYRIC_NODE) ) != NULL)
+    {
         node += nodelen;
-        gchar *artist = get_search_value(node, ARTIST_BEG, ARTIST_END);
-        gchar *title  = get_search_value(node, SONG_BEG, SONG_END);
-
-        if(levenshtein_strnormcmp(capo->s, artist, capo->s->artist) <= capo->s->fuzzyness &&
-                levenshtein_strnormcmp(capo->s, title, capo->s->title)   <= capo->s->fuzzyness) {
-            gchar *lyric_id = get_search_value(node, LYRIC_ID_BEG, LYRIC_ID_END);
-            gchar *lyric_checksum = get_search_value(node, LYRIC_CHECKSUM_BEG, LYRIC_CHECKSUM_END);
-            if(lyric_id && lyric_checksum && strcmp(lyric_id, "0") != 0) {
-                gchar *content_url = g_strdup_printf(CL_API_GET, lyric_id, lyric_checksum);
-                GlyrMemCache *result = get_lyrics_from_results(capo->s, content_url);
-                if(result != NULL) {
-                    result_list = g_list_prepend(result_list, result);
+        gchar * artist = get_search_value (node,ARTIST_BEG,ARTIST_END);
+        gchar * title  = get_search_value (node,SONG_BEG,SONG_END);
+
+        if (levenshtein_strnormcmp (capo->s,artist,capo->s->artist) <= capo->s->fuzzyness &&
+                levenshtein_strnormcmp (capo->s,title,capo->s->title)   <= capo->s->fuzzyness)
+        {
+            gchar * lyric_id = get_search_value (node,LYRIC_ID_BEG,LYRIC_ID_END);
+            gchar * lyric_checksum = get_search_value (node,LYRIC_CHECKSUM_BEG,LYRIC_CHECKSUM_END);
+            if (lyric_id && lyric_checksum && strcmp (lyric_id,"0") != 0)
+            {
+                gchar * content_url = g_strdup_printf (CL_API_GET,lyric_id,lyric_checksum);
+                GlyrMemCache * result = get_lyrics_from_results (capo->s,content_url);
+                if (result != NULL)
+                {
+                    result_list = g_list_prepend (result_list,result);
                 }
-                g_free(content_url);
+                g_free (content_url);
             }
-            g_free(lyric_id);
-            g_free(lyric_checksum);
+            g_free (lyric_id);
+            g_free (lyric_checksum);
         }
-        g_free(artist);
-        g_free(title);
+        g_free (artist);
+        g_free (title);
     }
     return result_list;
 }
@@ -103,7 +109,8 @@ static GList *lyrics_chartlyrics_parse(cb_object *capo)
 /////////////////////////////////
 
 
-MetaDataSource lyrics_chartlyrics_src = {
+MetaDataSource lyrics_chartlyrics_src =
+{
     .name = "chartlyrics",
     .key  = 'c',
     .parser    = lyrics_chartlyrics_parse,
diff --git a/lib/intern/lyrics/elyrics.c b/lib/intern/lyrics/elyrics.c
index bfb36cb..b529e85 100644
--- a/lib/intern/lyrics/elyrics.c
+++ b/lib/intern/lyrics/elyrics.c
@@ -23,34 +23,34 @@
 /* Simple URL replace scheme - works pretty good here */
 #define ELYRICS_BASE_URL "http://www.elyrics.net/read/%c/%s-lyrics/%s-lyrics.html"
 
-static const gchar *lyrics_elyrics_url(GlyrQuery *settings)
+static const gchar * lyrics_elyrics_url (GlyrQuery * settings)
 {
-    gchar *result_url = NULL;
-
-    gchar *space_to_min_artist = strreplace(settings->artist, " ", "-");
-    gchar *space_to_min_title  = strreplace(settings->title, " ", "-");
-    if(space_to_min_artist && space_to_min_title) {
-        gchar *prep_title = NULL, * prep_artist = NULL;
-        if(settings->normalization & GLYR_NORMALIZE_ARTIST) {
-            prep_title  = prepare_string(space_to_min_title, settings->normalization, TRUE);
-        } else {
-            prep_title  = prepare_string(space_to_min_title, GLYR_NORMALIZE_NONE, TRUE);
+    gchar * result_url = NULL;
+
+    gchar * space_to_min_artist = strreplace (settings->artist," ","-");
+    gchar * space_to_min_title  = strreplace (settings->title, " ","-");
+    if (space_to_min_artist && space_to_min_title)
+    {
+        gchar * prep_title = NULL, * prep_artist = NULL;
+        if (settings->normalization & GLYR_NORMALIZE_ARTIST)
+            prep_title  = prepare_string (space_to_min_title, settings->normalization,TRUE);
+        else
+            prep_title  = prepare_string (space_to_min_title, GLYR_NORMALIZE_NONE,TRUE);
+
+        if (settings->normalization & GLYR_NORMALIZE_ARTIST)
+            prep_artist = prepare_string (space_to_min_artist, settings->normalization,TRUE);
+        else
+            prep_artist = prepare_string (space_to_min_artist, GLYR_NORMALIZE_NONE,TRUE);
+
+        if (prep_title && prep_artist)
+        {
+            result_url = g_strdup_printf (ELYRICS_BASE_URL,prep_artist[0],prep_artist,prep_title);
+            g_free (prep_title);
+            g_free (prep_artist);
         }
 
-        if(settings->normalization & GLYR_NORMALIZE_ARTIST) {
-            prep_artist = prepare_string(space_to_min_artist, settings->normalization, TRUE);
-        } else {
-            prep_artist = prepare_string(space_to_min_artist, GLYR_NORMALIZE_NONE, TRUE);
-        }
-
-        if(prep_title && prep_artist) {
-            result_url = g_strdup_printf(ELYRICS_BASE_URL, prep_artist[0], prep_artist, prep_title);
-            g_free(prep_title);
-            g_free(prep_artist);
-        }
-
-        g_free(space_to_min_artist);
-        g_free(space_to_min_title);
+        g_free (space_to_min_artist);
+        g_free (space_to_min_title);
     }
     return result_url;
 }
@@ -63,20 +63,24 @@ static const gchar *lyrics_elyrics_url(GlyrQuery *settings)
 #define BAD_STRING "Lyrics removed for copyright protection!"
 
 /* This data is separated from the actual lyrics => remove it from here */
-static void remove_from_from_string(gchar *string)
+static void remove_from_from_string (gchar * string)
 {
-    gchar *from_middle = strstr(string, FROM_MIDDLE);
-    if(from_middle != NULL) {
-        gchar *from_end = strstr(from_middle, FROM_END);
-        if(from_end != NULL) {
-            gchar *from_start = from_middle;
-            while(from_start[0] && from_start[0] != '>') {
+    gchar * from_middle = strstr (string,FROM_MIDDLE);
+    if (from_middle != NULL)
+    {
+        gchar * from_end = strstr (from_middle,FROM_END);
+        if (from_end != NULL)
+        {
+            gchar * from_start = from_middle;
+            while (from_start[0] && from_start[0] != '>')
+            {
                 from_start--;
             }
 
-            if(from_start != NULL) {
+            if (from_start != NULL)
+            {
                 gsize memlen = from_end - from_start;
-                memset(from_start, ' ', memlen);
+                memset (from_start,' ',memlen);
             }
         }
     }
@@ -88,28 +92,32 @@ static void remove_from_from_string(gchar *string)
 #define LYRICS_ALT_END "these lyrics are submitted by"
 #define LYRICS_END   "</div>"
 
-static GList *lyrics_elyrics_parse(cb_object *capo)
+static GList * lyrics_elyrics_parse (cb_object * capo)
 {
-    GList *results = NULL;
-    gchar *lyrics_begin = strstr(capo->cache->data, LYRICS_BEGIN);
-    if(lyrics_begin != NULL) {
-        if(g_strstr_len(lyrics_begin, 250, BAD_STRING) == NULL) {
-            gchar *lyrics_end = strstr(lyrics_begin, LYRICS_ALT_END);
-            if(lyrics_end == NULL) {
-                lyrics_end = strstr(lyrics_begin, LYRICS_END);
+    GList * results = NULL;
+    gchar * lyrics_begin = strstr (capo->cache->data,LYRICS_BEGIN);
+    if (lyrics_begin != NULL)
+    {
+        if (g_strstr_len (lyrics_begin,250,BAD_STRING) == NULL)
+        {
+            gchar * lyrics_end = strstr (lyrics_begin,LYRICS_ALT_END);
+            if (lyrics_end == NULL)
+            {
+                lyrics_end = strstr (lyrics_begin,LYRICS_END);
             }
 
-            if(lyrics_end != NULL) {
+            if (lyrics_end != NULL)
+            {
                 /* Modifying original buffer is allowed
                  * As long it's not saved in the result cache
                  * */
                 lyrics_end[0] = '\0';
 
-                GlyrMemCache *item = DL_init();
-                remove_from_from_string(lyrics_begin);
-                item->data = g_strdup(lyrics_begin);
+                GlyrMemCache * item = DL_init();
+                remove_from_from_string (lyrics_begin);
+                item->data = g_strdup (lyrics_begin);
                 item->size = lyrics_end - lyrics_begin;
-                results = g_list_prepend(results, item);
+                results = g_list_prepend (results,item);
             }
         }
     }
@@ -118,7 +126,8 @@ static GList *lyrics_elyrics_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource lyrics_elyrics_src = {
+MetaDataSource lyrics_elyrics_src =
+{
     .name = "elyrics",
     .key  = 'e',
     .encoding  = "LATIN1",
diff --git a/lib/intern/lyrics/lipwalk.c b/lib/intern/lyrics/lipwalk.c
index 852b634..4ea754b 100644
--- a/lib/intern/lyrics/lipwalk.c
+++ b/lib/intern/lyrics/lipwalk.c
@@ -32,31 +32,35 @@
 
 #define IS_ON_SEARCH_PAGE "<title>Search results for"
 
-static const gchar *lyrics_lipwalk_url(GlyrQuery *settings)
+static const gchar * lyrics_lipwalk_url (GlyrQuery * settings)
 {
     return LIPWALK_URL;
 }
 
 /////////////////////////////////
 
-static GlyrMemCache *parse_lyrics_page(GlyrMemCache *cache)
+static GlyrMemCache * parse_lyrics_page (GlyrMemCache * cache)
 {
-    gchar *start = NULL;
-    gchar *end = NULL;
-    gchar *content = NULL;
+    gchar * start = NULL;
+    gchar * end = NULL;
+    gchar * content = NULL;
 
-    GlyrMemCache *result_cache = NULL;
-    if(cache && (start = strstr(cache->data, START)) != NULL) {
+    GlyrMemCache * result_cache = NULL;
+    if (cache && (start = strstr (cache->data,START) ) != NULL)
+    {
         start += (sizeof START) - 1;
-        if(start && (end = strstr(start + (sizeof START) , END)) != NULL) {
-            if(ABS(end - start) > 35) {
+        if (start && (end = strstr (start + (sizeof START) ,END) ) != NULL)
+        {
+            if (ABS (end-start) > 35)
+            {
                 * (end) = 0;
-                content = strreplace(start, "<br />", NULL);
-                if(content != NULL) {
+                content = strreplace (start,"<br />",NULL);
+                if (content != NULL)
+                {
                     result_cache = DL_init();
                     result_cache->data = content;
-                    result_cache->size = strlen(content);
-                    result_cache->dsrc = g_strdup(cache->dsrc);
+                    result_cache->size = strlen (content);
+                    result_cache->dsrc = g_strdup (cache->dsrc);
                 }
             }
         }
@@ -66,19 +70,23 @@ static GlyrMemCache *parse_lyrics_page(GlyrMemCache *cache)
 
 /////////////////////////////////
 
-static gboolean validate_track_description(GlyrQuery *query, gchar *description)
+static gboolean validate_track_description (GlyrQuery * query, gchar * description)
 {
     gboolean result = FALSE;
-    if(description != NULL) {
-        gchar **splitv = g_strsplit(description, " - ", 0);
-        if(splitv != NULL) {
-            if(splitv[0] && splitv[1] != NULL) {
-                if(levenshtein_strnormcmp(query, query->artist, splitv[0]) <= query->fuzzyness
-                        && levenshtein_strnormcmp(query, query->title, splitv[1]) <= query->fuzzyness) {
+    if (description != NULL)
+    {
+        gchar ** splitv = g_strsplit (description," - ",0);
+        if (splitv != NULL)
+        {
+            if (splitv[0] && splitv[1] != NULL)
+            {
+                if (levenshtein_strnormcmp (query,query->artist,splitv[0]) <= query->fuzzyness
+                        && levenshtein_strnormcmp (query,query->title, splitv[1]) <= query->fuzzyness)
+                {
                     result = TRUE;
                 }
             }
-            g_strfreev(splitv);
+            g_strfreev (splitv);
         }
     }
     return result;
@@ -86,38 +94,47 @@ static gboolean validate_track_description(GlyrQuery *query, gchar *description)
 
 /////////////////////////////////
 
-static GList *lyrics_lipwalk_parse(cb_object *capo)
+static GList * lyrics_lipwalk_parse (cb_object *capo)
 {
-    GList *result_list  = NULL;
-    if(strstr(capo->cache->data, IS_ON_SEARCH_PAGE) == NULL) {
-        GlyrMemCache *result_cache = parse_lyrics_page(capo->cache);
-        result_list = g_list_prepend(result_list, result_cache);
-    } else { /* Oops, we're on the search results page, things are complicated now */
+    GList * result_list  = NULL;
+    if (strstr (capo->cache->data,IS_ON_SEARCH_PAGE) == NULL)
+    {
+        GlyrMemCache * result_cache = parse_lyrics_page (capo->cache);
+        result_list = g_list_prepend (result_list,result_cache);
+    }
+    else /* Oops, we're on the search results page, things are complicated now */
+    {
         /* Happens with "In Flames" - "Trigger" e.g.                          */
-        gchar *search_node = capo->cache->data;
+        gchar * search_node = capo->cache->data;
         gsize track_len = (sizeof TRACK_BEGIN) - 1;
-        while(continue_search(g_list_length(result_list), capo->s) && (search_node = strstr(search_node + track_len, TRACK_BEGIN))) {
+        while (continue_search (g_list_length (result_list),capo->s) && (search_node = strstr (search_node + track_len,TRACK_BEGIN) ) )
+        {
             search_node += track_len;
-            gchar *track_end = strstr(search_node, TRACK_ENDIN);
-            if(track_end != NULL) {
-                gchar *lyrics_url = copy_value(search_node, track_end);
-                if(lyrics_url != NULL) {
+            gchar * track_end = strstr (search_node,TRACK_ENDIN);
+            if (track_end != NULL)
+            {
+                gchar * lyrics_url = copy_value (search_node,track_end);
+                if (lyrics_url != NULL)
+                {
                     track_end += (sizeof TRACK_ENDIN) - 1;
-                    gchar *track_descr = copy_value(track_end, strstr(track_end, TRACK_DESCR));
-                    if(track_descr != NULL && validate_track_description(capo->s, track_descr) == TRUE) {
-                        gchar *full_url = g_strdup_printf("%s%s", LIPWALK_DOMAIN, lyrics_url);
-                        GlyrMemCache *lyrics_page = download_single(full_url, capo->s, NULL);
-                        if(lyrics_page != NULL) {
-                            GlyrMemCache *result_cache = parse_lyrics_page(lyrics_page);
-                            if(result_cache != NULL) {
-                                result_list = g_list_prepend(result_list, result_cache);
+                    gchar * track_descr = copy_value (track_end,strstr (track_end,TRACK_DESCR) );
+                    if (track_descr != NULL && validate_track_description (capo->s,track_descr) == TRUE)
+                    {
+                        gchar * full_url = g_strdup_printf ("%s%s",LIPWALK_DOMAIN,lyrics_url);
+                        GlyrMemCache * lyrics_page = download_single (full_url,capo->s,NULL);
+                        if (lyrics_page != NULL)
+                        {
+                            GlyrMemCache * result_cache = parse_lyrics_page (lyrics_page);
+                            if (result_cache != NULL)
+                            {
+                                result_list = g_list_prepend (result_list,result_cache);
                             }
-                            DL_free(lyrics_page);
+                            DL_free (lyrics_page);
                         }
-                        g_free(track_descr);
-                        g_free(full_url);
+                        g_free (track_descr);
+                        g_free (full_url);
                     }
-                    g_free(lyrics_url);
+                    g_free (lyrics_url);
                 }
             }
         }
@@ -127,7 +144,8 @@ static GList *lyrics_lipwalk_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource lyrics_lipwalk_src = {
+MetaDataSource lyrics_lipwalk_src =
+{
     .name = "lipwalk",
     .key  = 'z',
     .parser    = lyrics_lipwalk_parse,
diff --git a/lib/intern/lyrics/lyrdb.c b/lib/intern/lyrics/lyrdb.c
index cb5a719..08514a6 100644
--- a/lib/intern/lyrics/lyrdb.c
+++ b/lib/intern/lyrics/lyrdb.c
@@ -24,48 +24,54 @@
 
 /////////////////////////////////
 
-static const char *lyrics_lyrdb_url(GlyrQuery *settings)
+static const char * lyrics_lyrdb_url (GlyrQuery * settings)
 {
     return LYRDB_URL;
 }
 
 /////////////////////////////////
 
-static GList *lyrics_lyrdb_parse(cb_object *capo)
+static GList * lyrics_lyrdb_parse (cb_object * capo)
 {
     gchar *slash = NULL;
-    GList *result_list = NULL;
+    GList * result_list = NULL;
 
-    if((slash = strchr(capo->cache->data, '\\')) != NULL) {
-        gchar *uID = copy_value(capo->cache->data, slash);
-        if(uID != NULL) {
-            gchar *lyr_url = g_strdup_printf("http://webservices.lyrdb.com/getlyr.php?q=%s", uID);
-            if(lyr_url != NULL) {
-                GlyrMemCache *new_cache = download_single(lyr_url, capo->s, NULL);
-                if(new_cache != NULL) {
+    if ( (slash = strchr (capo->cache->data,'\\') ) != NULL)
+    {
+        gchar * uID = copy_value (capo->cache->data,slash);
+        if (uID != NULL)
+        {
+            gchar * lyr_url = g_strdup_printf ("http://webservices.lyrdb.com/getlyr.php?q=%s",uID);
+            if (lyr_url != NULL)
+            {
+                GlyrMemCache * new_cache = download_single (lyr_url,capo->s,NULL);
+                if (new_cache != NULL)
+                {
                     gsize i = 0;
-                    gchar *buffer = g_malloc0(new_cache->size + 1);
-                    for(i = 0; i < new_cache->size; i++) {
+                    gchar * buffer = g_malloc0 (new_cache->size + 1);
+                    for (i = 0; i < new_cache->size; i++)
+                    {
                         buffer[i] = (new_cache->data[i] == '\r') ?
                                     ' ' :
                                     new_cache->data[i];
                     }
                     buffer[i] = 0;
 
-                    if(i != 0) {
-                        GlyrMemCache *result = DL_init();
+                    if (i != 0)
+                    {
+                        GlyrMemCache * result = DL_init();
                         result->data = buffer;
                         result->size = i;
-                        result->dsrc = g_strdup(lyr_url);
+                        result->dsrc = g_strdup (lyr_url);
 
-                        result_list = g_list_prepend(result_list, result);
+                        result_list = g_list_prepend (result_list,result);
                     }
 
-                    DL_free(new_cache);
+                    DL_free (new_cache);
                 }
-                g_free(lyr_url);
+                g_free (lyr_url);
             }
-            g_free(uID);
+            g_free (uID);
         }
     }
     return result_list;
@@ -73,7 +79,8 @@ static GList *lyrics_lyrdb_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource lyrics_lyrdb_src = {
+MetaDataSource lyrics_lyrdb_src =
+{
     .name = "lyrdb",
     .key  = 'd',
     .encoding  = "LATIN1",
diff --git a/lib/intern/lyrics/lyricsreg.c b/lib/intern/lyrics/lyricsreg.c
index a9dfe96..1891b53 100644
--- a/lib/intern/lyrics/lyricsreg.c
+++ b/lib/intern/lyrics/lyricsreg.c
@@ -23,30 +23,34 @@
 #define INFO_BEGIN "</div><div style=\"text-align:center;\">"
 #define INFO_ENDIN " <a href=\""
 
-static const char *lyrics_lyricsreg_url(GlyrQuery *s)
+static const char * lyrics_lyricsreg_url (GlyrQuery * s)
 {
     return "http://www.lyricsreg.com/lyrics/${artist}/${title}/";
 }
 
-static GList *lyrics_lyricsreg_parse(cb_object *capo)
+static GList * lyrics_lyricsreg_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *start = strstr(capo->cache->data, INFO_BEGIN);
+    GList * result_list = NULL;
+    gchar * start = strstr (capo->cache->data, INFO_BEGIN);
 
-    if(start != NULL) {
+    if (start != NULL)
+    {
         start += (sizeof INFO_BEGIN) - 1;
-        gchar *end = strstr(start, INFO_ENDIN);
-        if(end != NULL) {
+        gchar * end = strstr (start,INFO_ENDIN);
+        if (end != NULL)
+        {
             * (end) = 0;
-            gchar *no_br_tags = strreplace(start, "<br />", NULL);
-            if(no_br_tags != NULL) {
-                GlyrMemCache *tmp = DL_init();
-                tmp->data = beautify_string(no_br_tags);
-                tmp->size = tmp->data ? strlen(tmp->data) : 0;
-                g_free(no_br_tags);
+            gchar * no_br_tags = strreplace (start,"<br />",NULL);
+            if (no_br_tags != NULL)
+            {
+                GlyrMemCache * tmp = DL_init();
+                tmp->data = beautify_string (no_br_tags);
+                tmp->size = tmp->data ? strlen (tmp->data) : 0;
+                g_free (no_br_tags);
 
-                if(tmp->data != NULL) {
-                    result_list = g_list_prepend(result_list, tmp);
+                if (tmp->data != NULL)
+                {
+                    result_list = g_list_prepend (result_list,tmp);
                 }
             }
         }
@@ -56,7 +60,8 @@ static GList *lyrics_lyricsreg_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource lyrics_lyricsreg_src = {
+MetaDataSource lyrics_lyricsreg_src =
+{
     .name = "lyricsreg",
     .key  = 'r',
     .parser    = lyrics_lyricsreg_parse,
diff --git a/lib/intern/lyrics/lyricstime.c b/lib/intern/lyrics/lyricstime.c
index 2f3d76d..ef091a9 100644
--- a/lib/intern/lyrics/lyricstime.c
+++ b/lib/intern/lyrics/lyricstime.c
@@ -24,7 +24,7 @@
 
 /////////////////////////////////
 
-static const char *lyrics_lyricstime_url(GlyrQuery *settings)
+static const char * lyrics_lyricstime_url (GlyrQuery * settings)
 {
     return GLYR_GET_URL;
 }
@@ -34,24 +34,28 @@ static const char *lyrics_lyricstime_url(GlyrQuery *settings)
 #define LYR_BEGIN "<div id=\"songlyrics\" >"
 #define LYR_ENDIN "</div>"
 
-static GlyrMemCache *parse_page(GlyrMemCache *dl, cb_object *capo)
+static GlyrMemCache * parse_page (GlyrMemCache * dl, cb_object * capo)
 {
-    GlyrMemCache *result = NULL;
-    if(dl != NULL) {
-        gchar *begin = strstr(dl->data, LYR_BEGIN);
-        if(begin != NULL) {
+    GlyrMemCache * result = NULL;
+    if (dl != NULL)
+    {
+        gchar * begin = strstr (dl->data,LYR_BEGIN);
+        if (begin != NULL)
+        {
             begin += (sizeof LYR_BEGIN) - 1;
-            gchar *end = strstr(begin, LYR_ENDIN);
-            if(end != NULL) {
+            gchar * end = strstr (begin,LYR_ENDIN);
+            if (end != NULL)
+            {
                 * (end) = 0;
-                gchar *no_br_tags = strreplace(begin, "<br />", NULL);
-                if(no_br_tags != NULL) {
+                gchar * no_br_tags = strreplace (begin,"<br />",NULL);
+                if (no_br_tags != NULL)
+                {
                     result = DL_init();
-                    result->data = beautify_string(no_br_tags);
-                    result->size = (result->data) ? strlen(result->data) : 0;
-                    result->dsrc = g_strdup(dl->dsrc);
+                    result->data = beautify_string (no_br_tags);
+                    result->size = (result->data) ? strlen (result->data) : 0;
+                    result->dsrc = g_strdup (dl->dsrc);
 
-                    g_free(no_br_tags);
+                    g_free (no_br_tags);
                 }
             }
         }
@@ -69,23 +73,29 @@ static GlyrMemCache *parse_page(GlyrMemCache *dl, cb_object *capo)
 #define ARTIST_BEG "<b>"
 #define ARTIST_END "</b>"
 
-static gboolean validate_artist(cb_object *capo, gchar *backpointer)
+static gboolean validate_artist (cb_object * capo, gchar * backpointer)
 {
     gboolean i_shall_continue = false;
-    if(backpointer != NULL) {
-        char *span = strstr(backpointer, SPAN_BEGIN);
-        if(span != NULL) {
-            gchar *artist_beg = strstr(span, ARTIST_BEG);
-            if(artist_beg != NULL) {
+    if (backpointer != NULL)
+    {
+        char * span = strstr (backpointer,SPAN_BEGIN);
+        if (span != NULL)
+        {
+            gchar * artist_beg = strstr (span,ARTIST_BEG);
+            if (artist_beg != NULL)
+            {
                 artist_beg += (sizeof ARTIST_BEG) - 1;
-                gchar *artist_end = strstr(artist_beg, ARTIST_END);
-                if(artist_end != NULL) {
-                    gchar *artist_val = copy_value(artist_beg, artist_end);
-                    if(artist_val != NULL) {
-                        if(levenshtein_strnormcmp(capo->s, artist_val, capo->s->artist) <= capo->s->fuzzyness) {
+                gchar * artist_end = strstr (artist_beg,ARTIST_END);
+                if (artist_end != NULL)
+                {
+                    gchar * artist_val = copy_value (artist_beg,artist_end);
+                    if (artist_val != NULL)
+                    {
+                        if (levenshtein_strnormcmp (capo->s,artist_val,capo->s->artist) <= capo->s->fuzzyness)
+                        {
                             i_shall_continue = true;
                         }
-                        g_free(artist_val);
+                        g_free (artist_val);
                     }
                 }
             }
@@ -96,37 +106,43 @@ static gboolean validate_artist(cb_object *capo, gchar *backpointer)
 
 /////////////////////////////////
 
-static GList *lyrics_lyricstime_parse(cb_object *capo)
+static GList * lyrics_lyricstime_parse (cb_object * capo)
 {
-    GList *rList = NULL;
-    char *start = capo->cache->data;
-    if(start != NULL) {
-        gchar *div_end = strstr(start, SEARCH_ENDIN);
-        gchar *node = capo->cache->data;
-        gchar *backpointer = node;
+    GList * rList = NULL;
+    char * start = capo->cache->data;
+    if (start != NULL)
+    {
+        gchar * div_end = strstr (start,SEARCH_ENDIN);
+        gchar * node = capo->cache->data;
+        gchar * backpointer = node;
         gsize nlen = (sizeof NODE_BEGIN) - 1;
 
-        while(continue_search(g_list_length(rList), capo->s) && (node = strstr(node + nlen, NODE_BEGIN)) != NULL) {
-            if(div_end >= node) {
+        while (continue_search (g_list_length (rList),capo->s) && (node = strstr (node+nlen,NODE_BEGIN) ) != NULL)
+        {
+            if (div_end >= node)
                 break;
-            }
 
-            if(validate_artist(capo, backpointer) == TRUE) {
-                gchar *end_of_url = strstr(node + nlen, NODE_ENDIN);
-                if(end_of_url != NULL) {
-                    gchar *url = copy_value(node + nlen, end_of_url);
-                    if(url != NULL) {
-                        gchar *full_url = g_strdup_printf("http://www.lyricstime.com%s", url);
-                        GlyrMemCache *dl_cache = download_single(full_url, capo->s, NULL);
-                        if(dl_cache) {
-                            GlyrMemCache *parsed_cache = parse_page(dl_cache, capo);
-                            if(parsed_cache != NULL) {
-                                rList = g_list_prepend(rList, parsed_cache);
+            if (validate_artist (capo,backpointer) == TRUE)
+            {
+                gchar * end_of_url = strstr (node+nlen,NODE_ENDIN);
+                if (end_of_url != NULL)
+                {
+                    gchar * url = copy_value (node+nlen,end_of_url);
+                    if (url != NULL)
+                    {
+                        gchar * full_url = g_strdup_printf ("http://www.lyricstime.com%s",url);
+                        GlyrMemCache * dl_cache = download_single (full_url,capo->s,NULL);
+                        if (dl_cache)
+                        {
+                            GlyrMemCache * parsed_cache = parse_page (dl_cache,capo);
+                            if (parsed_cache != NULL)
+                            {
+                                rList = g_list_prepend (rList,parsed_cache);
                             }
-                            DL_free(dl_cache);
-                            g_free(full_url);
+                            DL_free (dl_cache);
+                            g_free (full_url);
                         }
-                        g_free(url);
+                        g_free (url);
                     }
                 }
             }
@@ -138,7 +154,8 @@ static GList *lyrics_lyricstime_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource lyrics_lyricstime_src = {
+MetaDataSource lyrics_lyricstime_src =
+{
     .name = "lyricstime",
     .key  = 'y',
     .parser    = lyrics_lyricstime_parse,
diff --git a/lib/intern/lyrics/lyricsvip.c b/lib/intern/lyrics/lyricsvip.c
index 6655ae6..2765611 100644
--- a/lib/intern/lyrics/lyricsvip.c
+++ b/lib/intern/lyrics/lyricsvip.c
@@ -24,21 +24,23 @@
 
 /////////////////////////////////
 
-static const gchar *lyrics_lyricsvip_url(GlyrQuery *settings)
+static const gchar * lyrics_lyricsvip_url (GlyrQuery * settings)
 {
-    gchar *result = NULL;
-    gchar *artist_clean = strreplace(settings->artist, " ", "-");
-    if(artist_clean != NULL) {
-        gchar *title_clean =  strreplace(settings->title, " ", "-");
-        if(title_clean != NULL) {
-            gchar *prep_artist = curl_easy_escape(NULL, artist_clean, 0);
-            gchar *prep_title  = curl_easy_escape(NULL, title_clean, 0);
-            result = g_strdup_printf(LV_URL, prep_artist, prep_title);
-            g_free(title_clean);
-            curl_free(prep_artist);
-            curl_free(prep_title);
+    gchar * result = NULL;
+    gchar * artist_clean = strreplace (settings->artist, " ", "-");
+    if (artist_clean != NULL)
+    {
+        gchar * title_clean =  strreplace (settings->title, " ", "-");
+        if (title_clean != NULL)
+        {
+            gchar * prep_artist = curl_easy_escape (NULL,artist_clean,0);
+            gchar * prep_title  = curl_easy_escape (NULL,title_clean,0);
+            result = g_strdup_printf (LV_URL, prep_artist, prep_title);
+            g_free (title_clean);
+            curl_free (prep_artist);
+            curl_free (prep_title);
         }
-        g_free(artist_clean);
+        g_free (artist_clean);
     }
     return result;
 }
@@ -48,24 +50,28 @@ static const gchar *lyrics_lyricsvip_url(GlyrQuery *settings)
 #define BEG "<img src=\"http://www.lyricsvip.com/images/phone2.gif\" alt=\"phone\" /></div>"
 #define END "<br />\n<div class=\"ad\">"
 
-static GList *lyrics_lyricsvip_parse(cb_object *capo)
+static GList * lyrics_lyricsvip_parse (cb_object *capo)
 {
-    gchar *start = NULL;
-    gchar *end = NULL;
-    gchar *content = NULL;
-    GList *result_list  = NULL;
+    gchar * start = NULL;
+    gchar * end = NULL;
+    gchar * content = NULL;
+    GList * result_list  = NULL;
 
-    if((start = strstr(capo->cache->data, BEG)) != NULL) {
-        if((end = strstr(start, END)) != NULL) {
-            if(ABS(end - start) > 0) {
+    if ( (start = strstr (capo->cache->data,BEG) ) != NULL)
+    {
+        if ( (end = strstr (start,END) ) != NULL)
+        {
+            if (ABS (end-start) > 0)
+            {
                 * (end) = 0;
 
-                content = strreplace(start, "<br />", "");
-                if(content) {
-                    GlyrMemCache *result = DL_init();
+                content = strreplace (start,"<br />","");
+                if (content)
+                {
+                    GlyrMemCache * result = DL_init();
                     result->data = content;
-                    result->size = strlen(content);
-                    result_list = g_list_prepend(result_list, result);
+                    result->size = strlen (content);
+                    result_list = g_list_prepend (result_list,result);
                 }
             }
         }
@@ -75,7 +81,8 @@ static GList *lyrics_lyricsvip_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource lyrics_lyricsvip_src = {
+MetaDataSource lyrics_lyricsvip_src =
+{
     .name = "lyricsvip",
     .key  = 'v',
     .parser    = lyrics_lyricsvip_parse,
diff --git a/lib/intern/lyrics/lyricswiki.c b/lib/intern/lyrics/lyricswiki.c
index ec8ad9e..8943133 100644
--- a/lib/intern/lyrics/lyricswiki.c
+++ b/lib/intern/lyrics/lyricswiki.c
@@ -27,7 +27,7 @@
 
 /////////////////////////////////
 
-static const gchar *lyrics_lyricswiki_url(GlyrQuery *settings)
+static const gchar * lyrics_lyricswiki_url (GlyrQuery * settings)
 {
     return LW_URL;
 }
@@ -35,22 +35,26 @@ static const gchar *lyrics_lyricswiki_url(GlyrQuery *settings)
 /////////////////////////////////
 
 // Compare response, so lyricswiki's search did not fool us
-static gboolean lv_cmp_content(const gchar *to_artist, const gchar *to_title, cb_object *capo)
+static gboolean lv_cmp_content (const gchar * to_artist, const gchar * to_title, cb_object * capo)
 {
     gboolean res = false;
-    if(to_artist && to_title && capo) {
-        gchar *tmp_artist = copy_value(to_artist, strstr(to_artist, "</artist>"));
-        if(tmp_artist != NULL) {
-            gchar *tmp_title = copy_value(to_title, strstr(to_title , "</song>"));
-            if(tmp_title != NULL) {
+    if (to_artist && to_title && capo)
+    {
+        gchar * tmp_artist = copy_value (to_artist,strstr (to_artist,"</artist>") );
+        if (tmp_artist != NULL)
+        {
+            gchar * tmp_title = copy_value (to_title, strstr (to_title ,"</song>" ) );
+            if (tmp_title != NULL)
+            {
                 /* levenshtein_strnormcmp takes care of those brackets */
-                if((levenshtein_strnormcmp(capo->s, capo->s->artist, tmp_artist) <= capo->s->fuzzyness &&
-                        levenshtein_strnormcmp(capo->s, capo->s->title, tmp_title)  <= capo->s->fuzzyness)) {
+                if ( (levenshtein_strnormcmp (capo->s,capo->s->artist,tmp_artist) <= capo->s->fuzzyness &&
+                        levenshtein_strnormcmp (capo->s,capo->s->title, tmp_title)  <= capo->s->fuzzyness ) )
+                {
                     res = true;
                 }
-                g_free(tmp_title);
+                g_free (tmp_title);
             }
-            g_free(tmp_artist);
+            g_free (tmp_artist);
         }
     }
     return res;
@@ -64,51 +68,58 @@ static gboolean lv_cmp_content(const gchar *to_artist, const gchar *to_title, cb
 #define LYR_ENDIN "<!--"
 #define LYR_INSTRUMENTAL "/Category:Instrumental"
 
-GList *parse_result_page(GlyrQuery *query, GlyrMemCache *to_parse)
+GList * parse_result_page (GlyrQuery * query, GlyrMemCache * to_parse)
 {
-    GList *result_list = NULL;
-    gchar *node = to_parse->data;
-    while(continue_search(g_list_length(result_list), query) && (node = strstr(node, LYR_NODE))) {
+    GList * result_list = NULL;
+    gchar * node = to_parse->data;
+    while (continue_search (g_list_length (result_list),query) && (node = strstr (node,LYR_NODE) ) )
+    {
         node += (sizeof LYR_NODE);
 
         bool is_instrumental = strstr(node, LYR_INSTRUMENTAL) != NULL;
-        gchar *lyr = get_search_value(node, LYR_BEGIN, LYR_ENDIN);
-        gchar *beautiness_test = beautify_string(lyr);
-        if(is_instrumental || (beautiness_test != NULL && beautiness_test[0])) {
-            if(is_instrumental || (lyr != NULL && strstr(lyr, BAD_STRING) == NULL && strstr(lyr, EXTERNAL_LINKS) == NULL)) {
-                GlyrMemCache *result = DL_init();
-                if(is_instrumental) {
+        gchar * lyr = get_search_value (node,LYR_BEGIN,LYR_ENDIN);
+        gchar * beautiness_test = beautify_string (lyr);
+        if (is_instrumental || (beautiness_test != NULL && beautiness_test[0]))
+        {
+            if (is_instrumental || (lyr != NULL && strstr (lyr,BAD_STRING) == NULL && strstr (lyr,EXTERNAL_LINKS) == NULL))
+            {
+                GlyrMemCache * result = DL_init();
+                if(is_instrumental) 
                     result->data = g_strdup("Instrumental");
-                } else {
+                else
                     result->data = lyr;
-                }
 
-                result->size = strlen(result->data);
-                result->dsrc = g_strdup(to_parse->dsrc);
-                result_list  = g_list_prepend(result_list, result);
+                result->size = strlen (result->data);
+                result->dsrc = g_strdup (to_parse->dsrc);
+                result_list  = g_list_prepend (result_list,result);
             }
-        } else {
-            g_free(lyr);
         }
-        g_free(beautiness_test);
+        else
+        {
+            g_free (lyr);
+        }
+        g_free (beautiness_test);
     }
     return result_list;
 }
 
 /////////////////////////////////
 
-static GList *lyrics_lyricswiki_parse(cb_object *capo)
+static GList * lyrics_lyricswiki_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    if(strstr(capo->cache->data, NOT_FOUND) == NULL && lv_cmp_content(strstr(capo->cache->data, "<artist>"), strstr(capo->cache->data, "<song>"), capo)) {
-        gchar *wiki_page_url = get_search_value(capo->cache->data, "<url>", "</url>");
-        if(wiki_page_url != NULL) {
-            GlyrMemCache *new_cache = download_single(wiki_page_url, capo->s, NULL);
-            if(new_cache != NULL) {
-                result_list = parse_result_page(capo->s, new_cache);
-                DL_free(new_cache);
+    GList * result_list = NULL;
+    if (strstr (capo->cache->data,NOT_FOUND) == NULL && lv_cmp_content (strstr (capo->cache->data,"<artist>"),strstr (capo->cache->data,"<song>"),capo) )
+    {
+        gchar * wiki_page_url = get_search_value (capo->cache->data,"<url>","</url>");
+        if (wiki_page_url != NULL)
+        {
+            GlyrMemCache * new_cache = download_single (wiki_page_url,capo->s,NULL);
+            if (new_cache != NULL)
+            {
+                result_list = parse_result_page (capo->s,new_cache);
+                DL_free (new_cache);
             }
-            g_free(wiki_page_url);
+            g_free (wiki_page_url);
         }
     }
     return result_list;
@@ -116,7 +127,8 @@ static GList *lyrics_lyricswiki_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource lyrics_lyricswiki_src = {
+MetaDataSource lyrics_lyricswiki_src =
+{
     .name = "lyricswiki",
     .key  = 'w',
     .parser    = lyrics_lyricswiki_parse,
diff --git a/lib/intern/lyrics/lyrix_at.c b/lib/intern/lyrics/lyrix_at.c
index 3e604f2..244569d 100644
--- a/lib/intern/lyrics/lyrix_at.c
+++ b/lib/intern/lyrics/lyrix_at.c
@@ -20,9 +20,9 @@
 #include "../../core.h"
 #include "../../stringlib.h"
 
-#define AT_URL "http://lyrix.at/lyrics-search/s-${artist}, ${title}, any, 321, .html"
+#define AT_URL "http://lyrix.at/lyrics-search/s-${artist},,${title},,any,1321,0.html"
 
-const char *lyrics_lyrixat_url(GlyrQuery *settings)
+const char * lyrics_lyrixat_url (GlyrQuery * settings)
 {
     return AT_URL;
 }
@@ -38,59 +38,70 @@ const char *lyrics_lyrixat_url(GlyrQuery *settings)
 
 /////////////////////////////////
 
-static void parse_lyrics_page(const gchar *url, GList **result_list, cb_object *capo)
+static void parse_lyrics_page (const gchar * url, GList ** result_list, cb_object * capo)
 {
-    GlyrMemCache *lyrcache = download_single(url, capo->s, "<!-- eBay Relevance Ad -->");
-    if(lyrcache != NULL) {
-        gchar *lyr_begin = strstr(lyrcache->data, LYRIC_BEGIN);
-        if(lyr_begin != NULL) {
-            gchar *lyr_endin = strstr(lyr_begin, "</div>");
-            if(lyr_endin != NULL) {
-                gchar *lyrics = copy_value(lyr_begin, lyr_endin);
-                if(lyrics != NULL) {
-                    GlyrMemCache *result = DL_init();
-                    result->data = strreplace(lyrics, "<br />", "");
-                    result->size = strlen(result->data);
-                    result->dsrc = g_strdup(url);
-                    *result_list = g_list_prepend(*result_list, result);
+    GlyrMemCache * lyrcache = download_single (url,capo->s,"<!-- eBay Relevance Ad -->");
+    if (lyrcache != NULL)
+    {
+        gchar * lyr_begin = strstr (lyrcache->data,LYRIC_BEGIN);
+        if (lyr_begin != NULL)
+        {
+            gchar * lyr_endin = strstr (lyr_begin,"</div>");
+            if (lyr_endin != NULL)
+            {
+                gchar * lyrics = copy_value (lyr_begin,lyr_endin);
+                if (lyrics != NULL)
+                {
+                    GlyrMemCache * result = DL_init();
+                    result->data = strreplace (lyrics,"<br />","");
+                    result->size = strlen (result->data);
+                    result->dsrc = g_strdup (url);
+                    *result_list = g_list_prepend (*result_list,result);
                 }
-                g_free(lyrics);
+                g_free (lyrics);
             }
         }
-        DL_free(lyrcache);
+        DL_free (lyrcache);
     }
 }
 
 /////////////////////////////////
 
-GList *lyrics_lyrixat_parse(cb_object *capo)
+GList * lyrics_lyrixat_parse (cb_object * capo)
 {
     /* lyrix.at does not offer any webservice -> use the searchfield to get some results */
-    GList *result_list = NULL;
-    gchar *search_begin_tag = capo->cache->data;
+    GList * result_list = NULL;
+    gchar * search_begin_tag = capo->cache->data;
     gint ctr = 0;
 
-    while(continue_search(g_list_length(result_list), capo->s) && (search_begin_tag = strstr(search_begin_tag + 1, SEARCH_START_TAG)) && MAX_TRIES >= ctr++) {
-        gchar *url_tag = search_begin_tag;
-        url_tag = strstr(url_tag, URL_TAG_BEGIN);
-        if(url_tag != NULL) {
-            gchar *title_tag = strstr(url_tag, URL_TAG_ENDIN);
-            if(title_tag) {
-                gchar *title_end = strstr(title_tag, TITLE_END);
-                if(title_end != NULL) {
+    while (continue_search (g_list_length (result_list),capo->s) && (search_begin_tag = strstr (search_begin_tag+1,SEARCH_START_TAG) ) && MAX_TRIES >= ctr++)
+    {
+        gchar * url_tag = search_begin_tag;
+        url_tag = strstr (url_tag,URL_TAG_BEGIN);
+        if (url_tag != NULL)
+        {
+            gchar * title_tag = strstr (url_tag,URL_TAG_ENDIN);
+            if (title_tag)
+            {
+                gchar * title_end = strstr (title_tag,TITLE_END);
+                if (title_end != NULL)
+                {
                     gsize tag_end_len = (sizeof URL_TAG_ENDIN) - 1;
-                    gchar *title = copy_value(title_tag + tag_end_len, title_end);
-                    if(title != NULL) {
-                        if(levenshtein_strnormcmp(capo->s, title, capo->s->title) <= capo->s->fuzzyness) {
-                            gchar *url_part = copy_value(url_tag + strlen(URL_TAG_BEGIN), title_tag);
-                            if(url_part != NULL) {
-                                gchar *url = g_strdup_printf("http://lyrix.at/de%s", url_part);
-                                parse_lyrics_page(url, &result_list, capo);
-                                g_free(url);
-                                g_free(url_part);
+                    gchar * title = copy_value (title_tag + tag_end_len,title_end);
+                    if (title != NULL)
+                    {
+                        if (levenshtein_strnormcmp (capo->s,title,capo->s->title) <= capo->s->fuzzyness)
+                        {
+                            gchar * url_part = copy_value (url_tag+strlen (URL_TAG_BEGIN),title_tag);
+                            if (url_part != NULL)
+                            {
+                                gchar * url = g_strdup_printf ("http://lyrix.at/de%s",url_part);
+                                parse_lyrics_page (url,&result_list,capo);
+                                g_free (url);
+                                g_free (url_part);
                             }
                         }
-                        g_free(title);
+                        g_free (title);
                     }
                 }
             }
@@ -100,7 +111,8 @@ GList *lyrics_lyrixat_parse(cb_object *capo)
 }
 /////////////////////////////////
 
-MetaDataSource lyrics_lyrix_src = {
+MetaDataSource lyrics_lyrix_src =
+{
     .name = "lyrix",
     .key  = 'a',
     .parser    = lyrics_lyrixat_parse,
diff --git a/lib/intern/lyrics/magistrix.c b/lib/intern/lyrics/magistrix.c
index 71a7ab1..46cb465 100644
--- a/lib/intern/lyrics/magistrix.c
+++ b/lib/intern/lyrics/magistrix.c
@@ -22,25 +22,26 @@
 
 #define MG_URL "http://www.magistrix.de/lyrics/search?q=${artist}+${title}"
 
-static const char *lyrics_magistrix_url(GlyrQuery *settings)
+static const char * lyrics_magistrix_url (GlyrQuery * settings)
 {
     return MG_URL;
 }
 
 ///////////////////////////////////
 
-static GlyrMemCache *parse_lyric_page(GlyrMemCache *cache)
+static GlyrMemCache * parse_lyric_page (GlyrMemCache * cache)
 {
-    GlyrMemCache *result = NULL;
-    g_return_val_if_fail(cache, NULL);
-    g_return_val_if_fail(cache->data, NULL);
+    GlyrMemCache * result = NULL;
+    g_return_val_if_fail (cache,NULL);
+    g_return_val_if_fail (cache->data,NULL);
 
-    gchar *data = get_search_value(cache->data, "id='songtext'>", "<div class='lyric-actions'>");
-    if(data != NULL) {
+    gchar * data = get_search_value (cache->data,"id='songtext'>","<div class='lyric-actions'>");
+    if (data != NULL)
+    {
         result = DL_init();
         result->data = data;
-        result->size = strlen(data);
-        result->dsrc = g_strdup(cache->dsrc);
+        result->size = strlen (data);
+        result->dsrc = g_strdup (cache->dsrc);
     }
 
     return result;
@@ -54,29 +55,35 @@ static GlyrMemCache *parse_lyric_page(GlyrMemCache *cache)
 #define SEARCH_LINK_START "&ndash;\n<a href=\""
 #define SEARCH_LINK_END   "\" class"
 
-static GList *parse_search_result_page(cb_object *capo)
+static GList * parse_search_result_page (cb_object * capo)
 {
-    GList *result_list = NULL;
-    char *first_result = strstr(capo->cache->data, SEARCH_FIRST_RESULT);
-    if(first_result != NULL) {
-        char *end_of_results = strstr(first_result + sizeof(SEARCH_FIRST_RESULT), SEARCH_LAST_RESULT);
-        if(end_of_results) {
-            char *node = first_result;
-            while((node = strstr(node + sizeof(SEARCH_NODE), SEARCH_NODE))
-                    && continue_search(g_list_length(result_list), capo->s)) {
-                char *new_url = get_search_value(node, SEARCH_LINK_START, SEARCH_LINK_END);
-                if(new_url != NULL) {
-                    char *full_url = g_strdup_printf("www.magistrix.de%s", new_url);
-                    GlyrMemCache *lyrics_page = download_single(full_url, capo->s, NULL);
-                    if(lyrics_page) {
-                        GlyrMemCache *item = parse_lyric_page(lyrics_page);
-                        if(item != NULL) {
-                            result_list = g_list_prepend(result_list, item);
+    GList * result_list = NULL;
+    char * first_result = strstr (capo->cache->data, SEARCH_FIRST_RESULT);
+    if (first_result != NULL)
+    {
+        char * end_of_results = strstr (first_result + sizeof (SEARCH_FIRST_RESULT), SEARCH_LAST_RESULT);
+        if (end_of_results)
+        {
+            char * node = first_result;
+            while ( (node = strstr (node + sizeof (SEARCH_NODE), SEARCH_NODE) )
+                    && continue_search (g_list_length (result_list), capo->s) )
+            {
+                char * new_url = get_search_value (node, SEARCH_LINK_START, SEARCH_LINK_END);
+                if (new_url != NULL)
+                {
+                    char * full_url = g_strdup_printf ("www.magistrix.de%s", new_url);
+                    GlyrMemCache * lyrics_page = download_single (full_url, capo->s, NULL);
+                    if (lyrics_page)
+                    {
+                        GlyrMemCache * item = parse_lyric_page (lyrics_page);
+                        if (item != NULL)
+                        {
+                            result_list = g_list_prepend (result_list, item);
                         }
-                        DL_free(lyrics_page);
+                        DL_free (lyrics_page);
                     }
-                    g_free(new_url);
-                    g_free(full_url);
+                    g_free (new_url);
+                    g_free (full_url);
                 }
             }
         }
@@ -86,18 +93,23 @@ static GList *parse_search_result_page(cb_object *capo)
 
 ///////////////////////////////////
 
-static GList *lyrics_magistrix_parse(cb_object *capo)
+static GList * lyrics_magistrix_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    if(strstr(capo->cache->data, "Es wurden keine Songtexte gefunden") == NULL) {      /* "No songtext" page? */
-        if(strstr(capo->cache->data, "<title>Songtext-Suche</title>") == NULL) {      /* Are we not on the search result page? */
-            GlyrMemCache *result = parse_lyric_page(capo->cache);
-            if(result != NULL) {
-                result_list = g_list_prepend(result_list, result);
+    GList * result_list = NULL;
+    if (strstr (capo->cache->data,"Es wurden keine Songtexte gefunden") == NULL) /* "No songtext" page? */
+    {
+        if (strstr (capo->cache->data,"<title>Songtext-Suche</title>") == NULL) /* Are we not on the search result page? */
+        {
+            GlyrMemCache * result = parse_lyric_page (capo->cache);
+            if (result != NULL)
+            {
+                result_list = g_list_prepend (result_list,result);
             }
-        } else {
+        }
+        else
+        {
             /* Parse Searchresult page */
-            result_list = parse_search_result_page(capo);
+            result_list = parse_search_result_page (capo);
         }
     }
     return result_list;
@@ -105,7 +117,8 @@ static GList *lyrics_magistrix_parse(cb_object *capo)
 
 ///////////////////////////////////
 
-MetaDataSource lyrics_magistrix_src = {
+MetaDataSource lyrics_magistrix_src =
+{
     .name = "magistrix",
     .key  = 'x',
     .parser    = lyrics_magistrix_parse,
diff --git a/lib/intern/lyrics/metallum.c b/lib/intern/lyrics/metallum.c
index fa8b371..66349e0 100644
--- a/lib/intern/lyrics/metallum.c
+++ b/lib/intern/lyrics/metallum.c
@@ -31,7 +31,7 @@
 
 /////////////////////////////////
 
-static const gchar *lyrics_metallum_url(GlyrQuery *s)
+static const gchar * lyrics_metallum_url (GlyrQuery * s)
 {
     return AJAX_URL;
 }
@@ -43,23 +43,27 @@ static const gchar *lyrics_metallum_url(GlyrQuery *s)
 
 /////////////////////////////////
 
-static GList *lyrics_metallum_parse(cb_object *capo)
+static GList * lyrics_metallum_parse (cb_object * capo)
 {
-    GList *result_items = NULL;
-    gchar *id_start = strstr(capo->cache->data, ID_START);
-    if(id_start != NULL) {
-        id_start += strlen(ID_START);
-        gchar *ID_string = copy_value(id_start, strstr(id_start, ID_END));
-        if(ID_string != NULL) {
-            gchar *content_url = g_strdup_printf(SUBST_URL, ID_string);
-            if(content_url != NULL) {
-                GlyrMemCache *content_cache = download_single(content_url, capo->s, NULL);
-                if(content_cache != NULL && strstr(content_cache->data, BAD_STRING) == NULL) {
-                    result_items = g_list_prepend(result_items, content_cache);
+    GList * result_items = NULL;
+    gchar * id_start = strstr (capo->cache->data,ID_START);
+    if (id_start != NULL)
+    {
+        id_start += strlen (ID_START);
+        gchar * ID_string = copy_value (id_start,strstr (id_start,ID_END) );
+        if (ID_string != NULL)
+        {
+            gchar * content_url = g_strdup_printf (SUBST_URL,ID_string);
+            if (content_url != NULL)
+            {
+                GlyrMemCache * content_cache = download_single (content_url,capo->s,NULL);
+                if (content_cache != NULL && strstr (content_cache->data,BAD_STRING) == NULL)
+                {
+                    result_items = g_list_prepend (result_items, content_cache);
                 }
-                g_free(content_url);
+                g_free (content_url);
             }
-            g_free(ID_string);
+            g_free (ID_string);
         }
     }
     return result_items;
@@ -67,7 +71,8 @@ static GList *lyrics_metallum_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource lyrics_metallum_src = {
+MetaDataSource lyrics_metallum_src =
+{
     .name = "metallum",
     .key  = 'u',
     .parser    = lyrics_metallum_parse,
diff --git a/lib/intern/lyrics/metrolyrics.c b/lib/intern/lyrics/metrolyrics.c
index b80d9a3..dbd3428 100644
--- a/lib/intern/lyrics/metrolyrics.c
+++ b/lib/intern/lyrics/metrolyrics.c
@@ -25,24 +25,28 @@
 #define MAX_TRIES 5
 
 // Just return URL
-static const gchar *lyrics_metrolyrics_url(GlyrQuery *settings)
+static const gchar * lyrics_metrolyrics_url (GlyrQuery * settings)
 {
     return ML_URL;
 }
 
 ///////////////////////////////////
 
-static void replace_from_message_inline(gchar *text)
+static void replace_from_message_inline (gchar * text)
 {
-    if(text != NULL) {
-        gchar *from_msg_start = strstr(text, "[ From: ");
-        if(from_msg_start != NULL) {
-            while(from_msg_start[0] != '\n' && from_msg_start[0]) {
+    if (text != NULL)
+    {
+        gchar * from_msg_start = strstr (text,"[ From: ");
+        if (from_msg_start != NULL)
+        {
+            while (from_msg_start[0] != '\n' && from_msg_start[0])
+            {
                 from_msg_start[0] = ' ';
                 from_msg_start++;
             }
 
-            if(from_msg_start[0] == '\n') {
+            if (from_msg_start[0] == '\n')
+            {
                 from_msg_start[0] = ' ';
             }
         }
@@ -54,20 +58,24 @@ static void replace_from_message_inline(gchar *text)
 #define LYRICS_DIV "<div id=\"lyrics-body\">"
 #define LYRICS_END "</div>"
 
-static GlyrMemCache *parse_lyrics_page(const gchar *buffer)
+static GlyrMemCache * parse_lyrics_page (const gchar * buffer)
 {
-    GlyrMemCache *result = NULL;
-    if(buffer != NULL) {
-        gchar *begin = strstr(buffer, LYRICS_DIV);
-        if(begin != NULL) {
-            gchar *end = strstr(begin, LYRICS_END);
-            if(end != NULL) {
-                gchar *lyr = copy_value(begin, end);
-                if(lyr != NULL) {
+    GlyrMemCache * result = NULL;
+    if (buffer != NULL)
+    {
+        gchar * begin = strstr (buffer,LYRICS_DIV);
+        if (begin != NULL)
+        {
+            gchar * end = strstr (begin,LYRICS_END);
+            if (end != NULL)
+            {
+                gchar * lyr = copy_value (begin,end);
+                if (lyr != NULL)
+                {
                     result = DL_init();
-                    replace_from_message_inline(lyr);
+                    replace_from_message_inline (lyr);
                     result->data = lyr;
-                    result->size = strlen(result->data);
+                    result->size = strlen (result->data);
                 }
             }
         }
@@ -89,57 +97,61 @@ static GlyrMemCache *parse_lyrics_page(const gchar *buffer)
         <span class="title">Die Apokalyptischen Reiter<br /><strong>Friede Sei Mit Dir Lyrics</strong></span>
     </a>
 
-    artist = get_search_value("<span class=\"title\">", <br />");
-    title  = get_search_value("<strong>", </strong>");
+    artist = get_search_value("<span class=\"title\">","<br />");
+    title  = get_search_value("<strong>","</strong>");
 */
 
-static GList *lyrics_metrolyrics_parse(cb_object *capo)
+static GList * lyrics_metrolyrics_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *root = strstr(capo->cache->data, ROOT_NODE);
+    GList * result_list = NULL;
+    gchar * root = strstr (capo->cache->data,ROOT_NODE);
 
-    if(root != NULL) {
-        gchar *end_of_earch = strstr(root, END_OF_SEARCH);
-        gchar *node = root;
+    if (root != NULL)
+    {
+        gchar * end_of_earch = strstr (root,END_OF_SEARCH);
+        gchar * node = root;
 
         gsize tries = 0;
         gsize nodelen = (sizeof NODE_BEGIN);
 
-        while(continue_search(g_list_length(result_list), capo->s) && (node = strstr(node + nodelen, NODE_BEGIN)) && tries < MAX_TRIES) {
+        while (continue_search (g_list_length (result_list),capo->s) && (node = strstr (node + nodelen,NODE_BEGIN) ) && tries < MAX_TRIES)
+        {
             node += nodelen;
 
-            gchar *m_artist = get_search_value(node, "<span class=\"title\">", "<br />");
-            gchar *m_title  = get_search_value(node, "<strong>", " Lyrics</strong>");
+            gchar * m_artist = get_search_value (node,"<span class=\"title\">","<br />");
+            gchar * m_title  = get_search_value (node,"<strong>"," Lyrics</strong>");
 
-            if(levenshtein_strnormcmp(capo->s, capo->s->title, m_title)  <= capo->s->fuzzyness &&
-                    levenshtein_strnormcmp(capo->s, capo->s->artist, m_artist) <= capo->s->fuzzyness) {
-                gchar *relative_url = copy_value(node, strstr(node, "\">"));
-                if(relative_url != NULL) {
-                    gchar *page_url = g_strdup_printf("www.metrolyrics.com/%s", relative_url);
+            if (levenshtein_strnormcmp (capo->s,capo->s->title, m_title)  <= capo->s->fuzzyness &&
+                    levenshtein_strnormcmp (capo->s,capo->s->artist,m_artist) <= capo->s->fuzzyness)
+            {
+                gchar * relative_url = copy_value (node, strstr (node,"\">") );
+                if (relative_url != NULL)
+                {
+                    gchar * page_url = g_strdup_printf ("www.metrolyrics.com/%s",relative_url);
 
                     tries++;
-                    GlyrMemCache *page_cache = download_single(page_url, capo->s, NULL);
-
-                    if(page_cache != NULL) {
-                        GlyrMemCache *result = parse_lyrics_page(page_cache->data);
-                        if(result != NULL) {
-                            result->dsrc = g_strdup(page_url);
-                            result_list  = g_list_prepend(result_list, result);
+                    GlyrMemCache * page_cache = download_single (page_url,capo->s,NULL);
+
+                    if (page_cache != NULL)
+                    {
+                        GlyrMemCache * result = parse_lyrics_page (page_cache->data);
+                        if (result != NULL)
+                        {
+                            result->dsrc = g_strdup (page_url);
+                            result_list  = g_list_prepend (result_list,result);
                         }
-                        DL_free(page_cache);
+                        DL_free (page_cache);
                     }
-                    g_free(page_url);
-                    g_free(relative_url);
+                    g_free (page_url);
+                    g_free (relative_url);
                 }
             }
 
-            g_free(m_artist);
-            g_free(m_title);
+            g_free (m_artist);
+            g_free (m_title);
 
             /* Only advertisment behind dist */
-            if(node >= end_of_earch) {
-                break;
-            }
+            if (node >= end_of_earch) break;
         }
     }
     return result_list;
@@ -147,7 +159,8 @@ static GList *lyrics_metrolyrics_parse(cb_object *capo)
 
 ///////////////////////////////////
 
-MetaDataSource lyrics_metrolyrics_src = {
+MetaDataSource lyrics_metrolyrics_src =
+{
     .name = "metrolyrics",
     .key  = 'm',
     .parser    = lyrics_metrolyrics_parse,
diff --git a/lib/intern/lyrics/vagalume.c b/lib/intern/lyrics/vagalume.c
index 7ffb2e2..0f7d9a9 100644
--- a/lib/intern/lyrics/vagalume.c
+++ b/lib/intern/lyrics/vagalume.c
@@ -29,13 +29,13 @@
 
 /**
  * Vagalume Provider written by: Felipe Bessa Coelho
- *
+ * 
  * https://github.com/fcoelho
  *
  * Many thanks.
  */
 
-static const char *lyrics_vagalume_url(GlyrQuery *s)
+static const char * lyrics_vagalume_url (GlyrQuery * s)
 {
     return VAGALUME_DOMAIN VAGALUME_PATH;
 }
@@ -49,29 +49,28 @@ static gunichar get_unichar(const char *src)
     gint i;
 
     uchar = 0;
-    for(i = 0; i < 4; ++i) {
+    for (i = 0; i < 4; ++i) {
         ch = src[i];
-        if(g_ascii_isxdigit(ch)) {
+        if (g_ascii_isxdigit(ch))
             uchar += ((gunichar) g_ascii_xdigit_value(ch) << ((3 - i) * 4));
-        } else {
+        else
             break;
-        }
     }
 
     return uchar;
 }
 
-static GString *vagalume_escape_text(const char *src, int len)
+static GString * vagalume_escape_text(const char * src, int len)
 {
-    GString *output = g_string_sized_new(len);
+    GString * output = g_string_sized_new(len);
 
-    for(int i = 0; i < len; ++i) {
-        if(src[i] == '\\') {
+    for (int i = 0; i < len; ++i) {
+        if (src[i] == '\\') {
             ++i;
-            if(src[i] == 'n') {
+            if (src[i] == 'n') {
                 output = g_string_append_c(output, '\n');
                 continue;
-            } else if(src[i] == 'u') {
+            } else if (src[i] == 'u') {
                 ++i;
                 /* this was taken from here:
                  * https://git.gnome.org/browse/json-glib/tree/json-glib/json-scanner.c#n1116 */
@@ -79,11 +78,11 @@ static GString *vagalume_escape_text(const char *src, int len)
                 /* 4 characters read, the XXXX in \uXXXX, but we leave the last
                  * increment to the for loop */
                 i += 3;
-                if(g_unichar_type(ucs) == G_UNICODE_SURROGATE) {
+                if (g_unichar_type(ucs) == G_UNICODE_SURROGATE) {
                     /* read next surrogate, but first update our source string
                      * pointer */
                     ++i;
-                    if('\\' == src[i++] && 'u' == src[i++]) {
+                    if ('\\' == src[i++] && 'u' == src[i++]) {
                         gunichar ucs_lo = get_unichar(src + i);
                         /* 6 characters read from \uXXXX: '\\', 'u' and XXXX,
                          * but again, leave the last one to be updated by the
@@ -104,28 +103,27 @@ static GString *vagalume_escape_text(const char *src, int len)
     return output;
 }
 
-static gboolean found_song(const char *json, jsmntok_t *tokens, int *cur_token, int *tokens_left)
+static gboolean found_song (const char *json, jsmntok_t *tokens, int *cur_token, int *tokens_left)
 {
     gboolean found_key = false, song_found = false;
 
     /* check "type" key to see if song was found */
-    for(*cur_token = 0, *tokens_left = 1; *tokens_left > 0; ++ (*cur_token), -- (*tokens_left)) {
-        jsmntok_t *token = &tokens[*cur_token];
+    for (*cur_token = 0, *tokens_left = 1; *tokens_left > 0; ++(*cur_token), --(*tokens_left)) {
+        jsmntok_t * token = &tokens[*cur_token];
 
-        if(token->type == JSMN_ARRAY || token->type == JSMN_OBJECT) {
+        if (token->type == JSMN_ARRAY || token->type == JSMN_OBJECT)
             *tokens_left += token->size;
-        }
 
-        if(token->type == JSMN_STRING) {
+        if (token->type == JSMN_STRING) {
             size_t len = token->end - token->start;
             const char *text_start = json + token->start;
 
-            if(len == 4 && g_ascii_strncasecmp(text_start, "type", len) == 0) {
+            if (len == 4 && g_ascii_strncasecmp(text_start, "type", len) == 0) {
                 found_key = true;
                 continue;
             }
-            if(found_key) {
-                if(len == 5 && g_ascii_strncasecmp(text_start, "exact", len) == 0) {
+            if (found_key) {
+                if (len == 5 && g_ascii_strncasecmp(text_start, "exact", len) == 0) {
                     song_found = true;
                     break;
                 } else {
@@ -136,35 +134,34 @@ static gboolean found_song(const char *json, jsmntok_t *tokens, int *cur_token,
             }
         }
     }
-
+    
     /* we return only here to make sure tokens_left is updated at the end of
      * the for loop (specially if we break out of it) */
     return song_found;
 }
 
-static jsmntok_t *get_text_token(const char *json, jsmntok_t *tokens, int *cur_token, int *tokens_left)
+static jsmntok_t * get_text_token(const char *json, jsmntok_t *tokens, int *cur_token, int *tokens_left)
 {
     gboolean found_key = false;
-    jsmntok_t *text_token = NULL;
+    jsmntok_t * text_token = NULL;
 
     /* find the first occurrence of "text" */
-    for(/* empty */; *tokens_left > 0; ++ (*cur_token), -- (*tokens_left)) {
-        jsmntok_t *token = &tokens[*cur_token];
+    for (/* empty */; *tokens_left > 0; ++(*cur_token), --(*tokens_left)) {
+        jsmntok_t * token = &tokens[*cur_token];
 
-        if(token->type == JSMN_ARRAY || token->type == JSMN_OBJECT) {
+        if (token->type == JSMN_ARRAY || token->type == JSMN_OBJECT)
             *tokens_left += token->size;
-        }
 
-        if(token->type == JSMN_STRING) {
+        if (token->type == JSMN_STRING) {
             size_t len = token->end - token->start;
             const char *text_start = json + token->start;
 
-            if(len == 4 && g_ascii_strncasecmp(text_start, "text", len) == 0) {
+            if (len == 4 && g_ascii_strncasecmp(text_start, "text", len) == 0) {
                 found_key = true;
                 continue;
             }
 
-            if(found_key) {
+            if (found_key) {
                 /* this is it */
                 text_token = token;
                 break;
@@ -175,9 +172,9 @@ static jsmntok_t *get_text_token(const char *json, jsmntok_t *tokens, int *cur_t
     return text_token;
 }
 
-static GList *lyrics_vagalume_parse(cb_object *capo)
+static GList * lyrics_vagalume_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
+    GList * result_list = NULL;
 
     /* jsmn variables */
     jsmn_parser parser;
@@ -195,17 +192,18 @@ static GList *lyrics_vagalume_parse(cb_object *capo)
 
     parse_result = jsmn_parse(&parser, json, tokens, 512);
 
-    if(parse_result == JSMN_SUCCESS) {
+    if (parse_result == JSMN_SUCCESS)
+    {
         gboolean song_found = found_song(json, tokens, &cur_token, &tokens_left);
-        if(song_found) {
-            jsmntok_t *text_token = get_text_token(json, tokens, &cur_token, &tokens_left);
-            if(text_token) {
-                const char *lyrics_start = json + text_token->start;
+        if (song_found) {
+            jsmntok_t * text_token = get_text_token(json, tokens, &cur_token, &tokens_left);
+            if (text_token) {
+                const char * lyrics_start = json + text_token->start;
                 size_t len = text_token->end - text_token->start;
 
-                GlyrMemCache *cache = DL_init();
-                if(cache != NULL) {
-                    GString *data = vagalume_escape_text(lyrics_start, len);
+                GlyrMemCache * cache = DL_init();
+                if (cache != NULL) {
+                    GString * data = vagalume_escape_text(lyrics_start, len);
 
                     cache->data = data->str;
                     cache->size = data->len;
@@ -225,7 +223,8 @@ static GList *lyrics_vagalume_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource lyrics_vagalume_src = {
+MetaDataSource lyrics_vagalume_src =
+{
     .name = "vagalume",
     .key  = 'g',
     .parser    = lyrics_vagalume_parse,
diff --git a/lib/intern/musictree/musictree.c b/lib/intern/musictree/musictree.c
index 4b5b4a1..e881ecf 100644
--- a/lib/intern/musictree/musictree.c
+++ b/lib/intern/musictree/musictree.c
@@ -4,19 +4,21 @@
 #include "../../register_plugins.h"
 
 //static gboolean path_go_up(char * song_dir_path);
-static GList *find_in_musictree(const gchar *song_file_path, const gchar *regex, gint up_to, GlyrQuery *query);
-static void foreach_file(const gchar *song_dir_path, const GRegex *cRegex, GlyrQuery *query, GList **retv_list);
+static GList * find_in_musictree (const gchar * song_file_path, const gchar * regex, gint up_to,GlyrQuery * query);
+static void foreach_file (const gchar * song_dir_path, const GRegex * cRegex, GlyrQuery * query, GList ** retv_list);
 
 //---------------------------------------------------
 
-static gchar *get_file_contents(const gchar *filename, gsize *len)
+static gchar * get_file_contents (const gchar * filename, gsize * len)
 {
-    gchar *content = NULL;
-    GError *file_error = NULL;
-    if(filename != NULL) {
-        if(g_file_get_contents(filename, &content, len, &file_error) == FALSE) {
-            glyr_message(-1, NULL, "Error while reading file '%s': %s\n", filename, file_error->message);
-            g_error_free(file_error);
+    gchar * content = NULL;
+    GError * file_error = NULL;
+    if (filename != NULL)
+    {
+        if (g_file_get_contents (filename,&content,len,&file_error) == FALSE)
+        {
+            glyr_message (-1,NULL,"Error while reading file '%s': %s\n",filename,file_error->message);
+            g_error_free (file_error);
         }
     }
     return content;
@@ -24,12 +26,14 @@ static gchar *get_file_contents(const gchar *filename, gsize *len)
 
 //---------------------------------------------------
 
-static GLYR_DATA_TYPE get_data_type_from_query(GlyrQuery *query)
+static GLYR_DATA_TYPE get_data_type_from_query (GlyrQuery * query)
 {
     GLYR_DATA_TYPE type = GLYR_TYPE_UNKNOWN;
-    for(GList *elem = r_getFList(); elem != NULL; elem = elem->next) {
-        MetaDataFetcher *fetcher = elem->data;
-        if(fetcher != NULL && fetcher->type == query->type) {
+    for (GList * elem = r_getFList(); elem != NULL; elem = elem->next)
+    {
+        MetaDataFetcher * fetcher = elem->data;
+        if (fetcher != NULL && fetcher->type == query->type)
+        {
             type = fetcher->default_data_type;
             break;
         }
@@ -39,119 +43,137 @@ static GLYR_DATA_TYPE get_data_type_from_query(GlyrQuery *query)
 
 //---------------------------------------------------
 
-static void file_to_cache(GList **list, GlyrQuery *query, gchar *data, gsize size)
+static void file_to_cache (GList ** list, GlyrQuery * query, gchar * data, gsize size)
 {
-    if(list != NULL && data != NULL) {
-        GlyrMemCache *item = DL_init();
-        glyr_cache_set_data(item, data, size);
-        item->type = get_data_type_from_query(query);
-        item->dsrc = g_strdup("musictree");
-        item->prov = g_strdup("musictree");
-
-        if(TYPE_IS_IMAGE(query->type)) {
-            item->img_format = g_strdup("jpeg");
+    if (list != NULL && data != NULL)
+    {
+        GlyrMemCache * item = DL_init();
+        glyr_cache_set_data (item,data,size);
+        item->type = get_data_type_from_query (query);
+        item->dsrc = g_strdup ("musictree");
+        item->prov = g_strdup ("musictree");
+
+        if (TYPE_IS_IMAGE (query->type) )
+        {
+            item->img_format = g_strdup ("jpeg");
             item->is_image = TRUE;
-        } else {
+        }
+        else
+        {
             item->is_image = FALSE;
         }
 
-        *list = g_list_prepend(*list, item);
+        *list = g_list_prepend (*list, item);
     }
 }
 
 //---------------------------------------------------
 
-static void foreach_file(const gchar *song_dir_path, const GRegex *cRegex, GlyrQuery *query, GList **retv_list)
+static void foreach_file (const gchar * song_dir_path, const GRegex * cRegex, GlyrQuery * query, GList ** retv_list)
 {
-    if(song_dir_path != NULL) {
-        GError *dir_error = NULL;
-        GDir *song_dir = g_dir_open(song_dir_path, 0, &dir_error);
-        if(song_dir != NULL) {
-            const gchar *entry = NULL;
-            while((entry = g_dir_read_name(song_dir)) != NULL) {
-                if(regex_match_compiled(entry, cRegex) == TRUE) {
+    if (song_dir_path != NULL)
+    {
+        GError * dir_error = NULL;
+        GDir * song_dir = g_dir_open (song_dir_path,0,&dir_error);
+        if (song_dir != NULL)
+        {
+            const gchar * entry = NULL;
+            while ( (entry = g_dir_read_name (song_dir) ) != NULL)
+            {
+                if (regex_match_compiled (entry,cRegex) == TRUE)
+                {
 
                     gsize size = 0;
-                    gchar *absolute_path = g_strdup_printf("%s%c%s", song_dir_path, G_DIR_SEPARATOR, entry);
+                    gchar * absolute_path = g_strdup_printf ("%s%c%s",song_dir_path,G_DIR_SEPARATOR,entry);
 
-                    if(absolute_path != NULL) {
+                    if (absolute_path != NULL)
+                    {
                         /* Read file */
-                        gchar *file_path = g_filename_from_utf8(absolute_path, -1, NULL, NULL, NULL);
-                        gchar *retv = get_file_contents(file_path, &size);
-                        g_free(file_path);
-                        g_free(absolute_path);
+                        gchar * file_path = g_filename_from_utf8 (absolute_path, -1, NULL, NULL, NULL);
+                        gchar * retv = get_file_contents (file_path,&size);
+                        g_free (file_path);
+                        g_free (absolute_path);
 
                         /* Add file to result list if not null */
-                        file_to_cache(retv_list, query, retv, size);
+                        file_to_cache (retv_list,query,retv,size);
 
                         /* Not requested more? */
-                        if(g_list_length(*retv_list) >= (gsize) query->number) {
+                        if (g_list_length (*retv_list) >= (gsize) query->number)
                             break;
-                        }
                     }
                 }
             }
-            g_dir_close(song_dir);
-        } else {
-            glyr_message(-1, NULL, "Opening %s failed: %s\n", song_dir_path, dir_error->message);
-            g_error_free(dir_error);
+            g_dir_close (song_dir);
+        }
+        else
+        {
+            glyr_message (-1,NULL,"Opening %s failed: %s\n",song_dir_path,dir_error->message);
+            g_error_free (dir_error);
         }
     }
 }
 
 //---------------------------------------------------
 
-static gchar *path_go_up(char *song_dir_path)
+static gchar * path_go_up (char * song_dir_path)
 {
-    if(song_dir_path != NULL) {
-        song_dir_path = g_strstrip(song_dir_path);
-        if(g_str_has_suffix(song_dir_path, "/")) {
-            gsize len = strlen(song_dir_path);
-            song_dir_path[len - 1] = '\0';
+    if (song_dir_path != NULL)
+    {
+        song_dir_path = g_strstrip (song_dir_path);
+        if (g_str_has_suffix (song_dir_path, "/") )
+        {
+            gsize len = strlen (song_dir_path);
+            song_dir_path[len-1] = '\0';
         }
 
-        return g_path_get_dirname(song_dir_path);
+        return g_path_get_dirname (song_dir_path);
     }
     return NULL;
 }
 
 //---------------------------------------------------
 
-static GList *find_in_musictree(const gchar *song_file_path, const gchar *regex, gint up_to, GlyrQuery *query)
+static GList * find_in_musictree (const gchar * song_file_path, const gchar * regex, gint up_to,GlyrQuery * query)
 {
-    GList *retv_list = NULL;
+    GList * retv_list = NULL;
 
-    gchar *song_dir_path = NULL;
-    if(g_file_test(song_file_path, G_FILE_TEST_IS_DIR)) {
-        song_dir_path = g_strdup(song_file_path);
-    } else {
-        song_dir_path = g_path_get_dirname(song_file_path);
+    gchar * song_dir_path = NULL;
+    if (g_file_test (song_file_path,G_FILE_TEST_IS_DIR) )
+    {
+        song_dir_path = g_strdup (song_file_path);
+    }
+    else
+    {
+        song_dir_path = g_path_get_dirname (song_file_path);
     }
 
-    if(song_dir_path != NULL) {
-        gchar *tmp = song_dir_path;
-        song_dir_path = g_filename_from_utf8(song_dir_path, -1, NULL, NULL, NULL);
-        g_free(tmp);
+    if (song_dir_path != NULL)
+    {
+        gchar * tmp = song_dir_path;
+        song_dir_path = g_filename_from_utf8 (song_dir_path, -1, NULL, NULL, NULL);
+        g_free (tmp);
     }
 
-    if(song_dir_path != NULL) {
+    if (song_dir_path != NULL)
+    {
         /* Compile the regex just once */
-        GRegex *compiled_regex = g_regex_new(regex, G_REGEX_CASELESS, 0, NULL);
-        if(compiled_regex != NULL) {
-            for(gint i = 0; i < up_to; ++i) {
+        GRegex * compiled_regex = g_regex_new (regex,G_REGEX_CASELESS, 0, NULL);
+        if (compiled_regex != NULL)
+        {
+            for (gint i = 0; i < up_to; ++i)
+            {
                 /* Check every single file */
-                foreach_file(song_dir_path, compiled_regex, query, &retv_list);
+                foreach_file (song_dir_path,compiled_regex, query, &retv_list);
 
                 /* Cannot go up anymore */
-                if((song_dir_path = path_go_up(song_dir_path)) == NULL) {
+                if ( (song_dir_path = path_go_up (song_dir_path) ) == NULL)
                     break;
-                }
             }
 
             /* Forgot the regex */
-            g_regex_unref(compiled_regex);
+            g_regex_unref (compiled_regex);
         }
-        g_free(song_dir_path);
+        g_free (song_dir_path);
     }
     return retv_list;
 }
@@ -160,23 +182,24 @@ static GList *find_in_musictree(const gchar *song_file_path, const gchar *regex,
 
 #define REGEX_ESCAPE(str)         \
     (str != NULL) ?               \
-    g_regex_escape_string(str, 1) \
+    g_regex_escape_string(str,-1) \
     : NULL
 
-static gchar *configure_regex(const gchar *regex, GlyrQuery *subs)
+static gchar * configure_regex (const gchar * regex, GlyrQuery * subs)
 {
-    gchar *correct_regex = NULL;
-    if(regex && subs) {
+    gchar * correct_regex = NULL;
+    if (regex && subs)
+    {
         GlyrQuery temp;
-        temp.artist = REGEX_ESCAPE(subs->artist);
-        temp.album  = REGEX_ESCAPE(subs->album);
-        temp.title  = REGEX_ESCAPE(subs->title);
+        temp.artist = REGEX_ESCAPE (subs->artist);
+        temp.album  = REGEX_ESCAPE (subs->album);
+        temp.title  = REGEX_ESCAPE (subs->title);
 
-        correct_regex = prepare_url(regex, &temp, FALSE);
+        correct_regex = prepare_url (regex,&temp,FALSE);
 
-        g_free(temp.artist);
-        g_free(temp.album);
-        g_free(temp.title);
+        g_free (temp.artist);
+        g_free (temp.album );
+        g_free (temp.title );
     }
     return correct_regex;
 }
@@ -186,7 +209,7 @@ static gchar *configure_regex(const gchar *regex, GlyrQuery *subs)
 
 /* PROVIDER STUFF */
 
-static const gchar *musictree_provider_url(GlyrQuery *query)
+static const gchar * musictree_provider_url (GlyrQuery * query)
 {
     /* Flag this as a Offline provider */
     return OFFLINE_PROVIDER;
@@ -194,15 +217,16 @@ static const gchar *musictree_provider_url(GlyrQuery *query)
 
 //---------------------------------------------------
 
-static GList *musictree_provider_parse(cb_object *capo)
+static GList * musictree_provider_parse (cb_object * capo)
 {
-    GList *retv_list = NULL;
+    GList * retv_list = NULL;
 
     gint recurse_depth;
-    const gchar *search_regex = NULL;
+    const gchar * search_regex = NULL;
 
     /* The actual regexes are shamelessly ripped of GMPC */
-    switch(capo->s->type) {
+    switch (capo->s->type)
+    {
     case GLYR_GET_COVERART:
         search_regex = "^(folder|front|album|AlbumArt|cover|.*${album}.*)\\.(jpg|png|jpeg|gif)";
         recurse_depth = 3;
@@ -226,18 +250,20 @@ static GList *musictree_provider_parse(cb_object *capo)
         break;
     }
 
-    if(search_regex != NULL && capo->s->musictree_path != NULL) {
-        gchar *correct_regex = configure_regex(search_regex, capo->s);
-        retv_list = find_in_musictree(capo->s->musictree_path, correct_regex, recurse_depth, capo->s);
+    if (search_regex != NULL && capo->s->musictree_path != NULL)
+    {
+        gchar * correct_regex = configure_regex (search_regex,capo->s);
+        retv_list = find_in_musictree (capo->s->musictree_path,correct_regex,recurse_depth,capo->s);
 
-        g_free(correct_regex);
+        g_free (correct_regex);
     }
     return retv_list;
 }
 
 //---------------------------------------------------
 
-MetaDataSource musictree_provider_src = {
+MetaDataSource musictree_provider_src =
+{
     .name = "musictree",
     .key  = 't',
     .parser    = musictree_provider_parse,
diff --git a/lib/intern/photos.c b/lib/intern/photos.c
index 17b8de9..c25aa86 100644
--- a/lib/intern/photos.c
+++ b/lib/intern/photos.c
@@ -23,15 +23,16 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
-    return generic_img_finalizer(s, list, stop_me, GLYR_TYPE_ARTIST_PHOTO, result_list);
+    return generic_img_finalizer (s,list,stop_me,GLYR_TYPE_ARTIST_PHOTO,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_artistphotos = {
+MetaDataFetcher glyrFetcher_artistphotos =
+{
     .name = "artistphoto",
     .type = GLYR_GET_ARTIST_PHOTOS,
     .default_data_type = GLYR_TYPE_ARTIST_PHOTO,
diff --git a/lib/intern/photos/bbcmusic.c b/lib/intern/photos/bbcmusic.c
index 8295133..a88ada3 100644
--- a/lib/intern/photos/bbcmusic.c
+++ b/lib/intern/photos/bbcmusic.c
@@ -31,42 +31,47 @@
 #define CONTENT_BEGIN "<image><src>"
 #define CONTENT_ENDIN "</src></image>"
 
-static GlyrMemCache *parse_bbc_xml(GlyrMemCache *input)
+static GlyrMemCache * parse_bbc_xml (GlyrMemCache * input)
 {
-    GlyrMemCache *result = NULL;
-    char *content = get_search_value(input->data, CONTENT_BEGIN, CONTENT_ENDIN);
-    if(content != NULL) {
+    GlyrMemCache * result = NULL;
+    char * content = get_search_value (input->data, CONTENT_BEGIN, CONTENT_ENDIN);
+    if (content != NULL)
+    {
         result = DL_init();
         result->data = content;
-        result->dsrc = g_strdup(input->dsrc);
-        result->size = strlen(content);
+        result->dsrc = g_strdup (input->dsrc);
+        result->size = strlen (content);
     }
     return result;
 }
 
 /////////////////////////////////
 
-static const char *photos_bbcmusic_url(GlyrQuery *qry)
+static const char * photos_bbcmusic_url (GlyrQuery * qry)
 {
     return "http://musicbrainz.org/ws/2/artist?query=artist:${artist}";
 }
 
 /////////////////////////////////
 
-static GList *photos_bbcmusic_parse(cb_object *capo)
+static GList * photos_bbcmusic_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
+    GList * result_list = NULL;
 
-    char *mbid = mbid_parse_data(capo->cache, "artist", "name", capo->s->artist, capo->s);
+    char * mbid = mbid_parse_data (capo->cache, "artist", "name", capo->s->artist, capo->s);
 
-    if(mbid != NULL) {
-        char *full_url = g_strdup_printf(API_ROOT, mbid);
-        if(full_url != NULL) {
-            GlyrMemCache *bbc_xml = download_single(full_url, capo->s, NULL);
-            if(bbc_xml != NULL) {
-                GlyrMemCache *item = parse_bbc_xml(bbc_xml);
-                if(item != NULL) {
-                    result_list = g_list_prepend(result_list, item);
+    if (mbid != NULL)
+    {
+        char * full_url = g_strdup_printf (API_ROOT, mbid);
+        if (full_url != NULL)
+        {
+            GlyrMemCache * bbc_xml = download_single (full_url, capo->s, NULL);
+            if (bbc_xml != NULL)
+            {
+                GlyrMemCache * item = parse_bbc_xml (bbc_xml);
+                if (item != NULL)
+                {
+                    result_list = g_list_prepend (result_list, item);
                 }
                 DL_free(bbc_xml);
             }
@@ -80,7 +85,8 @@ static GList *photos_bbcmusic_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource photos_bbcmusic_src = {
+MetaDataSource photos_bbcmusic_src =
+{
     .name      = "bbcmusic",
     .key       = 'b',
     .free_url  = false,
diff --git a/lib/intern/photos/discogs.c b/lib/intern/photos/discogs.c
index 6814398..a9d73e5 100644
--- a/lib/intern/photos/discogs.c
+++ b/lib/intern/photos/discogs.c
@@ -52,39 +52,42 @@
 #define THUMB_SUBDNOE "\"thumb\": \""
 #define FOLLR_SUBNODE "\"uri\": \""
 #define NODE THUMB_SUBDNOE
-#define ENDOF_SUBNODE "\", 
+#define ENDOF_SUBNODE "\","
 
 
 /////////////////////////////////////////////////////
 
-static bool check_artist_album(GlyrQuery *q, const char *artist)
+static bool check_artist_album (GlyrQuery * q, const char * artist)
 {
-    return levenshtein_strnormcmp(q, q->artist, artist) <= q->fuzzyness;
+    return levenshtein_strnormcmp (q,q->artist, artist) <= q->fuzzyness;
 
 }
 
 /////////////////////////////////////////////////////
 
-static GlyrMemCache *transform_url(cb_object *s, const char *url)
+static GlyrMemCache * transform_url (cb_object * s, const char * url)
 {
-    GlyrMemCache *rc = NULL;
-    size_t rc_size = strlen(url);
-    char *rc_url  = g_strdup(url);
-
-    if(rc_url != NULL) {
-        char *slash = strrchr(rc_url, '/');
-        if(slash != NULL) {
-            char *sp = strchr(slash, '-');
-            if(sp != NULL) {
-                char *ep = strchr(sp + 1, '-');
+    GlyrMemCache * rc = NULL;
+    size_t rc_size = strlen (url);
+    char * rc_url  = g_strdup (url);
+
+    if (rc_url != NULL)
+    {
+        char * slash = strrchr (rc_url,'/');
+        if (slash != NULL)
+        {
+            char * sp = strchr (slash,'-');
+            if (sp != NULL)
+            {
+                char * ep = strchr (sp + 1, '-');
                 if(ep != NULL) {
                     size_t rest_len = rc_size - (ep - rc_url) + 1;
-                    memmove(sp, ep, rest_len);
+                    memmove (sp,ep,rest_len);
 
                     rc = DL_init();
-                    rc->data = (char *) rc_url;
-                    rc->size = strlen(url);
-                    rc->dsrc = g_strdup(s->url);
+                    rc->data = (char*) rc_url;
+                    rc->size = strlen (url);
+                    rc->dsrc = g_strdup (s->url);
                 }
             }
         }
@@ -96,37 +99,41 @@ static GlyrMemCache *transform_url(cb_object *s, const char *url)
 /////////////////////////////////////////////////////
 /////////////////////////////////////////////////////
 
-static const char *photos_discogs_url(GlyrQuery *q)
+static const char * photos_discogs_url (GlyrQuery * q)
 {
     return API_ENTRY;
 }
 
 /////////////////////////////////////////////////////
 
-static GList *photos_discogs_parse(cb_object *capo)
+static GList * photos_discogs_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
+    GList * result_list = NULL;
 
     /* Jump to the very first node 'directly' */
-    gchar *node = capo->cache->data;
+    gchar * node = capo->cache->data;
 
-    while(continue_search(g_list_length(result_list), capo->s)
-            && (node = strstr(node + (sizeof NODE) - 1, NODE)) != NULL) {
+    while (continue_search (g_list_length (result_list),capo->s)
+            && (node = strstr (node + (sizeof NODE) - 1,NODE) ) != NULL)
+    {
 
-        char *artist_album = get_search_value(node, TITLE_SUBNODE, ENDOF_SUBNODE);
-        if(artist_album && check_artist_album(capo->s, artist_album)) {
+        char * artist_album = get_search_value (node,TITLE_SUBNODE,ENDOF_SUBNODE);
+        if (artist_album && check_artist_album (capo->s,artist_album) )
+        {
 
-            char *thumb_url = get_search_value(node, THUMB_SUBDNOE, ENDOF_SUBNODE);
-            if(thumb_url) {
+            char * thumb_url = get_search_value (node,THUMB_SUBDNOE,ENDOF_SUBNODE);
+            if (thumb_url)
+            {
 
-                GlyrMemCache *p = transform_url(capo, thumb_url);
-                if(p != NULL) {
-                    result_list = g_list_prepend(result_list, p);
+                GlyrMemCache * p = transform_url (capo,thumb_url);
+                if (p != NULL)
+                {
+                    result_list = g_list_prepend (result_list,p);
                 }
-                g_free(thumb_url);
+                g_free (thumb_url);
             }
         }
-        g_free(artist_album);
+        g_free (artist_album);
     }
 
     return result_list;
@@ -134,7 +141,8 @@ static GList *photos_discogs_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource photos_discogs_src = {
+MetaDataSource photos_discogs_src =
+{
     .name      = "discogs",
     .key       = 'd',
     .parser    = photos_discogs_parse,
diff --git a/lib/intern/photos/flickr.c b/lib/intern/photos/flickr.c
index 55c2c87..03001a6 100644
--- a/lib/intern/photos/flickr.c
+++ b/lib/intern/photos/flickr.c
@@ -25,55 +25,59 @@
 
 /////////////////////////////////
 
-static const gchar *photos_flickr_url(GlyrQuery *settings)
+static const gchar * photos_flickr_url (GlyrQuery * settings)
 {
-    if(settings->img_max_size <= 175 && settings->img_max_size != -1) {
+    if (settings->img_max_size <= 175 && settings->img_max_size != -1)
+    {
         return NULL;
     }
 
-    gchar *url = g_strdup_printf("http://api.flickr.com/services/rest/"
-                                 "?method=flickr.photos.search&"
-                                 "api_key="API_KEY_FLICKR"&"
-                                 "tags=%s&"
-                                 "media=photos&"
-                                 "group_id=29928242@N00&"
-                                 "content_type=6&"
-                                 "sort=interestingness-asc&"
-                                 "per_page=%d",
-                                 settings->artist,
-                                 settings->number
-                                );
+    gchar * url = g_strdup_printf ("http://api.flickr.com/services/rest/"
+                                   "?method=flickr.photos.search&"
+                                   "api_key="API_KEY_FLICKR"&"
+                                   "tags=%s&"
+                                   "media=photos&"
+                                   "group_id=29928242@N00&"
+                                   "content_type=6&"
+                                   "sort=interestingness-asc&"
+                                   "per_page=%d",
+                                   settings->artist,
+                                   settings->number
+                                  );
     return url;
 }
 
 /////////////////////////////////
 
-static GList *photos_flickr_parse(cb_object *capo)
+static GList * photos_flickr_parse (cb_object * capo)
 {
-    gchar *ph_begin = capo->cache->data;
-    GList *result_list = NULL;
+    gchar * ph_begin = capo->cache->data;
+    GList * result_list = NULL;
 
-    while(continue_search(g_list_length(result_list), capo->s) && (ph_begin = strstr(ph_begin, LINE_BEGIN)) != NULL) {
-        gchar *ph_end = strstr(ph_begin, LINE_ENDIN);
-        if(ph_end != NULL) {
-            gchar *linebf = copy_value(ph_begin, ph_end);
-            if(linebf != NULL) {
-                gchar *ID = get_search_value(linebf, "id=\"", "\"");
-                gchar *SC = get_search_value(linebf, "secret=\"", "\"");
-                gchar *SV = get_search_value(linebf, "server=\"", "\"");
-                gchar *FR = get_search_value(linebf, "farm=\"", "\"");
+    while (continue_search (g_list_length (result_list),capo->s) && (ph_begin=strstr (ph_begin,LINE_BEGIN) ) != NULL)
+    {
+        gchar * ph_end = strstr (ph_begin,LINE_ENDIN);
+        if (ph_end != NULL)
+        {
+            gchar * linebf = copy_value (ph_begin,ph_end);
+            if (linebf != NULL)
+            {
+                gchar * ID = get_search_value (linebf, "id=\"","\"");
+                gchar * SC = get_search_value (linebf, "secret=\"","\"");
+                gchar * SV = get_search_value (linebf, "server=\"","\"");
+                gchar * FR = get_search_value (linebf, "farm=\"","\"");
 
-                GlyrMemCache *cache = DL_init();
-                cache->data = g_strdup_printf("http://farm%s.static.flickr.com/%s/%s_%s.jpg", FR, SV, ID, SC);
-                cache->size = strlen(cache->data);
-                result_list = g_list_prepend(result_list, cache);
+                GlyrMemCache * cache = DL_init();
+                cache->data = g_strdup_printf ("http://farm%s.static.flickr.com/%s/%s_%s.jpg",FR,SV,ID,SC);
+                cache->size = strlen (cache->data);
+                result_list = g_list_prepend (result_list,cache);
 
-                g_free(ID);
-                g_free(SC);
-                g_free(SV);
-                g_free(FR);
+                g_free (ID);
+                g_free (SC);
+                g_free (SV);
+                g_free (FR);
 
-                g_free(linebf);
+                g_free (linebf);
             }
         }
     }
@@ -82,7 +86,8 @@ static GList *photos_flickr_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource photos_flickr_src = {
+MetaDataSource photos_flickr_src =
+{
     .name = "flickr",
     .key  = 'f',
     .parser    = photos_flickr_parse,
diff --git a/lib/intern/photos/google.c b/lib/intern/photos/google.c
index 48b8946..4d65095 100644
--- a/lib/intern/photos/google.c
+++ b/lib/intern/photos/google.c
@@ -23,27 +23,29 @@
 
 /////////////////////////////////
 
-static const gchar *photos_google_url(GlyrQuery *s)
+static const gchar * photos_google_url (GlyrQuery * s)
 {
-    const gchar *result = NULL;
-    gchar *searchterm = g_strdup("${artist}+band+photos");
-    if(searchterm != NULL) {
-        result = generic_google_url(s, searchterm);
-        g_free(searchterm);
+    const gchar * result = NULL;
+    gchar * searchterm = g_strdup ("${artist}+band+photos");
+    if (searchterm != NULL)
+    {
+        result = generic_google_url (s,searchterm);
+        g_free (searchterm);
     }
     return result;
 }
 
 /////////////////////////////////
 
-static GList *photos_google_parse(cb_object *capo)
+static GList * photos_google_parse (cb_object * capo)
 {
-    return generic_google_parse(capo);
+    return generic_google_parse (capo);
 }
 
 /////////////////////////////////
 
-MetaDataSource photos_google_src = {
+MetaDataSource photos_google_src =
+{
     .name = "google",
     .key  = 'g',
     .parser    = photos_google_parse,
diff --git a/lib/intern/photos/lastfm.c b/lib/intern/photos/lastfm.c
index f764c5d..204a9b8 100644
--- a/lib/intern/photos/lastfm.c
+++ b/lib/intern/photos/lastfm.c
@@ -26,43 +26,49 @@
 
 /////////////////////////////////
 
-static const gchar *photos_lastfm_url(GlyrQuery *settings)
+static const gchar * photos_lastfm_url (GlyrQuery * settings)
 {
     return "http://ws.audioscrobbler.com/2.0/?method=artist.getimages&autocorrect=1&artist=${artist}&api_key="API_KEY_LASTFM;
 }
 
 /////////////////////////////////
 
-static gboolean size_fits(GlyrQuery *s, gchar **ref)
+static gboolean size_fits (GlyrQuery * s, gchar ** ref)
 {
     gboolean result = FALSE;
-    if(ref != NULL) {
-        gchar *search_ptr = ref[0];
-        if(search_ptr != NULL) {
-            search_ptr = strchr(search_ptr, '"');
+    if (ref != NULL)
+    {
+        gchar * search_ptr = ref[0];
+        if (search_ptr != NULL)
+        {
+            search_ptr = strchr (search_ptr,'"');
 
             gint ratio = 0;
-            gchar *width_string  = get_search_value(search_ptr, "width=\"", "\"");
-            gchar *height_string = get_search_value(search_ptr, "height=\"", "\"");
-            if(width_string && height_string) {
-                ratio  = (strtol(width_string, NULL, 10) + strtol(height_string, NULL, 10)) / 2;
+            gchar * width_string  = get_search_value (search_ptr,"width=\"","\"");
+            gchar * height_string = get_search_value (search_ptr,"height=\"","\"");
+            if (width_string && height_string)
+            {
+                ratio  = (strtol (width_string,NULL,10) + strtol (height_string,NULL,10) ) /2;
             }
-            g_free(width_string);
-            g_free(height_string);
+            g_free (width_string);
+            g_free (height_string);
 
             gboolean original_size_allowed = TRUE;
-            if(g_strstr_len(ref[0], 100, "original") != NULL) {
+            if (g_strstr_len (ref[0],100,"original") != NULL)
+            {
                 /* Deny extremelly large images by default, except explicitely wanted */
-                if(!(ratio >= 1000 && s->img_min_size >= 1000 && s->img_max_size == -1)) {
+                if (! (ratio >= 1000 && s->img_min_size >= 1000 && s->img_max_size == -1) )
+                {
                     original_size_allowed = FALSE;
                 }
             }
 
-            if(size_is_okay(ratio, s->img_min_size, s->img_max_size) == TRUE && original_size_allowed == TRUE) {
+            if (size_is_okay (ratio, s->img_min_size, s->img_max_size) == TRUE && original_size_allowed == TRUE)
+            {
                 result = TRUE;
             }
 
-            search_ptr = strchr(search_ptr, '>');
+            search_ptr = strchr (search_ptr,'>');
         }
         ref[0] = search_ptr + 1;
     }
@@ -71,22 +77,26 @@ static gboolean size_fits(GlyrQuery *s, gchar **ref)
 
 /////////////////////////////////
 
-static GList *photos_lastfm_parse(cb_object *capo)
+static GList * photos_lastfm_parse (cb_object * capo)
 {
-    gchar *root = capo->cache->data;
-    GList *result_list = NULL;
+    gchar * root = capo->cache->data;
+    GList * result_list = NULL;
 
-    while(continue_search(g_list_length(result_list), capo->s) && (root = strstr(root, SIZE_FO)) != NULL) {
-        gchar *begin = root + strlen(SIZE_FO);
-        if(size_fits(capo->s, &begin) == TRUE) {
-            gchar *endin = strstr(begin, URL_ENDIN);
-            if(endin != NULL) {
-                gchar *urlb = copy_value(begin, endin);
-                if(urlb != NULL) {
-                    GlyrMemCache *cache = DL_init();
+    while (continue_search (g_list_length (result_list),capo->s) && (root = strstr (root,SIZE_FO) ) != NULL)
+    {
+        gchar * begin = root + strlen (SIZE_FO);
+        if (size_fits (capo->s,&begin) == TRUE)
+        {
+            gchar * endin = strstr (begin,URL_ENDIN);
+            if (endin != NULL)
+            {
+                gchar * urlb = copy_value (begin,endin);
+                if (urlb != NULL)
+                {
+                    GlyrMemCache * cache = DL_init();
                     cache->data = urlb;
-                    cache->size = strlen(urlb);
-                    result_list = g_list_prepend(result_list, cache);
+                    cache->size = strlen (urlb);
+                    result_list = g_list_prepend (result_list,cache);
                 }
             }
         }
@@ -97,7 +107,8 @@ static GList *photos_lastfm_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource photos_lastfm_src = {
+MetaDataSource photos_lastfm_src =
+{
     .name = "lastfm",
     .key  = 'l',
     .parser    = photos_lastfm_parse,
diff --git a/lib/intern/photos/picsearch.c b/lib/intern/photos/picsearch.c
index b739257..5bafc0c 100644
--- a/lib/intern/photos/picsearch.c
+++ b/lib/intern/photos/picsearch.c
@@ -23,20 +23,21 @@
 
 /////////////////////////////////
 
-static const gchar *photos_picsearch_url(GlyrQuery *s)
+static const gchar * photos_picsearch_url (GlyrQuery * s)
 {
-    return generic_picsearch_url(s, "${artist}+band");
+    return generic_picsearch_url (s,"${artist}+band");
 }
 
 /////////////////////////////////
-static GList *photos_picsearch_parse(cb_object *capo)
+static GList * photos_picsearch_parse (cb_object * capo)
 {
-    return generic_picsearch_parse(capo);
+    return generic_picsearch_parse (capo);
 }
 
 /////////////////////////////////
 
-MetaDataSource photos_picsearch_src = {
+MetaDataSource photos_picsearch_src =
+{
     .name      = "picsearch",
     .key       = 'p',
     .parser    = photos_picsearch_parse,
diff --git a/lib/intern/photos/rhapsody.c b/lib/intern/photos/rhapsody.c
index 12a54e1..bc21516 100644
--- a/lib/intern/photos/rhapsody.c
+++ b/lib/intern/photos/rhapsody.c
@@ -23,18 +23,21 @@
 
 /////////////////////////////////
 
-static gchar *translate_string(gchar *string)
+static gchar * translate_string (gchar * string)
 {
-    gchar *result = NULL;
-    if(string != NULL) {
-        gchar *beautiful = beautify_string(string);
-        if(beautiful != NULL) {
-            gchar *downcase = g_utf8_strdown(beautiful, -1);
-            if(downcase != NULL) {
-                result = translate_umlauts(downcase);
-                g_free(downcase);
+    gchar * result = NULL;
+    if (string != NULL)
+    {
+        gchar * beautiful = beautify_string (string);
+        if (beautiful != NULL)
+        {
+            gchar * downcase = g_utf8_strdown (beautiful,-1);
+            if (downcase != NULL)
+            {
+                result = translate_umlauts (downcase);
+                g_free (downcase);
             }
-            g_free(beautiful);
+            g_free (beautiful);
         }
     }
     return result;
@@ -42,35 +45,39 @@ static gchar *translate_string(gchar *string)
 
 /////////////////////////////////
 
-static const gchar *photos_rhapsody_url(GlyrQuery *query)
+static const gchar * photos_rhapsody_url (GlyrQuery * query)
 {
-    gchar *result = NULL;
-    if(query->img_min_size <= 135) {
-        gchar *corrected_artist = translate_string(query->artist);
-        if(corrected_artist != NULL) {
-            result = g_strdup_printf("http://feeds.rhapsody.com/%s/data.xml", corrected_artist);
+    gchar * result = NULL;
+    if (query->img_min_size <= 135)
+    {
+        gchar * corrected_artist = translate_string (query->artist);
+        if (corrected_artist != NULL)
+        {
+            result = g_strdup_printf ("http://feeds.rhapsody.com/%s/data.xml",corrected_artist);
         }
-        g_free(corrected_artist);
+        g_free (corrected_artist);
     }
     return result;
 }
 
 /////////////////////////////////
 
-static gboolean check_size(GlyrQuery *s, gchar *ref)
+static gboolean check_size (GlyrQuery * s, gchar * ref)
 {
     gboolean result = FALSE;
-    if(ref != NULL) {
-        gchar *width_str  = get_search_value(ref, "width=\"", "\"");
-        gchar *height_str = get_search_value(ref, "height=\"", "\"");
-        if(width_str && height_str) {
-            gint width  = strtol(width_str, NULL, 10);
-            gint height = strtol(height_str, NULL, 10);
+    if (ref != NULL)
+    {
+        gchar * width_str  = get_search_value (ref,"width=\"","\"");
+        gchar * height_str = get_search_value (ref,"height=\"","\"");
+        if (width_str && height_str)
+        {
+            gint width  = strtol (width_str, NULL,10);
+            gint height = strtol (height_str,NULL,10);
 
-            result = size_is_okay((width + height) / 2 + 10, s->img_min_size, s->img_max_size);
+            result = size_is_okay ( (width+height) /2 + 10,s->img_min_size,s->img_max_size);
         }
-        g_free(width_str);
-        g_free(height_str);
+        g_free (width_str);
+        g_free (height_str);
     }
     return result;
 }
@@ -81,24 +88,28 @@ static gboolean check_size(GlyrQuery *s, gchar *ref)
 #define DELIM_END "</art>"
 #define NODE "<img "
 
-static GList *photos_rhapsody_parse(cb_object *capo)
+static GList * photos_rhapsody_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    gchar *delim_beg = strstr(capo->cache->data, DELIM_BEG);
-    gchar *delim_end = strstr(capo->cache->data, DELIM_END);
+    GList * result_list = NULL;
+    gchar * delim_beg = strstr (capo->cache->data,DELIM_BEG);
+    gchar * delim_end = strstr (capo->cache->data,DELIM_END);
 
-    if(delim_beg && delim_end) {
-        gchar *node = delim_beg;
+    if (delim_beg && delim_end)
+    {
+        gchar * node = delim_beg;
         gsize nd_len = (sizeof NODE) - 1;
-        while(continue_search(g_list_length(result_list), capo->s) && (node = strstr(node + nd_len, NODE)) && node < delim_end) {
+        while (continue_search (g_list_length (result_list),capo->s) && (node = strstr (node + nd_len, NODE) ) && node < delim_end)
+        {
             node += nd_len;
-            if(check_size(capo->s, node) == TRUE) {
-                gchar *url = get_search_value(node, "src=\"", "\"");
-                if(url != NULL) {
-                    GlyrMemCache *result = DL_init();
+            if (check_size (capo->s,node) == TRUE)
+            {
+                gchar * url = get_search_value (node,"src=\"","\"");
+                if (url != NULL)
+                {
+                    GlyrMemCache * result = DL_init();
                     result->data = url;
-                    result->size = strlen(url);
-                    result_list = g_list_prepend(result_list, result);
+                    result->size = strlen (url);
+                    result_list = g_list_prepend (result_list,result);
                 }
             }
         }
@@ -109,7 +120,8 @@ static GList *photos_rhapsody_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource photos_rhapsody_src = {
+MetaDataSource photos_rhapsody_src =
+{
     .name      = "rhapsody",
     .key       = 'r',
     .parser    = photos_rhapsody_parse,
diff --git a/lib/intern/photos/singerpictures.c b/lib/intern/photos/singerpictures.c
index d21f6c7..994cee5 100644
--- a/lib/intern/photos/singerpictures.c
+++ b/lib/intern/photos/singerpictures.c
@@ -22,23 +22,24 @@
 
 #define SPICS_BASE_URL "http://www.singerpictures.com/%s-pictures.html"
 
-static const gchar *photos_singerlyrics_url(GlyrQuery *settings)
+static const gchar * photos_singerlyrics_url (GlyrQuery * settings)
 {
-    gchar *result_url = NULL;
-    gchar *space_to_min_artist = strreplace(settings->artist, " ", "-");
-    if(space_to_min_artist != NULL) {
-        gchar *prep_artist = NULL;
-        if(settings->normalization & GLYR_NORMALIZE_ARTIST) {
-            prep_artist = prepare_string(space_to_min_artist, settings->normalization, TRUE);
-        } else {
-            prep_artist = prepare_string(space_to_min_artist, GLYR_NORMALIZE_NONE, TRUE);
+    gchar * result_url = NULL;
+    gchar * space_to_min_artist = strreplace (settings->artist," ","-");
+    if (space_to_min_artist != NULL)
+    {
+        gchar * prep_artist = NULL;
+        if(settings->normalization & GLYR_NORMALIZE_ARTIST)
+            prep_artist = prepare_string (space_to_min_artist, settings->normalization,TRUE);
+        else
+            prep_artist = prepare_string (space_to_min_artist, GLYR_NORMALIZE_NONE,TRUE);
+
+        if (prep_artist != NULL)
+        {
+            result_url = g_strdup_printf (SPICS_BASE_URL,prep_artist);
+            g_free (prep_artist);
         }
-
-        if(prep_artist != NULL) {
-            result_url = g_strdup_printf(SPICS_BASE_URL, prep_artist);
-            g_free(prep_artist);
-        }
-        g_free(space_to_min_artist);
+        g_free (space_to_min_artist);
     }
     return result_url;
 }
@@ -49,39 +50,45 @@ static const gchar *photos_singerlyrics_url(GlyrQuery *settings)
 #define SIZE_END   "<br>"
 #define MAX_NUM_SIZE 16
 
-static gboolean check_image_size(GlyrQuery *s, gchar *ref_to_img_start)
+static gboolean check_image_size (GlyrQuery * s, gchar * ref_to_img_start)
 {
-    if(s->img_min_size == -1 && s->img_max_size == -1) {
+    if (s->img_min_size == -1 && s->img_max_size == -1)
+    {
         return TRUE;
     }
 
     gboolean result = FALSE;
-    gchar *size_begin = strstr(ref_to_img_start, SIZE_BEGIN);
-    if(size_begin != NULL) {
+    gchar * size_begin = strstr (ref_to_img_start,SIZE_BEGIN);
+    if (size_begin != NULL)
+    {
         size_begin += (sizeof SIZE_BEGIN) - 1;
-        gchar *size_end = strstr(size_begin, SIZE_END);
-        if(size_end != NULL) {
-            gchar size_buf[2][MAX_NUM_SIZE] = {{}, {}};
+        gchar * size_end = strstr (size_begin,SIZE_END);
+        if (size_end != NULL)
+        {
+            gchar size_buf[2][MAX_NUM_SIZE] = {{},{}};
             gint copy_to = 0, offset = 0;
 
             /* Parse the 'x_one X y_one' field */
-            for(gint it = 0; &size_begin[it] != size_end && it < MAX_NUM_SIZE; it++) {
-                if(size_begin[it] == 'X') {
+            for (gint it = 0; &size_begin[it] != size_end && it < MAX_NUM_SIZE; it++)
+            {
+                if (size_begin[it] == 'X')
+                {
                     copy_to = 1;
                     offset  = 0;
-                } else {
+                }
+                else
+                {
                     size_buf[copy_to][offset++] = size_begin[it];
                 }
             }
 
-            gint x = g_ascii_strtoll(size_buf[0], NULL, 10);
-            gint y = g_ascii_strtoll(size_buf[0], NULL, 10);
-            gint ratio = (x + y) / 2;
+            gint x = g_ascii_strtoll (size_buf[0],NULL,10);
+            gint y = g_ascii_strtoll (size_buf[0],NULL,10);
+            gint ratio = (x+y) /2;
 
-            if((s->img_min_size == -1 || ratio >= s->img_min_size) &&
-                    (s->img_max_size == -1 || ratio <= s->img_max_size)) {
+            if ( (s->img_min_size == -1 || ratio >= s->img_min_size) &&
+                    (s->img_max_size == -1 || ratio <= s->img_max_size) )
                 result = TRUE;
-            }
         }
     }
     return result;
@@ -93,22 +100,25 @@ static gboolean check_image_size(GlyrQuery *s, gchar *ref_to_img_start)
 #define URL_ID_START "rel=\"nofollow\"><img src='/images/pic/"
 #define URL_ID_END   "_th."
 
-static GList *photos_singerlyrics_parse(cb_object *capo)
+static GList * photos_singerlyrics_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
+    GList * result_list = NULL;
     gsize len = (sizeof URL_ID_START) - 1;
-    gchar *url_id_start = capo->cache->data;
-
-    while((continue_search(g_list_length(result_list), capo->s) && (url_id_start = strstr(url_id_start + len, URL_ID_START)) != NULL)) {
-        if(check_image_size(capo->s, url_id_start)) {
-            gchar *ID = get_search_value(url_id_start, URL_ID_START, URL_ID_END);
-            if(ID != NULL) {
-                GlyrMemCache *item = DL_init();
-                item->data = g_strdup_printf(FINAL_BASE_URL, ID);
-                item->size = strlen(item->data);
-
-                result_list = g_list_prepend(result_list, item);
-                g_free(ID);
+    gchar * url_id_start = capo->cache->data;
+
+    while ( (continue_search (g_list_length (result_list),capo->s) && (url_id_start = strstr (url_id_start + len,URL_ID_START) ) != NULL) )
+    {
+        if (check_image_size (capo->s, url_id_start) )
+        {
+            gchar * ID = get_search_value (url_id_start,URL_ID_START,URL_ID_END);
+            if (ID != NULL)
+            {
+                GlyrMemCache * item = DL_init();
+                item->data = g_strdup_printf (FINAL_BASE_URL,ID);
+                item->size = strlen (item->data);
+
+                result_list = g_list_prepend (result_list, item);
+                g_free (ID);
             }
         }
     }
@@ -117,7 +127,8 @@ static GList *photos_singerlyrics_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource photos_singerpictures_src = {
+MetaDataSource photos_singerpictures_src =
+{
     .name = "singerpictures",
     .key  = 's',
     .parser    = photos_singerlyrics_parse,
diff --git a/lib/intern/relations.c b/lib/intern/relations.c
index 3bc9b7c..654fb92 100644
--- a/lib/intern/relations.c
+++ b/lib/intern/relations.c
@@ -22,15 +22,16 @@
 #include "../stringlib.h"
 #include "generic.h"
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
-    return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_RELATION, result_list);
+    return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_RELATION,result_list);
 }
 
 //-------------------------------------
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_relations = {
+MetaDataFetcher glyrFetcher_relations =
+{
     .name = "relations",
     .type = GLYR_GET_RELATIONS,
     .default_data_type = GLYR_TYPE_RELATION,
diff --git a/lib/intern/relations/generated.c b/lib/intern/relations/generated.c
index 03946c7..0413f6f 100644
--- a/lib/intern/relations/generated.c
+++ b/lib/intern/relations/generated.c
@@ -22,52 +22,57 @@
 
 /////////////////////////////////
 
-static GList *relations_generated_parse(cb_object *capo)
+static GList * relations_generated_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
-    GList *temple_list = NULL;
+    GList * result_list = NULL;
+    GList * temple_list = NULL;
 
-    if(capo->s->title && capo->s->album) {
-        temple_list = g_list_prepend(temple_list, "Musicbrainz Recording:http://musicbrainz.org/search?query=\"${title}\"+AND+artist%3A\"${artist}\"+AND+release%3A\"${album}\"&type=recording&advanced=1");
+    if (capo->s->title && capo->s->album)
+    {
+        temple_list = g_list_prepend (temple_list,"Musicbrainz Recording:http://musicbrainz.org/search?query=\"${title}\"+AND+artist%3A\"${artist}\"+AND+release%3A\"${album}\"&type=recording&advanced=1");
     }
 
-    if(capo->s->album) {
-        temple_list = g_list_prepend(temple_list, "Musicbrainz Album:http://musicbrainz.org/search?query=\"${album}\"+AND+artist%3A\"${artist}\"&type=release&advanced=1");
-        temple_list = g_list_prepend(temple_list, "Wikipedia Album:http://en.wikipedia.org/wiki/Special:Search/${album}(${artist})");
+    if (capo->s->album)
+    {
+        temple_list = g_list_prepend (temple_list,"Musicbrainz Album:http://musicbrainz.org/search?query=\"${album}\"+AND+artist%3A\"${artist}\"&type=release&advanced=1");
+        temple_list = g_list_prepend (temple_list,"Wikipedia Album:http://en.wikipedia.org/wiki/Special:Search/${album}(${artist})");
     }
 
-    temple_list = g_list_prepend(temple_list, "Musicbrainz Artist:http://musicbrainz.org/search?query=\"${artist}\"&type=artist");
-    temple_list = g_list_prepend(temple_list, "Wikipedia Artist:http://en.wikipedia.org/wiki/Special:Search/${artist}");
-    temple_list = g_list_prepend(temple_list, "Lastfm Page:http://last.fm/music/${artist}");
+    temple_list = g_list_prepend (temple_list,"Musicbrainz Artist:http://musicbrainz.org/search?query=\"${artist}\"&type=artist");
+    temple_list = g_list_prepend (temple_list,"Wikipedia Artist:http://en.wikipedia.org/wiki/Special:Search/${artist}");
+    temple_list = g_list_prepend (temple_list,"Lastfm Page:http://last.fm/music/${artist}");
 
-    for(GList *elem = temple_list; elem; elem = elem->next) {
-        gchar *result_url = prepare_url(elem->data, capo->s, TRUE);
-        if(result_url != NULL) {
-            GlyrMemCache *result = DL_init();
+    for (GList * elem = temple_list; elem; elem = elem->next)
+    {
+        gchar * result_url = prepare_url (elem->data, capo->s,TRUE);
+        if (result_url != NULL)
+        {
+            GlyrMemCache * result = DL_init();
             result->data = result_url;
-            result->size = strlen(result_url);
-            result->dsrc = g_strdup(OFFLINE_PROVIDER);
-            result->prov = g_strdup("generated");
+            result->size = strlen (result_url);
+            result->dsrc = g_strdup (OFFLINE_PROVIDER);
+            result->prov = g_strdup ("generated");
             result->type = GLYR_TYPE_RELATION;
-            update_md5sum(result);
-            result_list = g_list_prepend(result_list, result);
+            update_md5sum (result);
+            result_list = g_list_prepend (result_list, result);
         }
     }
 
-    g_list_free(temple_list);
+    g_list_free (temple_list);
     return result_list;
 }
 
 /////////////////////////////////
 
-static const gchar *relations_generated_url(GlyrQuery *sets)
+static const gchar * relations_generated_url (GlyrQuery * sets)
 {
     return OFFLINE_PROVIDER;
 }
 
 /////////////////////////////////
 
-MetaDataSource relations_generated_src = {
+MetaDataSource relations_generated_src =
+{
     .name = "generated",
     .key  = 'g',
     .parser    = relations_generated_parse,
diff --git a/lib/intern/relations/musicbrainz.c b/lib/intern/relations/musicbrainz.c
index 46fe48c..722de00 100644
--- a/lib/intern/relations/musicbrainz.c
+++ b/lib/intern/relations/musicbrainz.c
@@ -27,52 +27,58 @@
 #define RELATION_BEGIN_TYPE  "<relation"
 
 /* Wrap around the (a bit more) generic versions */
-static GList *relations_musicbrainz_parse(cb_object *capo)
+static GList * relations_musicbrainz_parse (cb_object * capo)
 {
-    GList *results = NULL;
+    GList * results = NULL;
     gint mbid_marker = 0;
-    while(continue_search(g_list_length(results), capo->s)) {
-        GlyrMemCache   *infobuf = generic_musicbrainz_parse(capo, &mbid_marker, "url-rels");
-        if(infobuf == NULL) {
+    while (continue_search (g_list_length (results), capo->s) )
+    {
+        GlyrMemCache  * infobuf = generic_musicbrainz_parse (capo,&mbid_marker,"url-rels");
+        if (infobuf == NULL)
+        {
             break;
         }
         gsize nlen = (sizeof RELATION_BEGIN_TYPE) - 1;
-        gchar *node = strstr(infobuf->data, RELATION_TARGLYR_GET_TYPE);
-        if(node != NULL) {
+        gchar * node = strstr (infobuf->data,RELATION_TARGLYR_GET_TYPE);
+        if (node != NULL)
+        {
             gint ctr = 0;
-            while(continue_search(ctr, capo->s) && (node = strstr(node + nlen, RELATION_BEGIN_TYPE))) {
+            while (continue_search (ctr,capo->s) && (node = strstr (node+nlen,RELATION_BEGIN_TYPE) ) )
+            {
                 node += nlen;
-                gchar *target = get_search_value(node, "target=\"", "\"");
-                gchar *type   = get_search_value(node, "type=\"", "\"");
+                gchar * target = get_search_value (node,"target=\"","\"");
+                gchar * type   = get_search_value (node,"type=\"","\"");
 
-                if(type != NULL && target != NULL) {
-                    GlyrMemCache *tmp = DL_init();
-                    tmp->data = g_strdup_printf("%s:%s", type, target);
-                    tmp->size = strlen(tmp->data);
-                    tmp->dsrc = g_strdup(infobuf->dsrc);
-                    results = g_list_prepend(results, tmp);
+                if (type != NULL && target != NULL)
+                {
+                    GlyrMemCache * tmp = DL_init();
+                    tmp->data = g_strdup_printf ("%s:%s",type,target);
+                    tmp->size = strlen (tmp->data);
+                    tmp->dsrc = g_strdup (infobuf->dsrc);
+                    results = g_list_prepend (results,tmp);
                     ctr++;
 
-                    g_free(type);
-                    g_free(target);
+                    g_free (type);
+                    g_free (target);
                 }
             }
         }
-        DL_free(infobuf);
+        DL_free (infobuf);
     }
     return results;
 }
 
 /////////////////////////////////
 
-static const gchar *relations_musicbrainz_url(GlyrQuery *sets)
+static const gchar * relations_musicbrainz_url (GlyrQuery * sets)
 {
-    return generic_musicbrainz_url(sets);
+    return generic_musicbrainz_url (sets);
 }
 
 /////////////////////////////////
 
-MetaDataSource relations_musicbrainz_src = {
+MetaDataSource relations_musicbrainz_src =
+{
     .name = "musicbrainz",
     .key  = 'm',
     .parser    = relations_musicbrainz_parse,
diff --git a/lib/intern/review.c b/lib/intern/review.c
index 76d2ebc..927feef 100644
--- a/lib/intern/review.c
+++ b/lib/intern/review.c
@@ -24,27 +24,30 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
     /* Fix up messy text, escape chars etc.  */
-    for(GList *elem = list; elem; elem = elem->next) {
-        GlyrMemCache *item = elem->data;
-        if(item != NULL) {
+    for (GList * elem = list; elem; elem = elem->next)
+    {
+        GlyrMemCache * item = elem->data;
+        if (item != NULL)
+        {
 
-            gchar *temp = beautify_string(item->data);
-            g_free(item->data);
+            gchar * temp = beautify_string (item->data);
+            g_free (item->data);
             item->data = temp;
-            item->size = (item->data) ? strlen(item->data) : 0;
+            item->size = (item->data) ? strlen (item->data) : 0;
         }
     }
 
-    return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_ALBUM_REVIEW, result_list);
+    return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_ALBUM_REVIEW,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_review = {
+MetaDataFetcher glyrFetcher_review =
+{
     .name = "albumreview",
     .type = GLYR_GET_ALBUM_REVIEW,
     .default_data_type = GLYR_TYPE_ALBUM_REVIEW,
diff --git a/lib/intern/review/amazon.c b/lib/intern/review/amazon.c
index 36f04c8..735bac3 100644
--- a/lib/intern/review/amazon.c
+++ b/lib/intern/review/amazon.c
@@ -21,29 +21,32 @@
 #include "../../stringlib.h"
 #include "../common/amazon.h"
 
-static const gchar *review_amazon_url(GlyrQuery *settings)
+static const gchar * review_amazon_url (GlyrQuery * settings)
 {
-    return generic_amazon_url(settings, "EditorialReview");
+    return generic_amazon_url (settings,"EditorialReview");
 }
 
 #define TheContent "<Content>"
 #define TheEndofCt "</Content>"
-static GList *review_amazon_parse(cb_object *capo)
+static GList * review_amazon_parse (cb_object * capo)
 {
-    gchar *node = capo->cache->data;
+    gchar * node = capo->cache->data;
     gsize conlen = (sizeof TheContent) - 1;
-    GList *result_list = NULL;
-    while(continue_search(g_list_length(result_list), capo->s) && (node = strstr(node + conlen, TheContent)) != NULL) {
-        gchar *endOfText = strstr(node + conlen, TheEndofCt);
-        gchar *text = copy_value(node + conlen, endOfText);
-        if(text != NULL) {
+    GList * result_list = NULL;
+    while (continue_search (g_list_length (result_list),capo->s) && (node = strstr (node+conlen,TheContent) ) != NULL)
+    {
+        gchar * endOfText = strstr (node+conlen,TheEndofCt);
+        gchar * text = copy_value (node+conlen,endOfText);
+        if (text != NULL)
+        {
             /* Ignore reviews with 350 chars
              * as mostly just advertisement */
-            if((endOfText - (node + conlen)) > 350) {
-                GlyrMemCache *result = DL_init();
+            if ( (endOfText - (node+conlen) ) > 350)
+            {
+                GlyrMemCache * result = DL_init();
                 result->data = text;
-                result->size = result->data ? strlen(result->data) : 0;
-                result_list = g_list_prepend(result_list, result);
+                result->size = result->data ? strlen (result->data) : 0;
+                result_list = g_list_prepend (result_list,result);
             }
         }
     }
@@ -52,7 +55,8 @@ static GList *review_amazon_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource review_amazon_src = {
+MetaDataSource review_amazon_src =
+{
     .name = "amazon",
     .key  = 'a',
     .parser    = review_amazon_parse,
diff --git a/lib/intern/review/echonest.c b/lib/intern/review/echonest.c
index bbd686b..79f57fc 100644
--- a/lib/intern/review/echonest.c
+++ b/lib/intern/review/echonest.c
@@ -24,21 +24,21 @@
 /* JSON Parsing */
 #include "../../jsmn/jsmn.h"
 
-static const gchar *review_echonest_url(GlyrQuery *s)
+static const gchar * review_echonest_url (GlyrQuery * s)
 {
     return "http://developer.echonest.com/api/v4/artist/reviews?api_key="API_KEY_ECHONEST"&results=${number}&format=json&name=${artist}";
 }
 
 /////////////////////////////////
 
-static int strip_escapes(char *text, int len)
+static int strip_escapes(char * text, int len) 
 {
     int offset = 0;
 
-    for(int i = 0; i < len; ++i) {
-        if(text[i] == '\\') {
+    for (int i = 0; i < len; ++i) {
+        if (text[i] == '\\') {
             ++i;
-            if(text[i] == 'n') {
+            if (text[i] == 'n') {
                 text[offset++] = '\n';
                 continue;
             }
@@ -51,11 +51,10 @@ static int strip_escapes(char *text, int len)
 
 /////////////////////////////////
 
-static GList *add_result(GList *results, cb_object *capo, char *url, char *summary, char *release)
-{
-    if(levenshtein_strnormcmp(capo->s, capo->s->album, release) <= capo->s->fuzzyness) {
-        if(strlen(summary) >= 125) {
-            GlyrMemCache *result = DL_init();
+static GList *add_result(GList *results, cb_object *capo, char *url, char *summary, char *release) {
+    if (levenshtein_strnormcmp(capo->s, capo->s->album, release) <= capo->s->fuzzyness) {
+        if (strlen(summary) >= 125) {
+            GlyrMemCache * result = DL_init();
             result->data = g_strdup_printf("%s\n \n \nRead more on: %s\n", summary, url);
             result->size = strlen(result->data);
             result->size -= strip_escapes(result->data, result->size);
@@ -67,9 +66,9 @@ static GList *add_result(GList *results, cb_object *capo, char *url, char *summa
 
 /////////////////////////////////
 
-static bool json_is_key(jsmntok_t tokens[], int current, char *json, char *key)
+static bool json_is_key(jsmntok_t tokens[], int current, char *json, char *key) 
 {
-    jsmntok_t *token = &tokens[current];
+    jsmntok_t * token = &tokens[current];
     return (token->type == JSMN_STRING &&
             g_ascii_strncasecmp(
                 json + token->start,
@@ -80,10 +79,10 @@ static bool json_is_key(jsmntok_t tokens[], int current, char *json, char *key)
 
 /////////////////////////////////
 
-static char *json_get_next_value(jsmntok_t tokens[], int current, char *json)
+static char * json_get_next_value(jsmntok_t tokens[], int current, char *json) 
 {
     jsmntok_t *next_token = &tokens[current + 1];
-    if(next_token != NULL && next_token->type == JSMN_STRING) {
+    if (next_token != NULL && next_token->type == JSMN_STRING) {
         return g_strndup(json + next_token->start, next_token->end - next_token->start);
     } else {
         return NULL;
@@ -97,14 +96,14 @@ static char *json_get_next_value(jsmntok_t tokens[], int current, char *json)
         g_free(name);                                     \
         name = json_get_next_value(tokens, i++, json);    \
     }                                                     \
- 
-static GList *review_echonest_parse(cb_object *capo)
+
+static GList * review_echonest_parse (cb_object * capo)
 {
-    char *json = capo->cache->data;
+    char * json = capo->cache->data;
     const int num_tokens = 512;
+    
 
-
-    GList *results = NULL;
+    GList * results = NULL;
 
     /* jasmin stuff */
     jsmn_parser parser;
@@ -126,9 +125,9 @@ static GList *review_echonest_parse(cb_object *capo)
     /* Save partial results here */
     char *url = NULL, *summary = NULL, *release = NULL;
 
-    if(error == JSMN_SUCCESS) {
-        for(int i = 0; i < num_tokens; ++i) {
-            jsmntok_t *token = &tokens[i];
+    if (error == JSMN_SUCCESS) {
+        for (int i = 0; i < num_tokens; ++i) {
+            jsmntok_t * token = &tokens[i];
 
             /* End of tokens? */
             if(token->start <= 0 && token->end <= 0) {
@@ -139,9 +138,9 @@ static GList *review_echonest_parse(cb_object *capo)
             JSON_GET_VALUE_IF_KEY(summary, "summary");
             JSON_GET_VALUE_IF_KEY(release, "release");
 
-            char *next_bracket = strchr(json + token->start, '}');
-            if(next_bracket > curr_bracket) {
-                if(url && summary && release) {
+            char * next_bracket = strchr(json + token->start, '}');
+            if (next_bracket > curr_bracket) {
+                if (url && summary && release) {
                     results = add_result(results, capo, url, summary, release);
                 }
                 curr_bracket = next_bracket;
@@ -149,7 +148,7 @@ static GList *review_echonest_parse(cb_object *capo)
 
         }
 
-        if(url && summary && release) {
+        if (url && summary && release) {
             results = add_result(results, capo, url, summary, release);
         }
 
@@ -165,7 +164,8 @@ static GList *review_echonest_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource review_echonest_src = {
+MetaDataSource review_echonest_src =
+{
     .name      = "echonest",
     .key       = 'e',
     .free_url  = false,
@@ -175,5 +175,5 @@ MetaDataSource review_echonest_src = {
     .quality   = 70,
     .speed     = 85,
     .endmarker = NULL,
-    .lang_aware = false
+    .lang_aware = false 
 };
diff --git a/lib/intern/review/metallum.c b/lib/intern/review/metallum.c
index c722f69..f79bc6f 100644
--- a/lib/intern/review/metallum.c
+++ b/lib/intern/review/metallum.c
@@ -28,7 +28,7 @@
     "&iColumns=3&sColumns=&iDisplayStart=0"                                \
     "&iDisplayLength=100&sNames=%%2C%%2C"
 
-static const gchar *review_metallum_url(GlyrQuery *s)
+static const gchar * review_metallum_url (GlyrQuery * s)
 {
     return AJAX_URL;
 }
@@ -36,54 +36,61 @@ static const gchar *review_metallum_url(GlyrQuery *s)
 #define REVIEW_START "<div class=\"reviewContent\">"
 #define REVIEW_END   "</div>"
 
-static void parse_review_site(GlyrQuery *s, GlyrMemCache *cache, GList **result_items)
+static void parse_review_site (GlyrQuery * s, GlyrMemCache * cache, GList ** result_items)
 {
-    if(cache != NULL) {
+    if (cache != NULL)
+    {
         gsize nodelen = (sizeof REVIEW_START) - 1;
-        gchar *node  = cache->data;
+        gchar * node  = cache->data;
 
-        while(continue_search(g_list_length(*result_items), s) && (node = strstr(node + nodelen, REVIEW_START)) != NULL) {
-            gchar *data = get_search_value(node, REVIEW_START, REVIEW_END);
-            if(data != NULL) {
-                GlyrMemCache *item = DL_init();
+        while (continue_search (g_list_length (*result_items),s) && (node = strstr (node+nodelen,REVIEW_START) ) != NULL)
+        {
+            gchar * data = get_search_value (node,REVIEW_START,REVIEW_END);
+            if (data != NULL)
+            {
+                GlyrMemCache * item = DL_init();
 
-                gchar *kill_br = strreplace(data, "  <br />\n", "");
-                item->data = strreplace(kill_br, ".  ", ".\n");
-                item->size = strlen(item->data);
-                item->dsrc = g_strdup(cache->dsrc);
-                *result_items = g_list_prepend(*result_items, item);
+                gchar * kill_br = strreplace (data,"  <br />\n","");
+                item->data = strreplace (kill_br,".  ",".\n");
+                item->size = strlen (item->data);
+                item->dsrc = g_strdup (cache->dsrc);
+                *result_items = g_list_prepend (*result_items, item);
 
-                g_free(kill_br);
-                g_free(data);
+                g_free (kill_br);
+                g_free (data);
             }
         }
-        DL_free(cache);
+        DL_free (cache);
     }
 }
 
 #define NODE_START "\"<a href=\\\""
 #define NODE_END "\\\">"
 
-static GList *review_metallum_parse(cb_object *capo)
+static GList * review_metallum_parse (cb_object * capo)
 {
-    GList *result_items = NULL;
+    GList * result_items = NULL;
 
-    gsize nodelen = strlen(NODE_START);
-    gchar *node  = capo->cache->data;
+    gsize nodelen = strlen (NODE_START);
+    gchar * node  = capo->cache->data;
     gint node_ctr = 0;
 
-    while((node = strstr(node + nodelen, NODE_START)) != NULL) {
+    while ( (node = strstr (node+nodelen,NODE_START) ) != NULL)
+    {
         /* Only take the album url, not the other urls */
-        if(++node_ctr % 2 == 0) {
+        if (++node_ctr % 2 == 0)
+        {
             node += nodelen;
-            gchar *content_url = copy_value(node, strstr(node, NODE_END));
-            if(content_url != NULL) {
-                gchar *review_url = strreplace(content_url, "/albums/", "/reviews/");
-                if(review_url != NULL) {
-                    parse_review_site(capo->s, download_single(review_url, capo->s, NULL), &result_items);
-                    g_free(review_url);
+            gchar * content_url = copy_value (node,strstr (node,NODE_END) );
+            if (content_url != NULL)
+            {
+                gchar * review_url = strreplace (content_url,"/albums/","/reviews/");
+                if (review_url != NULL)
+                {
+                    parse_review_site (capo->s, download_single (review_url,capo->s,NULL), &result_items);
+                    g_free (review_url);
                 }
-                g_free(content_url);
+                g_free (content_url);
             }
         }
     }
@@ -91,7 +98,8 @@ static GList *review_metallum_parse(cb_object *capo)
 }
 
 
-MetaDataSource review_metallum_src = {
+MetaDataSource review_metallum_src =
+{
     .name = "metallum",
     .key  = 'e',
     .parser    = review_metallum_parse,
diff --git a/lib/intern/similar_artist.c b/lib/intern/similar_artist.c
index 8a3def7..d0ce6af 100644
--- a/lib/intern/similar_artist.c
+++ b/lib/intern/similar_artist.c
@@ -24,15 +24,16 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
-    return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_SIMILAR_SONG, result_list);
+    return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_SIMILAR_SONG,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_similar_artists = {
+MetaDataFetcher glyrFetcher_similar_artists =
+{
     .name = "similarartists",
     .type = GLYR_GET_SIMILAR_ARTISTS,
     .default_data_type = GLYR_TYPE_SIMILAR_ARTIST,
diff --git a/lib/intern/similar_artist/lastfm.c b/lib/intern/similar_artist/lastfm.c
index 9de4e3f..0139a8c 100644
--- a/lib/intern/similar_artist/lastfm.c
+++ b/lib/intern/similar_artist/lastfm.c
@@ -22,7 +22,7 @@
 
 #define API_KEY API_KEY_LASTFM
 
-static const char *similar_lastfm_url(GlyrQuery *sets)
+static const char * similar_lastfm_url (GlyrQuery * sets)
 {
     return "http://ws.audioscrobbler.com/2.0/?method=artist.getsimilar&artist=${artist}&api_key="API_KEY;
 }
@@ -43,48 +43,52 @@ static const char *similar_lastfm_url(GlyrQuery *sets)
 #define IMAGE_X_BEGIN "<image size=\"mega\">"
 #define IMAGE_ENDIN   "</image>"
 
-static GList *similar_lastfm_parse(cb_object *capo)
+static GList * similar_lastfm_parse (cb_object * capo)
 {
-    GList *results = NULL;
-    gchar *find = capo->cache->data;
-    while(continue_search(g_list_length(results), capo->s) && (find = strstr(find + 1, "<artist>")) != NULL) {
-        gchar *name  = get_search_value(find, NAME_BEGIN, NAME_ENDIN);
-        gchar *match = get_search_value(find, MATCH_BEGIN, MATCH_ENDIN);
-        gchar *url   = get_search_value(find, URL_BEGIN, URL_ENDIN);
+    GList * results = NULL;
+    gchar * find = capo->cache->data;
+    while (continue_search (g_list_length (results),capo->s) && (find = strstr (find+1, "<artist>") ) != NULL)
+    {
+        gchar * name  = get_search_value (find,NAME_BEGIN,NAME_ENDIN);
+        gchar * match = get_search_value (find,MATCH_BEGIN,MATCH_ENDIN);
+        gchar * url   = get_search_value (find,URL_BEGIN,URL_ENDIN);
 
-        gchar *img_s = get_search_value(find, IMAGE_S_BEGIN, IMAGE_ENDIN);
-        gchar *img_m = get_search_value(find, IMAGE_M_BEGIN, IMAGE_ENDIN);
-        gchar *img_l = get_search_value(find, IMAGE_L_BEGIN, IMAGE_ENDIN);
-        gchar *img_e = get_search_value(find, IMAGE_E_BEGIN, IMAGE_ENDIN);
-        gchar *img_x = get_search_value(find, IMAGE_X_BEGIN, IMAGE_ENDIN);
-        gchar *composed = g_strdup_printf("%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n", name, match, url, img_s, img_m, img_l, img_e, img_x);
+        gchar * img_s = get_search_value (find,IMAGE_S_BEGIN,IMAGE_ENDIN);
+        gchar * img_m = get_search_value (find,IMAGE_M_BEGIN,IMAGE_ENDIN);
+        gchar * img_l = get_search_value (find,IMAGE_L_BEGIN,IMAGE_ENDIN);
+        gchar * img_e = get_search_value (find,IMAGE_E_BEGIN,IMAGE_ENDIN);
+        gchar * img_x = get_search_value (find,IMAGE_X_BEGIN,IMAGE_ENDIN);
+        gchar * composed = g_strdup_printf ("%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n",name,match,url,img_s,img_m,img_l,img_e,img_x);
 
-        if(composed != NULL) {
-            GlyrMemCache *result = DL_init();
+        if (composed != NULL)
+        {
+            GlyrMemCache * result = DL_init();
             result->data = composed;
-            result->size = strlen(composed);
-            results = g_list_prepend(results, result);
+            result->size = strlen (composed);
+            results = g_list_prepend (results, result);
         }
 
-        if(results != NULL) {
-            results = g_list_reverse(results);
+        if (results != NULL)
+        {
+            results = g_list_reverse (results);
         }
 
-        g_free(name);
-        g_free(match);
-        g_free(url);
-        g_free(img_s);
-        g_free(img_m);
-        g_free(img_l);
-        g_free(img_e);
-        g_free(img_x);
+        g_free (name);
+        g_free (match);
+        g_free (url);
+        g_free (img_s);
+        g_free (img_m);
+        g_free (img_l);
+        g_free (img_e);
+        g_free (img_x);
     }
     return results;
 }
 
 /////////////////////////////////
 
-MetaDataSource similar_artist_lastfm_src = {
+MetaDataSource similar_artist_lastfm_src =
+{
     .name = "lastfm",
     .key  = 'l',
     .parser    = similar_lastfm_parse,
diff --git a/lib/intern/similar_song.c b/lib/intern/similar_song.c
index 2a1f726..fd12596 100644
--- a/lib/intern/similar_song.c
+++ b/lib/intern/similar_song.c
@@ -24,15 +24,16 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
-    return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_SIMILAR_SONG, result_list);
+    return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_SIMILAR_SONG,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_similar_song = {
+MetaDataFetcher glyrFetcher_similar_song =
+{
     .name = "similarsongs",
     .type = GLYR_GET_SIMILAR_SONGS,
     .default_data_type = GLYR_TYPE_SIMILAR_SONG,
diff --git a/lib/intern/similar_song/lastfm.c b/lib/intern/similar_song/lastfm.c
index b98b069..d05dc87 100644
--- a/lib/intern/similar_song/lastfm.c
+++ b/lib/intern/similar_song/lastfm.c
@@ -20,7 +20,7 @@
 #include "../../stringlib.h"
 #include "../../core.h"
 
-static const gchar *similar_song_lastfm_url(GlyrQuery *sets)
+static const gchar * similar_song_lastfm_url (GlyrQuery * sets)
 {
     return  "http://ws.audioscrobbler.com/2.0/?method=track.getsimilar&artist=${artist}&track=${title}&api_key="API_KEY_LASTFM;
 }
@@ -38,37 +38,40 @@ static const gchar *similar_song_lastfm_url(GlyrQuery *sets)
 #define URL_BEGIN "<url>"
 #define URL_ENDIN "</url>"
 
-static GList *similar_song_lastfm_parse(cb_object *capo)
+static GList * similar_song_lastfm_parse (cb_object * capo)
 {
-    GList *results = NULL;
-    gchar *begin = capo->cache->data;
+    GList * results = NULL;
+    gchar * begin = capo->cache->data;
 
-    while(continue_search(g_list_length(results), capo->s) && (begin = strstr(begin, TRACK_BEGIN)) != NULL) {
-        gchar *track  = get_search_value(begin, NAME_BEGIN, NAME_ENDIN);
-        gchar *match  = get_search_value(begin, MATCH_BEGIN, MATCH_ENDIN);
-        gchar *url    = get_search_value(begin, URL_BEGIN, URL_ENDIN);
-        gchar *artist = get_search_value(strstr(begin, ARTIST_BEGIN), NAME_BEGIN, NAME_ENDIN);
+    while (continue_search (g_list_length (results),capo->s) && (begin = strstr (begin, TRACK_BEGIN) ) != NULL)
+    {
+        gchar * track  = get_search_value (begin,NAME_BEGIN,NAME_ENDIN);
+        gchar * match  = get_search_value (begin,MATCH_BEGIN,MATCH_ENDIN);
+        gchar * url    = get_search_value (begin,URL_BEGIN,URL_ENDIN);
+        gchar * artist = get_search_value (strstr (begin,ARTIST_BEGIN),NAME_BEGIN,NAME_ENDIN);
 
-        if(artist && track) {
-            GlyrMemCache *result = DL_init();
-            result->data = g_strdup_printf("%s\n%s\n%s\n%s\n", track, artist, match, url);
-            result->size = strlen(result->data);
-            results = g_list_prepend(results, result);
+        if (artist && track)
+        {
+            GlyrMemCache * result = DL_init();
+            result->data = g_strdup_printf ("%s\n%s\n%s\n%s\n",track,artist,match,url);
+            result->size = strlen (result->data);
+            results = g_list_prepend (results, result);
         }
 
-        g_free(track);
-        g_free(artist);
-        g_free(match);
-        g_free(url);
+        g_free (track);
+        g_free (artist);
+        g_free (match);
+        g_free (url);
 
-        begin += sizeof(TRACK_BEGIN) - 1;
+        begin += sizeof (TRACK_BEGIN) - 1;
     }
     return results;
 }
 
 /////////////////////////////////
 
-MetaDataSource similar_song_lastfm_src = {
+MetaDataSource similar_song_lastfm_src =
+{
     .name = "lastfm",
     .key  = 'l',
     .parser    = similar_song_lastfm_parse,
diff --git a/lib/intern/tags.c b/lib/intern/tags.c
index fdb8170..26742f1 100644
--- a/lib/intern/tags.c
+++ b/lib/intern/tags.c
@@ -24,15 +24,16 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
-    return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_TAG, result_list);
+    return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_TAG,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_tags = {
+MetaDataFetcher glyrFetcher_tags =
+{
     .name = "tags",
     .type = GLYR_GET_TAGS,
     .default_data_type = GLYR_TYPE_TAG,
diff --git a/lib/intern/tags/musicbrainz.c b/lib/intern/tags/musicbrainz.c
index cd1bcf5..bf042d4 100644
--- a/lib/intern/tags/musicbrainz.c
+++ b/lib/intern/tags/musicbrainz.c
@@ -35,58 +35,62 @@ artist && album          -> album
 /////////////////////////////////
 
 /* Wrap around the (a bit more) generic versions */
-static GList *tags_musicbrainz_parse(cb_object *capo)
+static GList * tags_musicbrainz_parse (cb_object * capo)
 {
-    GList *results = NULL;
+    GList * results = NULL;
     gint mbid_marker = 0;
-    while(continue_search(g_list_length(results), capo->s)) {
-        GlyrMemCache   *info = generic_musicbrainz_parse(capo, &mbid_marker, "tags");
-        if(info == NULL) {
+    while (continue_search (g_list_length (results), capo->s) )
+    {
+        GlyrMemCache  * info = generic_musicbrainz_parse (capo,&mbid_marker,"tags");
+        if (info == NULL)
+        {
             break;
         }
 
-        gint type_num = please_what_type(capo->s);
-        gchar *tag_node = info->data;
-        while((tag_node = strstr(tag_node + 1, "<tag"))) {
-            gchar *tag_begin = strchr(tag_node + 1, '>');
-            if(!tag_begin) {
+        gint type_num = please_what_type (capo->s);
+        gchar * tag_node = info->data;
+        while ( (tag_node = strstr (tag_node + 1,"<tag") ) )
+        {
+            gchar * tag_begin = strchr (tag_node+1,'>');
+            if (!tag_begin)
                 continue;
-            }
 
             tag_begin++;
-            gchar *tag_endin = strchr(tag_begin, '<');
-            if(!tag_endin) {
+            gchar * tag_endin = strchr (tag_begin,'<');
+            if (!tag_endin)
                 continue;
-            }
 
-            gchar *value = copy_value(tag_begin, tag_endin);
-            if(value != NULL) {
-                if(strlen(value) > 0) {
-                    GlyrMemCache *tmp = DL_init();
+            gchar * value = copy_value (tag_begin,tag_endin);
+            if (value != NULL)
+            {
+                if (strlen (value) > 0)
+                {
+                    GlyrMemCache * tmp = DL_init();
                     tmp->data = value;
                     tmp->size = tag_endin - tag_begin;
                     tmp->type = type_num;
-                    tmp->dsrc = g_strdup(info->dsrc);
+                    tmp->dsrc = g_strdup (info->dsrc);
 
-                    results = g_list_prepend(results, tmp);
+                    results = g_list_prepend (results,tmp);
                 }
             }
         }
-        DL_free(info);
+        DL_free (info);
     }
     return results;
 }
 
 /////////////////////////////////
 
-static const gchar *tags_musicbrainz_url(GlyrQuery *sets)
+static const gchar * tags_musicbrainz_url (GlyrQuery * sets)
 {
-    return generic_musicbrainz_url(sets);
+    return generic_musicbrainz_url (sets);
 }
 
 /////////////////////////////////
 
-MetaDataSource tags_musicbrainz_src = {
+MetaDataSource tags_musicbrainz_src =
+{
     .name = "musicbrainz",
     .key  = 'm',
     .parser    = tags_musicbrainz_parse,
diff --git a/lib/intern/tracklist.c b/lib/intern/tracklist.c
index 99b3ca4..551a9fa 100644
--- a/lib/intern/tracklist.c
+++ b/lib/intern/tracklist.c
@@ -24,15 +24,16 @@
 
 /////////////////////////////////
 
-static GList *factory(GlyrQuery *s, GList *list, gboolean *stop_me, GList **result_list)
+static GList * factory (GlyrQuery * s, GList * list, gboolean * stop_me, GList ** result_list)
 {
-    return generic_txt_finalizer(s, list, stop_me, GLYR_TYPE_TRACK, result_list);
+    return generic_txt_finalizer (s,list,stop_me,GLYR_TYPE_TRACK,result_list);
 }
 
 /////////////////////////////////
 
 /* PlugStruct */
-MetaDataFetcher glyrFetcher_tracklist = {
+MetaDataFetcher glyrFetcher_tracklist =
+{
     .name = "tracklist",
     .type = GLYR_GET_TRACKLIST,
     .default_data_type = GLYR_TYPE_TRACK,
diff --git a/lib/intern/tracklist/musicbrainz.c b/lib/intern/tracklist/musicbrainz.c
index 824b67c..dd51428 100644
--- a/lib/intern/tracklist/musicbrainz.c
+++ b/lib/intern/tracklist/musicbrainz.c
@@ -20,7 +20,7 @@
 #include "../../stringlib.h"
 #include "../../core.h"
 
-static const gchar *tracklist_musicbrainz_url(GlyrQuery *sets)
+static const gchar * tracklist_musicbrainz_url (GlyrQuery * sets)
 {
     return "http://musicbrainz.org/ws/1/release/?type=xml&artist=${artist}&releasetypes=Official&limit=10&title=${album}&limit=1";
 }
@@ -38,30 +38,32 @@ static const gchar *tracklist_musicbrainz_url(GlyrQuery *sets)
 
 /////////////////////////////////
 
-static GList *traverse_xml(const gchar *data, const gchar *url, cb_object *capo)
+static GList * traverse_xml (const gchar * data, const gchar * url, cb_object * capo)
 {
-    gchar *beg = (gchar *) data;
-    GList *collection = NULL;
+    gchar * beg = (gchar*) data;
+    GList * collection = NULL;
     gint item_ctr = 0;
 
     /* Hop over album title */
-    beg = strstr(beg, TIT_BEGIN);
+    beg = strstr (beg,TIT_BEGIN);
 
-    while(continue_search(item_ctr, capo->s) && (beg = strstr(beg + (sizeof TIT_BEGIN) - 1, TIT_BEGIN)) != NULL) {
-        gchar *dy;
-        gchar *value = copy_value(beg + (sizeof TIT_BEGIN) - 1, strstr(beg, TIT_ENDIN));
-        gchar *durat = copy_value(strstr(beg, DUR_BEGIN) + (sizeof DUR_BEGIN) - 1, (dy = strstr(beg, DUR_ENDIN)));
-        if(value != NULL && durat != NULL) {
-            GlyrMemCache *cont = DL_init();
+    while (continue_search (item_ctr,capo->s) && (beg = strstr (beg + (sizeof TIT_BEGIN) - 1,TIT_BEGIN) ) != NULL)
+    {
+        gchar * dy;
+        gchar * value = copy_value (beg+ (sizeof TIT_BEGIN) - 1,strstr (beg,TIT_ENDIN) );
+        gchar * durat = copy_value (strstr (beg,DUR_BEGIN) + (sizeof DUR_BEGIN) - 1, (dy = strstr (beg,DUR_ENDIN) ) );
+        if (value != NULL && durat != NULL)
+        {
+            GlyrMemCache * cont = DL_init();
             cont->data = value;
-            cont->size = strlen(cont->data);
-            cont->duration = strtol(durat, NULL, 10) / 1e3;
-            cont->dsrc = g_strdup(url);
-            collection = g_list_prepend(collection, cont);
+            cont->size = strlen (cont->data);
+            cont->duration = strtol (durat,NULL,10) / 1e3;
+            cont->dsrc = g_strdup (url);
+            collection = g_list_prepend (collection,cont);
 
             /* free & jump to next */
             item_ctr++;
-            g_free(durat);
+            g_free (durat);
             beg = dy;
         }
     }
@@ -70,25 +72,29 @@ static GList *traverse_xml(const gchar *data, const gchar *url, cb_object *capo)
 
 /////////////////////////////////
 
-static GList *tracklist_musicbrainz_parse(cb_object *capo)
+static GList * tracklist_musicbrainz_parse (cb_object * capo)
 {
-    GList *result_list = NULL;
+    GList * result_list = NULL;
 
-    gchar *rel_id_begin = strstr(capo->cache->data, REL_ID_BEGIN);
-    if(rel_id_begin != NULL) {
-        gchar *release_ID = get_search_value(rel_id_begin, REL_ID_BEGIN, REL_ID_ENDIN);
-        if(release_ID != NULL) {
-            gchar *release_page_info_url = g_strdup_printf(REL_ID_FORM, release_ID);
-            GlyrMemCache *dlData = download_single(release_page_info_url, capo->s, NULL);
-            if(dlData != NULL) {
-                result_list = traverse_xml(dlData->data, capo->url, capo);
-                if(result_list != NULL) {
-                    result_list = g_list_reverse(result_list);
+    gchar * rel_id_begin = strstr (capo->cache->data,REL_ID_BEGIN);
+    if (rel_id_begin != NULL)
+    {
+        gchar * release_ID = get_search_value (rel_id_begin,REL_ID_BEGIN,REL_ID_ENDIN);
+        if (release_ID != NULL)
+        {
+            gchar * release_page_info_url = g_strdup_printf (REL_ID_FORM, release_ID);
+            GlyrMemCache * dlData = download_single (release_page_info_url,capo->s,NULL);
+            if (dlData != NULL)
+            {
+                result_list = traverse_xml (dlData->data,capo->url,capo);
+                if (result_list != NULL)
+                {
+                    result_list = g_list_reverse (result_list);
                 }
-                DL_free(dlData);
+                DL_free (dlData);
             }
-            g_free(release_page_info_url);
-            g_free(release_ID);
+            g_free (release_page_info_url);
+            g_free (release_ID);
         }
     }
     return result_list;
@@ -96,7 +102,8 @@ static GList *tracklist_musicbrainz_parse(cb_object *capo)
 
 /////////////////////////////////
 
-MetaDataSource tracklist_musicbrainz_src = {
+MetaDataSource tracklist_musicbrainz_src =
+{
     .name = "musicbrainz",
     .key  = 'm',
     .parser    = tracklist_musicbrainz_parse,
diff --git a/lib/jsmn/jsmn.c b/lib/jsmn/jsmn.c
index 7c8295b..5e2d40e 100644
--- a/lib/jsmn/jsmn.c
+++ b/lib/jsmn/jsmn.c
@@ -5,295 +5,251 @@
 /**
  * Allocates a fresh unused token from the token pull.
  */
-static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser,
-                                   jsmntok_t *tokens, size_t num_tokens)
-{
-    jsmntok_t *tok;
-    if(parser->toknext >= (int) num_tokens) {
-        return NULL;
-    }
-    tok = &tokens[parser->toknext++];
-    tok->start = tok->end = -1;
-    tok->size = 0;
+static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, 
+		jsmntok_t *tokens, size_t num_tokens) {
+	jsmntok_t *tok;
+	if (parser->toknext >= (int)num_tokens) {
+		return NULL;
+	}
+	tok = &tokens[parser->toknext++];
+	tok->start = tok->end = -1;
+	tok->size = 0;
 #ifdef JSMN_PARENT_LINKS
-    tok->parent = -1;
+	tok->parent = -1;
 #endif
-    return tok;
+	return tok;
 }
 
 /**
  * Fills token type and boundaries.
  */
-static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type,
-                            int start, int end)
-{
-    token->type = type;
-    token->start = start;
-    token->end = end;
-    token->size = 0;
+static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type, 
+                            int start, int end) {
+	token->type = type;
+	token->start = start;
+	token->end = end;
+	token->size = 0;
 }
 
 /**
  * Fills next available token with JSON primitive.
  */
 static jsmnerr_t jsmn_parse_primitive(jsmn_parser *parser, const char *js,
-                                      jsmntok_t *tokens, size_t num_tokens)
-{
-    jsmntok_t *token;
-    int start;
+		jsmntok_t *tokens, size_t num_tokens) {
+	jsmntok_t *token;
+	int start;
 
-    start = parser->pos;
+	start = parser->pos;
 
-    for(; js[parser->pos] != '\0'; parser->pos++) {
-        switch(js[parser->pos]) {
+	for (; js[parser->pos] != '\0'; parser->pos++) {
+		switch (js[parser->pos]) {
 #ifndef JSMN_STRICT
-        /* In strict mode primitive must be followed by ",  or "}" or "]" */
-        case ':':
+			/* In strict mode primitive must be followed by "," or "}" or "]" */
+			case ':':
 #endif
-        case '\t' :
-        case '\r' :
-        case '\n' :
-        case ' ' :
-        case ',   :
-        case ']'  :
-        case '}' :
-            goto found;
-        }
-        if(js[parser->pos] < 32 || js[parser->pos] >= 127) {
-            parser->pos = start;
-            return JSMN_ERROR_INVAL;
-        }
-    }
+			case '\t' : case '\r' : case '\n' : case ' ' :
+			case ','  : case ']'  : case '}' :
+				goto found;
+		}
+		if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
+			parser->pos = start;
+			return JSMN_ERROR_INVAL;
+		}
+	}
 #ifdef JSMN_STRICT
-    /* In strict mode primitive must be followed by a comma/object/array */
-    parser->pos = start;
-    return JSMN_ERROR_PART;
+	/* In strict mode primitive must be followed by a comma/object/array */
+	parser->pos = start;
+	return JSMN_ERROR_PART;
 #endif
 
 found:
-    token = jsmn_alloc_token(parser, tokens, num_tokens);
-    if(token == NULL) {
-        parser->pos = start;
-        return JSMN_ERROR_NOMEM;
-    }
-    jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
+	token = jsmn_alloc_token(parser, tokens, num_tokens);
+	if (token == NULL) {
+		parser->pos = start;
+		return JSMN_ERROR_NOMEM;
+	}
+	jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
 #ifdef JSMN_PARENT_LINKS
-    token->parent = parser->toksuper;
+	token->parent = parser->toksuper;
 #endif
-    parser->pos--;
-    return JSMN_SUCCESS;
+	parser->pos--;
+	return JSMN_SUCCESS;
 }
 
 /**
  * Filsl next token with JSON string.
  */
 static jsmnerr_t jsmn_parse_string(jsmn_parser *parser, const char *js,
-                                   jsmntok_t *tokens, size_t num_tokens)
-{
-    jsmntok_t *token;
+		jsmntok_t *tokens, size_t num_tokens) {
+	jsmntok_t *token;
 
-    int start = parser->pos;
+	int start = parser->pos;
 
-    parser->pos++;
+	parser->pos++;
 
-    /* Skip starting quote */
-    for(; js[parser->pos] != '\0'; parser->pos++) {
-        char c = js[parser->pos];
+	/* Skip starting quote */
+	for (; js[parser->pos] != '\0'; parser->pos++) {
+		char c = js[parser->pos];
 
-        /* Quote: end of string */
-        if(c == '\"') {
-            token = jsmn_alloc_token(parser, tokens, num_tokens);
-            if(token == NULL) {
-                parser->pos = start;
-                return JSMN_ERROR_NOMEM;
-            }
-            jsmn_fill_token(token, JSMN_STRING, start + 1, parser->pos);
+		/* Quote: end of string */
+		if (c == '\"') {
+			token = jsmn_alloc_token(parser, tokens, num_tokens);
+			if (token == NULL) {
+				parser->pos = start;
+				return JSMN_ERROR_NOMEM;
+			}
+			jsmn_fill_token(token, JSMN_STRING, start+1, parser->pos);
 #ifdef JSMN_PARENT_LINKS
-            token->parent = parser->toksuper;
+			token->parent = parser->toksuper;
 #endif
-            return JSMN_SUCCESS;
-        }
-
-        /* Backslash: Quoted symbol expected */
-        if(c == '\\') {
-            parser->pos++;
-            switch(js[parser->pos]) {
-            /* Allowed escaped symbols */
-            case '\"':
-            case '/' :
-            case '\\' :
-            case 'b' :
-            case 'f' :
-            case 'r' :
-            case 'n'  :
-            case 't' :
-                break;
-            /* Allows escaped symbol \uXXXX */
-            case 'u':
-                /* TODO */
-                break;
-            /* Unexpected symbol */
-            default:
-                parser->pos = start;
-                return JSMN_ERROR_INVAL;
-            }
-        }
-    }
-    parser->pos = start;
-    return JSMN_ERROR_PART;
+			return JSMN_SUCCESS;
+		}
+
+		/* Backslash: Quoted symbol expected */
+		if (c == '\\') {
+			parser->pos++;
+			switch (js[parser->pos]) {
+				/* Allowed escaped symbols */
+				case '\"': case '/' : case '\\' : case 'b' :
+				case 'f' : case 'r' : case 'n'  : case 't' :
+					break;
+				/* Allows escaped symbol \uXXXX */
+				case 'u':
+					/* TODO */
+					break;
+				/* Unexpected symbol */
+				default:
+					parser->pos = start;
+					return JSMN_ERROR_INVAL;
+			}
+		}
+	}
+	parser->pos = start;
+	return JSMN_ERROR_PART;
 }
 
 /**
  * Parse JSON string and fill tokens.
  */
-jsmnerr_t jsmn_parse(jsmn_parser *parser, const char *js, jsmntok_t *tokens,
-                     unsigned int num_tokens)
-{
-    jsmnerr_t r;
-    int i;
-    jsmntok_t *token;
-
-    for(; js[parser->pos] != '\0'; parser->pos++) {
-        char c;
-        jsmntype_t type;
-
-        c = js[parser->pos];
-        switch(c) {
-        case '{':
-        case '[':
-            token = jsmn_alloc_token(parser, tokens, num_tokens);
-            if(token == NULL) {
-                return JSMN_ERROR_NOMEM;
-            }
-            if(parser->toksuper != -1) {
-                tokens[parser->toksuper].size++;
+jsmnerr_t jsmn_parse(jsmn_parser *parser, const char *js, jsmntok_t *tokens, 
+		unsigned int num_tokens) {
+	jsmnerr_t r;
+	int i;
+	jsmntok_t *token;
+
+	for (; js[parser->pos] != '\0'; parser->pos++) {
+		char c;
+		jsmntype_t type;
+
+		c = js[parser->pos];
+		switch (c) {
+			case '{': case '[':
+				token = jsmn_alloc_token(parser, tokens, num_tokens);
+				if (token == NULL)
+					return JSMN_ERROR_NOMEM;
+				if (parser->toksuper != -1) {
+					tokens[parser->toksuper].size++;
 #ifdef JSMN_PARENT_LINKS
-                token->parent = parser->toksuper;
+					token->parent = parser->toksuper;
 #endif
-            }
-            token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
-            token->start = parser->pos;
-            parser->toksuper = parser->toknext - 1;
-            break;
-        case '}':
-        case ']':
-            type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
+				}
+				token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
+				token->start = parser->pos;
+				parser->toksuper = parser->toknext - 1;
+				break;
+			case '}': case ']':
+				type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
 #ifdef JSMN_PARENT_LINKS
-            if(parser->toknext < 1) {
-                return JSMN_ERROR_INVAL;
-            }
-            token = &tokens[parser->toknext - 1];
-            for(;;) {
-                if(token->start != -1 && token->end == -1) {
-                    if(token->type != type) {
-                        return JSMN_ERROR_INVAL;
-                    }
-                    token->end = parser->pos + 1;
-                    parser->toksuper = token->parent;
-                    break;
-                }
-                if(token->parent == -1) {
-                    break;
-                }
-                token = &tokens[token->parent];
-            }
+				if (parser->toknext < 1) {
+					return JSMN_ERROR_INVAL;
+				}
+				token = &tokens[parser->toknext - 1];
+				for (;;) {
+					if (token->start != -1 && token->end == -1) {
+						if (token->type != type) {
+							return JSMN_ERROR_INVAL;
+						}
+						token->end = parser->pos + 1;
+						parser->toksuper = token->parent;
+						break;
+					}
+					if (token->parent == -1) {
+						break;
+					}
+					token = &tokens[token->parent];
+				}
 #else
-            for(i = parser->toknext - 1; i >= 0; i--) {
-                token = &tokens[i];
-                if(token->start != -1 && token->end == -1) {
-                    if(token->type != type) {
-                        return JSMN_ERROR_INVAL;
-                    }
-                    parser->toksuper = -1;
-                    token->end = parser->pos + 1;
-                    break;
-                }
-            }
-            /* Error if unmatched closing bracket */
-            if(i == -1) {
-                return JSMN_ERROR_INVAL;
-            }
-            for(; i >= 0; i--) {
-                token = &tokens[i];
-                if(token->start != -1 && token->end == -1) {
-                    parser->toksuper = i;
-                    break;
-                }
-            }
+				for (i = parser->toknext - 1; i >= 0; i--) {
+					token = &tokens[i];
+					if (token->start != -1 && token->end == -1) {
+						if (token->type != type) {
+							return JSMN_ERROR_INVAL;
+						}
+						parser->toksuper = -1;
+						token->end = parser->pos + 1;
+						break;
+					}
+				}
+				/* Error if unmatched closing bracket */
+				if (i == -1) return JSMN_ERROR_INVAL;
+				for (; i >= 0; i--) {
+					token = &tokens[i];
+					if (token->start != -1 && token->end == -1) {
+						parser->toksuper = i;
+						break;
+					}
+				}
 #endif
-            break;
-        case '\"':
-            r = jsmn_parse_string(parser, js, tokens, num_tokens);
-            if(r < 0) {
-                return r;
-            }
-            if(parser->toksuper != -1) {
-                tokens[parser->toksuper].size++;
-            }
-            break;
-        case '\t' :
-        case '\r' :
-        case '\n' :
-        case ':' :
-        case ', :
-        case ' ':
-            break;
+				break;
+			case '\"':
+				r = jsmn_parse_string(parser, js, tokens, num_tokens);
+				if (r < 0) return r;
+				if (parser->toksuper != -1)
+					tokens[parser->toksuper].size++;
+				break;
+			case '\t' : case '\r' : case '\n' : case ':' : case ',': case ' ': 
+				break;
 #ifdef JSMN_STRICT
-        /* In strict mode primitives are: numbers and booleans */
-        case '-':
-        case '0':
-        case '1' :
-        case '2':
-        case '3' :
-        case '4':
-        case '5':
-        case '6':
-        case '7' :
-        case '8':
-        case '9':
-        case 't':
-        case 'f':
-        case 'n' :
+			/* In strict mode primitives are: numbers and booleans */
+			case '-': case '0': case '1' : case '2': case '3' : case '4':
+			case '5': case '6': case '7' : case '8': case '9':
+			case 't': case 'f': case 'n' :
 #else
-        /* In non-strict mode every unquoted value is a primitive */
-        default:
+			/* In non-strict mode every unquoted value is a primitive */
+			default:
 #endif
-            r = jsmn_parse_primitive(parser, js, tokens, num_tokens);
-            if(r < 0) {
-                return r;
-            }
-            if(parser->toksuper != -1) {
-                tokens[parser->toksuper].size++;
-            }
-            break;
+				r = jsmn_parse_primitive(parser, js, tokens, num_tokens);
+				if (r < 0) return r;
+				if (parser->toksuper != -1)
+					tokens[parser->toksuper].size++;
+				break;
 
 #ifdef JSMN_STRICT
-        /* Unexpected char in strict mode */
-        default:
-            return JSMN_ERROR_INVAL;
+			/* Unexpected char in strict mode */
+			default:
+				return JSMN_ERROR_INVAL;
 #endif
 
-        }
-    }
+		}
+	}
 
-    for(i = parser->toknext - 1; i >= 0; i--) {
-        /* Unmatched opened object or array */
-        if(tokens[i].start != -1 && tokens[i].end == -1) {
-            return JSMN_ERROR_PART;
-        }
-    }
+	for (i = parser->toknext - 1; i >= 0; i--) {
+		/* Unmatched opened object or array */
+		if (tokens[i].start != -1 && tokens[i].end == -1) {
+			return JSMN_ERROR_PART;
+		}
+	}
 
-    return JSMN_SUCCESS;
+	return JSMN_SUCCESS;
 }
 
 /**
- * Creates a new parser based over a given  buffer with an array of tokens
+ * Creates a new parser based over a given  buffer with an array of tokens 
  * available.
  */
-void jsmn_init(jsmn_parser *parser)
-{
-    parser->pos = 0;
-    parser->toknext = 0;
-    parser->toksuper = -1;
+void jsmn_init(jsmn_parser *parser) {
+	parser->pos = 0;
+	parser->toknext = 0;
+	parser->toksuper = -1;
 }
 
diff --git a/lib/jsmn/jsmn_test.c b/lib/jsmn/jsmn_test.c
index 3517bf4..308faf6 100644
--- a/lib/jsmn/jsmn_test.c
+++ b/lib/jsmn/jsmn_test.c
@@ -8,7 +8,7 @@ static int test_passed = 0;
 static int test_failed = 0;
 
 /* Terminate current test with error */
-#define fail()  return __LINE__
+#define fail()	return __LINE__
 
 /* Successfull end of the test case */
 #define done() return 0
@@ -17,359 +17,348 @@ static int test_failed = 0;
 #define check(cond) do { if (!(cond)) fail(); } while (0)
 
 /* Test runner */
-static void test(int (*func)(void), const char *name)
-{
-    int r = func();
-    if(r == 0) {
-        test_passed++;
-    } else {
-        test_failed++;
-        printf("FAILED: %s (at line %d)\n", name, r);
-    }
+static void test(int (*func)(void), const char *name) {
+	int r = func();
+	if (r == 0) {
+		test_passed++;
+	} else {
+		test_failed++;
+		printf("FAILED: %s (at line %d)\n", name, r);
+	}
 }
 
 #define TOKEN_EQ(t, tok_start, tok_end, tok_type) \
-    ((t).start == tok_start \
-     && (t).end == tok_end  \
-     && (t).type == (tok_type))
+	((t).start == tok_start \
+	 && (t).end == tok_end  \
+	 && (t).type == (tok_type))
 
 #define TOKEN_STRING(js, t, s) \
-    (strncmp(js+(t).start, s, (t).end - (t).start) == 0 \
-     && strlen(s) == (t).end - (t).start)
+	(strncmp(js+(t).start, s, (t).end - (t).start) == 0 \
+	 && strlen(s) == (t).end - (t).start)
 
 #define TOKEN_PRINT(t) \
-    printf("start: %d, end: %d, type: %d, size: %d\n", \
-            (t).start, (t).end, (t).type, (t).size)
-
-int test_empty()
-{
-    const char *js;
-    int r;
-    jsmn_parser p;
-    jsmntok_t t[10];
-
-    js = "{}";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, t, 10);
-    check(r == JSMN_SUCCESS);
-    check(t[0].type == JSMN_OBJECT);
-    check(t[0].start == 0 && t[0].end == 2);
-
-    js = "[]";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, t, 10);
-    check(r == JSMN_SUCCESS);
-    check(t[0].type == JSMN_ARRAY);
-    check(t[0].start == 0 && t[0].end == 2);
-
-    js = "{\"a\":[]}";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, t, 10);
-    check(r == JSMN_SUCCESS);
-    check(t[0].type == JSMN_OBJECT && t[0].start == 0 && t[0].end == 8);
-    check(t[1].type == JSMN_STRING && t[1].start == 2 && t[1].end == 3);
-    check(t[2].type == JSMN_ARRAY && t[2].start == 5 && t[2].end == 7);
-
-    js = "[{}, }]";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, t, 10);
-    check(r == JSMN_SUCCESS);
-    check(t[0].type == JSMN_ARRAY && t[0].start == 0 && t[0].end == 7);
-    check(t[1].type == JSMN_OBJECT && t[1].start == 1 && t[1].end == 3);
-    check(t[2].type == JSMN_OBJECT && t[2].start == 4 && t[2].end == 6);
-    return 0;
+	printf("start: %d, end: %d, type: %d, size: %d\n", \
+			(t).start, (t).end, (t).type, (t).size)
+
+int test_empty() {
+	const char *js;
+	int r;
+	jsmn_parser p;
+	jsmntok_t t[10];
+
+	js = "{}";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, t, 10);
+	check(r == JSMN_SUCCESS);
+	check(t[0].type == JSMN_OBJECT);
+	check(t[0].start == 0 && t[0].end == 2);
+
+	js = "[]";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, t, 10);
+	check(r == JSMN_SUCCESS);
+	check(t[0].type == JSMN_ARRAY);
+	check(t[0].start == 0 && t[0].end == 2);
+
+	js = "{\"a\":[]}";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, t, 10);
+	check(r == JSMN_SUCCESS);
+	check(t[0].type == JSMN_OBJECT && t[0].start == 0 && t[0].end == 8);
+	check(t[1].type == JSMN_STRING && t[1].start == 2 && t[1].end == 3);
+	check(t[2].type == JSMN_ARRAY && t[2].start == 5 && t[2].end == 7);
+
+	js = "[{},{}]";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, t, 10);
+	check(r == JSMN_SUCCESS);
+	check(t[0].type == JSMN_ARRAY && t[0].start == 0 && t[0].end == 7);
+	check(t[1].type == JSMN_OBJECT && t[1].start == 1 && t[1].end == 3);
+	check(t[2].type == JSMN_OBJECT && t[2].start == 4 && t[2].end == 6);
+	return 0;
 }
 
-int test_simple()
-{
-    const char *js;
-    int r;
-    jsmn_parser p;
-    jsmntok_t tokens[10];
-
-    js = "{\"a\": 0}";
-
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tokens, 10);
-    check(r == JSMN_SUCCESS);
-    check(TOKEN_EQ(tokens[0], 0, 8, JSMN_OBJECT));
-    check(TOKEN_EQ(tokens[1], 2, 3, JSMN_STRING));
-    check(TOKEN_EQ(tokens[2], 6, 7, JSMN_PRIMITIVE));
-
-    check(TOKEN_STRING(js, tokens[0], js));
-    check(TOKEN_STRING(js, tokens[1], "a"));
-    check(TOKEN_STRING(js, tokens[2], "0"));
-
-    jsmn_init(&p);
-    js = "[\"a\":{},\"b\":{}]";
-    r = jsmn_parse(&p, js, tokens, 10);
-    check(r == JSMN_SUCCESS);
-
-    jsmn_init(&p);
-    js = "{\n \"Day\": 26,\n \"Month\": 9,\n \"Year\": 12\n }";
-    r = jsmn_parse(&p, js, tokens, 10);
-    check(r == JSMN_SUCCESS);
-
-    return 0;
+int test_simple() {
+	const char *js;
+	int r;
+	jsmn_parser p;
+	jsmntok_t tokens[10];
+
+	js = "{\"a\": 0}";
+
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tokens, 10);
+	check(r == JSMN_SUCCESS);
+	check(TOKEN_EQ(tokens[0], 0, 8, JSMN_OBJECT));
+	check(TOKEN_EQ(tokens[1], 2, 3, JSMN_STRING));
+	check(TOKEN_EQ(tokens[2], 6, 7, JSMN_PRIMITIVE));
+
+	check(TOKEN_STRING(js, tokens[0], js));
+	check(TOKEN_STRING(js, tokens[1], "a"));
+	check(TOKEN_STRING(js, tokens[2], "0"));
+
+	jsmn_init(&p);
+	js = "[\"a\":{},\"b\":{}]";
+	r = jsmn_parse(&p, js, tokens, 10);
+	check(r == JSMN_SUCCESS);
+
+	jsmn_init(&p);
+	js = "{\n \"Day\": 26,\n \"Month\": 9,\n \"Year\": 12\n }";
+	r = jsmn_parse(&p, js, tokens, 10);
+	check(r == JSMN_SUCCESS);
+
+	return 0;
 }
 
-int test_primitive()
-{
-    int r;
-    jsmn_parser p;
-    jsmntok_t tok[10];
-    const char *js;
+int test_primitive() {
+	int r;
+	jsmn_parser p;
+	jsmntok_t tok[10];
+	const char *js;
 #ifndef JSMN_STRICT
-    js = "\"boolVar\" : true";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
-          && tok[1].type == JSMN_PRIMITIVE);
-    check(TOKEN_STRING(js, tok[0], "boolVar"));
-    check(TOKEN_STRING(js, tok[1], "true"));
-
-    js = "\"boolVar\" : false";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
-          && tok[1].type == JSMN_PRIMITIVE);
-    check(TOKEN_STRING(js, tok[0], "boolVar"));
-    check(TOKEN_STRING(js, tok[1], "false"));
-
-    js = "\"intVar\" : 12345";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
-          && tok[1].type == JSMN_PRIMITIVE);
-    check(TOKEN_STRING(js, tok[0], "intVar"));
-    check(TOKEN_STRING(js, tok[1], "12345"));
-
-    js = "\"floatVar\" : 12.345";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
-          && tok[1].type == JSMN_PRIMITIVE);
-    check(TOKEN_STRING(js, tok[0], "floatVar"));
-    check(TOKEN_STRING(js, tok[1], "12.345"));
-
-    js = "\"nullVar\" : null";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
-          && tok[1].type == JSMN_PRIMITIVE);
-    check(TOKEN_STRING(js, tok[0], "nullVar"));
-    check(TOKEN_STRING(js, tok[1], "null"));
+	js = "\"boolVar\" : true";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING 
+			&& tok[1].type == JSMN_PRIMITIVE);
+	check(TOKEN_STRING(js, tok[0], "boolVar"));
+	check(TOKEN_STRING(js, tok[1], "true"));
+
+	js = "\"boolVar\" : false";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING 
+			&& tok[1].type == JSMN_PRIMITIVE);
+	check(TOKEN_STRING(js, tok[0], "boolVar"));
+	check(TOKEN_STRING(js, tok[1], "false"));
+
+	js = "\"intVar\" : 12345";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING 
+			&& tok[1].type == JSMN_PRIMITIVE);
+	check(TOKEN_STRING(js, tok[0], "intVar"));
+	check(TOKEN_STRING(js, tok[1], "12345"));
+
+	js = "\"floatVar\" : 12.345";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING 
+			&& tok[1].type == JSMN_PRIMITIVE);
+	check(TOKEN_STRING(js, tok[0], "floatVar"));
+	check(TOKEN_STRING(js, tok[1], "12.345"));
+
+	js = "\"nullVar\" : null";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING 
+			&& tok[1].type == JSMN_PRIMITIVE);
+	check(TOKEN_STRING(js, tok[0], "nullVar"));
+	check(TOKEN_STRING(js, tok[1], "null"));
 #endif
-    return 0;
+	return 0;
 }
 
-int test_string()
-{
-    int r;
-    jsmn_parser p;
-    jsmntok_t tok[10];
-    const char *js;
-
-    js = "\"strVar\" : \"hello world\"";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
-          && tok[1].type == JSMN_STRING);
-    check(TOKEN_STRING(js, tok[0], "strVar"));
-    check(TOKEN_STRING(js, tok[1], "hello world"));
-
-    js = "\"strVar\" : \"escapes: \\/\\r\\n\\t\\b\\f\\\"\\\\\"";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
-          && tok[1].type == JSMN_STRING);
-    check(TOKEN_STRING(js, tok[0], "strVar"));
-    check(TOKEN_STRING(js, tok[1], "escapes: \\/\\r\\n\\t\\b\\f\\\"\\\\"));
-
-    js = "\"strVar\" : \"\"";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
-          && tok[1].type == JSMN_STRING);
-    check(TOKEN_STRING(js, tok[0], "strVar"));
-    check(TOKEN_STRING(js, tok[1], ""));
-
-    return 0;
+int test_string() {
+	int r;
+	jsmn_parser p;
+	jsmntok_t tok[10];
+	const char *js;
+
+	js = "\"strVar\" : \"hello world\"";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING 
+			&& tok[1].type == JSMN_STRING);
+	check(TOKEN_STRING(js, tok[0], "strVar"));
+	check(TOKEN_STRING(js, tok[1], "hello world"));
+
+	js = "\"strVar\" : \"escapes: \\/\\r\\n\\t\\b\\f\\\"\\\\\"";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING 
+			&& tok[1].type == JSMN_STRING);
+	check(TOKEN_STRING(js, tok[0], "strVar"));
+	check(TOKEN_STRING(js, tok[1], "escapes: \\/\\r\\n\\t\\b\\f\\\"\\\\"));
+
+	js = "\"strVar\" : \"\"";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING 
+			&& tok[1].type == JSMN_STRING);
+	check(TOKEN_STRING(js, tok[0], "strVar"));
+	check(TOKEN_STRING(js, tok[1], ""));
+
+	return 0;
 }
 
-int test_partial_string()
-{
-    int r;
-    jsmn_parser p;
-    jsmntok_t tok[10];
-    const char *js;
-
-    jsmn_init(&p);
-    js = "\"x\": \"va";
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_ERROR_PART && tok[0].type == JSMN_STRING);
-    check(TOKEN_STRING(js, tok[0], "x"));
-    check(p.toknext == 1);
-
-    js = "\"x\": \"valu";
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_ERROR_PART && tok[0].type == JSMN_STRING);
-    check(TOKEN_STRING(js, tok[0], "x"));
-    check(p.toknext == 1);
-
-    js = "\"x\": \"value\"";
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
-          && tok[1].type == JSMN_STRING);
-    check(TOKEN_STRING(js, tok[0], "x"));
-    check(TOKEN_STRING(js, tok[1], "value"));
-
-    js = "\"x\": \"value\", \"y\": \"value y\"";
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
-          && tok[1].type == JSMN_STRING && tok[2].type == JSMN_STRING
-          && tok[3].type == JSMN_STRING);
-    check(TOKEN_STRING(js, tok[0], "x"));
-    check(TOKEN_STRING(js, tok[1], "value"));
-    check(TOKEN_STRING(js, tok[2], "y"));
-    check(TOKEN_STRING(js, tok[3], "value y"));
-
-    return 0;
+int test_partial_string() {
+	int r;
+	jsmn_parser p;
+	jsmntok_t tok[10];
+	const char *js;
+
+	jsmn_init(&p);
+	js = "\"x\": \"va";
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_ERROR_PART && tok[0].type == JSMN_STRING);
+	check(TOKEN_STRING(js, tok[0], "x"));
+	check(p.toknext == 1);
+
+	js = "\"x\": \"valu";
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_ERROR_PART && tok[0].type == JSMN_STRING);
+	check(TOKEN_STRING(js, tok[0], "x"));
+	check(p.toknext == 1);
+
+	js = "\"x\": \"value\"";
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
+			&& tok[1].type == JSMN_STRING);
+	check(TOKEN_STRING(js, tok[0], "x"));
+	check(TOKEN_STRING(js, tok[1], "value"));
+
+	js = "\"x\": \"value\", \"y\": \"value y\"";
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_STRING
+			&& tok[1].type == JSMN_STRING && tok[2].type == JSMN_STRING
+			&& tok[3].type == JSMN_STRING);
+	check(TOKEN_STRING(js, tok[0], "x"));
+	check(TOKEN_STRING(js, tok[1], "value"));
+	check(TOKEN_STRING(js, tok[2], "y"));
+	check(TOKEN_STRING(js, tok[3], "value y"));
+
+	return 0;
 }
 
-int test_unquoted_keys()
-{
+int test_unquoted_keys() {
 #ifndef JSMN_STRICT
-    int r;
-    jsmn_parser p;
-    jsmntok_t tok[10];
-    const char *js;
-
-    jsmn_init(&p);
-    js = "key1: \"value\"\nkey2 : 123";
-
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_PRIMITIVE
-          && tok[1].type == JSMN_STRING && tok[2].type == JSMN_PRIMITIVE
-          && tok[3].type == JSMN_PRIMITIVE);
-    check(TOKEN_STRING(js, tok[0], "key1"));
-    check(TOKEN_STRING(js, tok[1], "value"));
-    check(TOKEN_STRING(js, tok[2], "key2"));
-    check(TOKEN_STRING(js, tok[3], "123"));
+	int r;
+	jsmn_parser p;
+	jsmntok_t tok[10];
+	const char *js;
+
+	jsmn_init(&p);
+	js = "key1: \"value\"\nkey2 : 123";
+
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_PRIMITIVE
+			&& tok[1].type == JSMN_STRING && tok[2].type == JSMN_PRIMITIVE
+			&& tok[3].type == JSMN_PRIMITIVE);
+	check(TOKEN_STRING(js, tok[0], "key1"));
+	check(TOKEN_STRING(js, tok[1], "value"));
+	check(TOKEN_STRING(js, tok[2], "key2"));
+	check(TOKEN_STRING(js, tok[3], "123"));
 #endif
-    return 0;
+	return 0;
 }
 
-int test_partial_array()
-{
-    int r;
-    jsmn_parser p;
-    jsmntok_t tok[10];
-    const char *js;
-
-    jsmn_init(&p);
-    js = "  [ 1, true, ";
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_ERROR_PART && tok[0].type == JSMN_ARRAY
-          && tok[1].type == JSMN_PRIMITIVE && tok[2].type == JSMN_PRIMITIVE);
-
-    js = "  [ 1, true, [123, \"hello";
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_ERROR_PART && tok[0].type == JSMN_ARRAY
-          && tok[1].type == JSMN_PRIMITIVE && tok[2].type == JSMN_PRIMITIVE
-          && tok[3].type == JSMN_ARRAY && tok[4].type == JSMN_PRIMITIVE);
-
-    js = "  [ 1, true, [123, \"hello\"]";
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_ERROR_PART && tok[0].type == JSMN_ARRAY
-          && tok[1].type == JSMN_PRIMITIVE && tok[2].type == JSMN_PRIMITIVE
-          && tok[3].type == JSMN_ARRAY && tok[4].type == JSMN_PRIMITIVE
-          && tok[5].type == JSMN_STRING);
-    /* check child nodes of the 2nd array */
-    check(tok[3].size == 2);
-
-    js = "  [ 1, true, [123, \"hello\"]]";
-    r = jsmn_parse(&p, js, tok, 10);
-    check(r == JSMN_SUCCESS && tok[0].type == JSMN_ARRAY
-          && tok[1].type == JSMN_PRIMITIVE && tok[2].type == JSMN_PRIMITIVE
-          && tok[3].type == JSMN_ARRAY && tok[4].type == JSMN_PRIMITIVE
-          && tok[5].type == JSMN_STRING);
-    check(tok[3].size == 2);
-    check(tok[0].size == 3);
-    return 0;
+int test_partial_array() {
+	int r;
+	jsmn_parser p;
+	jsmntok_t tok[10];
+	const char *js;
+
+	jsmn_init(&p);
+	js = "  [ 1, true, ";
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_ERROR_PART && tok[0].type == JSMN_ARRAY 
+			&& tok[1].type == JSMN_PRIMITIVE && tok[2].type == JSMN_PRIMITIVE);
+
+	js = "  [ 1, true, [123, \"hello";
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_ERROR_PART && tok[0].type == JSMN_ARRAY 
+			&& tok[1].type == JSMN_PRIMITIVE && tok[2].type == JSMN_PRIMITIVE
+			&& tok[3].type == JSMN_ARRAY && tok[4].type == JSMN_PRIMITIVE);
+
+	js = "  [ 1, true, [123, \"hello\"]";
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_ERROR_PART && tok[0].type == JSMN_ARRAY 
+			&& tok[1].type == JSMN_PRIMITIVE && tok[2].type == JSMN_PRIMITIVE
+			&& tok[3].type == JSMN_ARRAY && tok[4].type == JSMN_PRIMITIVE
+			&& tok[5].type == JSMN_STRING);
+	/* check child nodes of the 2nd array */
+	check(tok[3].size == 2);
+
+	js = "  [ 1, true, [123, \"hello\"]]";
+	r = jsmn_parse(&p, js, tok, 10);
+	check(r == JSMN_SUCCESS && tok[0].type == JSMN_ARRAY 
+			&& tok[1].type == JSMN_PRIMITIVE && tok[2].type == JSMN_PRIMITIVE
+			&& tok[3].type == JSMN_ARRAY && tok[4].type == JSMN_PRIMITIVE
+			&& tok[5].type == JSMN_STRING);
+	check(tok[3].size == 2);
+	check(tok[0].size == 3);
+	return 0;
 }
 
-int test_array_nomem()
-{
-    int i;
-    int r;
-    jsmn_parser p;
-    jsmntok_t toksmall[10], toklarge[10];
-    const char *js;
+int test_array_nomem() {
+	int i;
+	int r;
+	jsmn_parser p;
+	jsmntok_t toksmall[10], toklarge[10];
+	const char *js;
 
-    js = "  [ 1, true, [123, \"hello\"]]";
+	js = "  [ 1, true, [123, \"hello\"]]";
 
-    for(i = 0; i < 6; i++) {
-        jsmn_init(&p);
-        memset(toksmall, 0, sizeof(toksmall));
-        memset(toklarge, 0, sizeof(toklarge));
-        r = jsmn_parse(&p, js, toksmall, i);
-        check(r == JSMN_ERROR_NOMEM);
+	for (i = 0; i < 6; i++) {
+		jsmn_init(&p);
+		memset(toksmall, 0, sizeof(toksmall));
+		memset(toklarge, 0, sizeof(toklarge));
+		r = jsmn_parse(&p, js, toksmall, i);
+		check(r == JSMN_ERROR_NOMEM);
 
-        memcpy(toklarge, toksmall, sizeof(toksmall));
+		memcpy(toklarge, toksmall, sizeof(toksmall));
 
-        r = jsmn_parse(&p, js, toklarge, 10);
-        check(r == JSMN_SUCCESS);
+		r = jsmn_parse(&p, js, toklarge, 10);
+		check(r == JSMN_SUCCESS);
 
-        check(toklarge[0].type == JSMN_ARRAY && toklarge[0].size == 3);
-        check(toklarge[3].type == JSMN_ARRAY && toklarge[3].size == 2);
-    }
-    return 0;
+		check(toklarge[0].type == JSMN_ARRAY && toklarge[0].size == 3);
+		check(toklarge[3].type == JSMN_ARRAY && toklarge[3].size == 2);
+	}
+	return 0;
 }
 
-int test_objects_arrays()
-{
-    int i;
-    int r;
-    jsmn_parser p;
-    jsmntok_t tokens[10];
-    const char *js;
-
-    js = "[10}";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tokens, 10);
-    check(r == JSMN_ERROR_INVAL);
-
-    js = "[10]";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tokens, 10);
-    check(r == JSMN_SUCCESS);
-
-    js = "{\"a\": 1]";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tokens, 10);
-    check(r == JSMN_ERROR_INVAL);
-
-    js = "{\"a\": 1}";
-    jsmn_init(&p);
-    r = jsmn_parse(&p, js, tokens, 10);
-    check(r == JSMN_SUCCESS);
-
-    return 0;
+int test_objects_arrays() {
+	int i;
+	int r;
+	jsmn_parser p;
+	jsmntok_t tokens[10];
+	const char *js;
+
+	js = "[10}";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tokens, 10);
+	check(r == JSMN_ERROR_INVAL);
+
+	js = "[10]";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tokens, 10);
+	check(r == JSMN_SUCCESS);
+
+	js = "{\"a\": 1]";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tokens, 10);
+	check(r == JSMN_ERROR_INVAL);
+
+	js = "{\"a\": 1}";
+	jsmn_init(&p);
+	r = jsmn_parse(&p, js, tokens, 10);
+	check(r == JSMN_SUCCESS);
+
+	return 0;
 }
 
-int main()
-{
-    test(test_empty, "general test for a empty JSON objects/arrays");
-    test(test_simple, "general test for a simple JSON string");
-    test(test_primitive, "test primitive JSON data types");
-    test(test_string, "test string JSON data types");
-    test(test_partial_string, "test partial JSON string parsing");
-    test(test_partial_array, "test partial array reading");
-    test(test_array_nomem, "test array reading with a smaller number of tokens");
-    test(test_unquoted_keys, "test unquoted keys (like in JavaScript)");
-    test(test_objects_arrays, "test objects and arrays");
-    printf("\nPASSED: %d\nFAILED: %d\n", test_passed, test_failed);
-    return 0;
+int main() {
+	test(test_empty, "general test for a empty JSON objects/arrays");
+	test(test_simple, "general test for a simple JSON string");
+	test(test_primitive, "test primitive JSON data types");
+	test(test_string, "test string JSON data types");
+	test(test_partial_string, "test partial JSON string parsing");
+	test(test_partial_array, "test partial array reading");
+	test(test_array_nomem, "test array reading with a smaller number of tokens");
+	test(test_unquoted_keys, "test unquoted keys (like in JavaScript)");
+	test(test_objects_arrays, "test objects and arrays");
+	printf("\nPASSED: %d\nFAILED: %d\n", test_passed, test_failed);
+	return 0;
 }
 
diff --git a/lib/misc.c b/lib/misc.c
index 2198263..edd2f99 100644
--- a/lib/misc.c
+++ b/lib/misc.c
@@ -21,14 +21,14 @@
 #include "stringlib.h"
 #include "misc.h"
 
-__attribute__((visibility("default")))
-size_t glyr_levenshtein_strcmp(const char *string, const char *other)
+__attribute__ ( (visibility ("default") ) )
+size_t glyr_levenshtein_strcmp (const char * string, const char * other)
 {
-    return levenshtein_safe_strcmp(string, other);
+    return levenshtein_safe_strcmp (string,other);
 }
 
-__attribute__((visibility("default")))
-size_t glyr_levenshtein_strnormcmp(const char *string, const char *other)
+__attribute__ ( (visibility ("default") ) )
+size_t glyr_levenshtein_strnormcmp (const char * string, const char * other)
 {
-    return levenshtein_strnormcmp(NULL, string, other);
+    return levenshtein_strnormcmp (NULL,string,other);
 }
diff --git a/lib/register_plugins.c b/lib/register_plugins.c
index 989e125..f317739 100644
--- a/lib/register_plugins.c
+++ b/lib/register_plugins.c
@@ -23,15 +23,15 @@
 #include "register_plugins.h"
 
 /* Warning: All functions in here are _not_ threadsafe. */
-static void get_list_from_type(MetaDataFetcher *fetch);
-static void register_provider_plugins(void);
-static void init_provider_list(void);
+static void get_list_from_type (MetaDataFetcher * fetch);
+static void register_provider_plugins (void);
+static void init_provider_list (void);
 
 /* global provider plugin list */
-GList *glyrMetaDataSourceList = NULL;
+GList * glyrMetaDataSourceList = NULL;
 
 /* List of MetaDataFetchers */
-GList *glyrMetaDataPluginList = NULL;
+GList * glyrMetaDataPluginList = NULL;
 
 
 /* Externalized fetcher vars, add yours here  {{{ */
@@ -115,7 +115,7 @@ extern MetaDataSource musictree_provider_src;
 /////////////////////////////////
 
 /* Get fetcher list */
-GList *r_getFList(void)
+GList * r_getFList (void)
 {
     return glyrMetaDataPluginList;
 }
@@ -123,96 +123,97 @@ GList *r_getFList(void)
 /////////////////////////////////
 
 /* Get Source list */
-GList *r_getSList(void)
+GList * r_getSList (void)
 {
     return glyrMetaDataSourceList;
 }
 
 /////////////////////////////////
 
-void plugin_add_to_list(GList **list, void *data)
+void plugin_add_to_list (GList ** list, void * data)
 {
-    if(list != NULL) {
-        *list = g_list_prepend(*list, data);
+    if (list != NULL)
+    {
+        *list = g_list_prepend (*list,data);
     }
 }
 
 /////////////////////////////////
 
-static void register_provider_plugins(void)
+static void register_provider_plugins (void)
 {
-    plugin_add_to_list(&glyrMetaDataSourceList, &ainfo_lastfm_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &ainfo_lyricsreg_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &ainfo_bbcmusic_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &ainfo_echonest_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &albumlist_musicbrainz_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&ainfo_lastfm_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&ainfo_lyricsreg_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&ainfo_bbcmusic_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&ainfo_echonest_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&albumlist_musicbrainz_src);
 
     // FIXME: Seems to be broken too. (serverside)
-    //plugin_add_to_list(&glyrMetaDataSourceList, cover_albumart_src);
+    //plugin_add_to_list(&glyrMetaDataSourceList,&cover_albumart_src);
 
     // FIXME: Silly amazon requires to be a Seller to use their API
-    // plugin_add_to_list(&glyrMetaDataSourceList, cover_amazon_src);
+    // plugin_add_to_list(&glyrMetaDataSourceList,&cover_amazon_src);
 
     // FIXME: Coverhunt seems to be down. Add again when up and running
-    //plugin_add_to_list(&glyrMetaDataSourceList, cover_coverhunt_src);
+    //plugin_add_to_list(&glyrMetaDataSourceList,&cover_coverhunt_src);
 
 
     // FIXME: No real data yet there.. adele:19 gives a correct mbid, but no results
-    plugin_add_to_list(&glyrMetaDataSourceList, &cover_coverartarchive_src);
-
-    plugin_add_to_list(&glyrMetaDataSourceList, &cover_discogs_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &cover_google_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &cover_lastfm_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &cover_jamendo_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &cover_lyricswiki_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &cover_rhapsody_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &cover_picsearch_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &cover_musicbrainz_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &cover_slothradio_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_lipwalk_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_lyrdb_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_lyricsreg_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_lyricstime_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_lyricsvip_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_lyricswiki_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_lyrix_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_magistrix_src);
-    //plugin_add_to_list (&glyrMetaDataSourceList, lyrics_metrolyrics_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_metallum_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_elyrics_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_vagalume_src);
+    plugin_add_to_list(&glyrMetaDataSourceList,&cover_coverartarchive_src);
+
+    plugin_add_to_list (&glyrMetaDataSourceList,&cover_discogs_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&cover_google_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&cover_lastfm_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&cover_jamendo_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&cover_lyricswiki_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&cover_rhapsody_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&cover_picsearch_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&cover_musicbrainz_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&cover_slothradio_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_lipwalk_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_lyrdb_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_lyricsreg_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_lyricstime_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_lyricsvip_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_lyricswiki_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_lyrix_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_magistrix_src);
+    //plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_metrolyrics_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_metallum_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_elyrics_src);
+	plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_vagalume_src);
 
     // FIXME: Chartlyrics reacts very slowly, and often not at all
     // add again when running again ( :( - good api though)
     // 28.1.2012: Seems to be on again, API fails too often though still.
-    plugin_add_to_list(&glyrMetaDataSourceList, &lyrics_chartlyrics_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &photos_flickr_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &photos_google_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &photos_lastfm_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &photos_discogs_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &photos_singerpictures_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &photos_rhapsody_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &photos_picsearch_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &photos_bbcmusic_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &relations_musicbrainz_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&lyrics_chartlyrics_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&photos_flickr_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&photos_google_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&photos_lastfm_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&photos_discogs_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&photos_singerpictures_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&photos_rhapsody_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&photos_picsearch_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&photos_bbcmusic_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&relations_musicbrainz_src);
 
     // FIXME: Silly amazon requires to be a Seller to use their API
-    //plugin_add_to_list(&glyrMetaDataSourceList, review_amazon_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &review_metallum_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &review_echonest_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &similar_artist_lastfm_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &similar_song_lastfm_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &tags_musicbrainz_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &tracklist_musicbrainz_src);
+    //plugin_add_to_list(&glyrMetaDataSourceList,&review_amazon_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&review_metallum_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&review_echonest_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&similar_artist_lastfm_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&similar_song_lastfm_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&tags_musicbrainz_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&tracklist_musicbrainz_src);
     // FIXME: Searchfunction of guitaretabs seems to be broken
-    //plugin_add_to_list(&glyrMetaDataSourceList, guitartabs_guitaretab_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &guitartabs_chordie_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &backdrops_htbackdrops_src);
+    //plugin_add_to_list(&glyrMetaDataSourceList,&guitartabs_guitaretab_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&guitartabs_chordie_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&backdrops_htbackdrops_src);
 
     /* Special offline providers */
-    plugin_add_to_list(&glyrMetaDataSourceList, &relations_generated_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &local_provider_src);
-    plugin_add_to_list(&glyrMetaDataSourceList, &musictree_provider_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&relations_generated_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&local_provider_src);
+    plugin_add_to_list (&glyrMetaDataSourceList,&musictree_provider_src);
 }
 
 /////////////////////////////////
@@ -221,10 +222,10 @@ static void register_provider_plugins(void)
  * This has no actual practical use, it's just that pretty plugins are listed
  * first in outputs. Actual sorting is not threadsafe!
  */
-static gint compare_by_priority(gconstpointer a, gconstpointer b)
+static gint compare_by_priority (gconstpointer a, gconstpointer b)
 {
-    const MetaDataSource *sa = a;
-    const MetaDataSource *sb = b;
+    const MetaDataSource * sa = a;
+    const MetaDataSource * sb = b;
     return (sa != NULL && sb != NULL) ?
            (sa->quality * sa->speed -
             sb->quality * sb->speed
@@ -233,58 +234,62 @@ static gint compare_by_priority(gconstpointer a, gconstpointer b)
 
 /////////////////////////////////
 
-static void get_list_from_type(MetaDataFetcher *fetch)
+static void get_list_from_type (MetaDataFetcher * fetch)
 {
-    GList *src;
-    for(src = glyrMetaDataSourceList; src; src = src->next) {
-        MetaDataSource *item = src->data;
-        if(item && (fetch->type == item->type || item->type == GLYR_GET_ANY)) {
-            fetch->provider = g_list_prepend(fetch->provider, item);
-            if(item->data_type == GLYR_TYPE_UNKNOWN) {
+    GList * src;
+    for (src = glyrMetaDataSourceList; src; src = src->next)
+    {
+        MetaDataSource * item = src->data;
+        if (item && (fetch->type == item->type || item->type == GLYR_GET_ANY) )
+        {
+            fetch->provider = g_list_prepend (fetch->provider,item);
+            if (item->data_type == GLYR_TYPE_UNKNOWN)
+            {
                 item->data_type = fetch->default_data_type;
             }
         }
 
     }
-    fetch->provider = g_list_sort(fetch->provider, compare_by_priority);
+    fetch->provider = g_list_sort (fetch->provider,compare_by_priority);
 
 }
 
 /////////////////////////////////
 
-static void init_provider_list(void)
+static void init_provider_list (void)
 {
-    for(GList *fetch = glyrMetaDataPluginList; fetch; fetch = fetch->next) {
-        get_list_from_type((MetaDataFetcher *)(fetch->data));
-    }
+    for (GList * fetch = glyrMetaDataPluginList; fetch; fetch = fetch->next)
+        get_list_from_type ( (MetaDataFetcher *) (fetch->data) );
 }
 
 /////////////////////////////////
 
 /* Register fetchers */
-void register_fetcher_plugins(void)
+void register_fetcher_plugins (void)
 {
     /* add yours here */
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_cover);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_lyrics);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_artistphotos);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_artistbio);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_similar_artists);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_similar_song);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_review);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_albumlist);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_tags);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_relations);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_tracklist);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_guitartabs);
-    plugin_add_to_list(&glyrMetaDataPluginList, &glyrFetcher_backdrops);
-
-    glyrMetaDataPluginList = g_list_reverse(glyrMetaDataPluginList);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_cover);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_lyrics);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_artistphotos);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_artistbio);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_similar_artists);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_similar_song);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_review);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_albumlist);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_tags);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_relations);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_tracklist);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_guitartabs);
+    plugin_add_to_list (&glyrMetaDataPluginList,&glyrFetcher_backdrops);
+
+    glyrMetaDataPluginList = g_list_reverse (glyrMetaDataPluginList);
 
     /* call init() */
-    for(GList *elem = glyrMetaDataPluginList; elem; elem = elem->next) {
-        MetaDataFetcher *fetch = elem->data;
-        if(fetch->init != NULL) {
+    for (GList * elem = glyrMetaDataPluginList; elem; elem = elem->next)
+    {
+        MetaDataFetcher * fetch = elem->data;
+        if (fetch->init != NULL)
+        {
             fetch->init();
         }
     }
@@ -298,73 +303,86 @@ void register_fetcher_plugins(void)
 /////////////////////////////////
 
 /* Unregister 'em again */
-void unregister_fetcher_plugins(void)
+void unregister_fetcher_plugins (void)
 {
     /* Destroy all fetchers */
-    if(glyrMetaDataPluginList) {
-        GList *elem;
-        for(elem = glyrMetaDataPluginList; elem != NULL; elem = elem->next) {
-            MetaDataFetcher *item = elem->data;
-            if(item->destroy != NULL) {
+    if (glyrMetaDataPluginList)
+    {
+        GList * elem;
+        for (elem = glyrMetaDataPluginList; elem != NULL; elem = elem->next)
+        {
+            MetaDataFetcher * item = elem->data;
+            if (item->destroy != NULL)
+            {
                 item->destroy();
             }
-            g_list_free(item->provider);
+            g_list_free (item->provider);
             item->provider = NULL;
         }
-        g_list_free(glyrMetaDataPluginList);
+        g_list_free (glyrMetaDataPluginList);
         glyrMetaDataPluginList = NULL;
     }
 
     /* Also kill others */
-    if(!glyrMetaDataSourceList) {
-        g_list_free(glyrMetaDataSourceList);
+    if (!glyrMetaDataSourceList)
+    {
+        g_list_free (glyrMetaDataSourceList);
         glyrMetaDataSourceList = NULL;
     }
 }
 
 /////////////////////////////////
 
-GlyrFetcherInfo *get_plugin_info(void)
+GlyrFetcherInfo * get_plugin_info (void)
 {
-    GlyrFetcherInfo *head = NULL;
-    GlyrFetcherInfo *prev_fetcher = NULL;
-    for(GList *elem0 = r_getFList(); elem0; elem0 = elem0->next) {
-        MetaDataFetcher *fetch = elem0->data;
-        GlyrFetcherInfo   *finfo = g_malloc0(sizeof(GlyrFetcherInfo));
-
-        GlyrSourceInfo *prev_source = NULL;
-        for(GList *elem1 = r_getSList(); elem1; elem1 = elem1->next) {
-            MetaDataSource *source = elem1->data;
-            if(source && source->type == fetch->type) {
-                GlyrSourceInfo   *sinfos = g_malloc0(sizeof(GlyrSourceInfo));
+    GlyrFetcherInfo * head = NULL;
+    GlyrFetcherInfo * prev_fetcher = NULL;
+    for (GList * elem0 = r_getFList(); elem0; elem0 = elem0->next)
+    {
+        MetaDataFetcher * fetch = elem0->data;
+        GlyrFetcherInfo  * finfo = g_malloc0 (sizeof (GlyrFetcherInfo) );
+
+        GlyrSourceInfo * prev_source = NULL;
+        for (GList * elem1 = r_getSList(); elem1; elem1 = elem1->next)
+        {
+            MetaDataSource * source = elem1->data;
+            if (source && source->type == fetch->type)
+            {
+                GlyrSourceInfo  * sinfos = g_malloc0 (sizeof (GlyrSourceInfo) );
 
                 sinfos->quality = source->quality;
                 sinfos->speed   = source->speed;
                 sinfos->key     = source->key;
                 sinfos->type    = source->type;
                 sinfos->lang_aware = source->lang_aware;
-                sinfos->name    = g_strdup(source->name);
+                sinfos->name    = g_strdup (source->name);
 
-                if(prev_source != NULL) {
+                if (prev_source != NULL)
+                {
                     prev_source->next = sinfos;
                     sinfos->prev = prev_source;
-                } else {
+                }
+                else
+                {
                     finfo->head = sinfos;
                 }
                 prev_source = sinfos;
             }
         }
 
-        if(prev_fetcher != NULL) {
+        if (prev_fetcher != NULL)
+        {
             prev_fetcher->next = finfo;
             finfo->prev = prev_fetcher;
-        } else {
+        }
+        else
+        {
             head = finfo;
         }
 
         prev_fetcher = finfo;
 
-        finfo->name = g_strdup(fetch->name);
+        finfo->name = g_strdup (fetch->name);
         finfo->type = fetch->type;
         finfo->reqs = fetch->reqs;
     }
@@ -373,33 +391,37 @@ GlyrFetcherInfo *get_plugin_info(void)
 
 /////////////////////////////////
 
-static void free_single_item(GlyrFetcherInfo *info)
+static void free_single_item (GlyrFetcherInfo * info)
 {
-    if(info != NULL) {
-        GlyrSourceInfo *elem = info->head;
-        while(elem != NULL) {
-            GlyrSourceInfo *to_delete = elem;
+    if (info != NULL)
+    {
+        GlyrSourceInfo * elem = info->head;
+        while (elem != NULL)
+        {
+            GlyrSourceInfo * to_delete = elem;
             elem = elem->next;
 
-            g_free(to_delete->name);
-            g_free(to_delete);
+            g_free (to_delete->name);
+            g_free (to_delete);
         }
-        g_free((gchar *) info->name);
+        g_free ( (gchar*) info->name);
         info->name = NULL;
     }
-    g_free(info);
+    g_free (info);
 }
 
 /////////////////////////////////
 
-void free_plugin_info(GlyrFetcherInfo *infos)
+void free_plugin_info (GlyrFetcherInfo * infos)
 {
-    if(infos != NULL) {
-        GlyrFetcherInfo *fetch = infos;
-        while(fetch != NULL) {
-            GlyrFetcherInfo *to_delete = fetch;
+    if (infos != NULL)
+    {
+        GlyrFetcherInfo * fetch = infos;
+        while (fetch != NULL)
+        {
+            GlyrFetcherInfo * to_delete = fetch;
             fetch = fetch->next;
-            free_single_item(to_delete);
+            free_single_item (to_delete);
         }
     }
 }
diff --git a/lib/stringlib.c b/lib/stringlib.c
index 64dc243..5a70418 100644
--- a/lib/stringlib.c
+++ b/lib/stringlib.c
@@ -40,78 +40,71 @@
  *
  * Also, this is UTF-8 aware.
  */
-gsize levenshtein_strcmp(const gchar *s, const gchar *t)
+gsize levenshtein_strcmp (const gchar * s, const gchar * t)
 {
-    int n = (s) ? g_utf8_strlen(s, -1) + 1 : 0;
-    int m = (t) ? g_utf8_strlen(t, -1) + 1 : 0;
+    int n = (s) ? g_utf8_strlen (s,-1) +1 : 0;
+    int m = (t) ? g_utf8_strlen (t,-1) +1 : 0;
 
     // NOTE: Be sure to call g_utf8_validate(), might fail otherwise
     //       It's advisable to call g_utf8_normalize() too.
 
     // Nothing to compute really..
-    if(n < 2) {
-        return m;
-    }
-    if(m < 2) {
-        return n;
-    }
+    if (n < 2) return m;
+    if (m < 2) return n;
 
     // String matrix
     int d[n][m];
-    int i, j;
+    int i,j;
 
     // Init first row|column to 0...n|m
-    for(i = 0; i < n; i++) {
-        d[i][0] = i;
-    }
-    for(j = 0; j < m; j++) {
-        d[0][j] = j;
-    }
+    for (i=0; i<n; i++) d[i][0] = i;
+    for (j=0; j<m; j++) d[0][j] = j;
 
-    for(i = 1; i < n; i++) {
+    for (i=1; i<n; i++)
+    {
         // Current char in string s
-        gunichar cats = g_utf8_get_char(g_utf8_offset_to_pointer(s, i - 1));
+        gunichar cats = g_utf8_get_char (g_utf8_offset_to_pointer (s,i-1) );
 
-        for(j = 1; j < m; j++) {
+        for (j=1; j<m; j++)
+        {
             // Do -1 only once
-            int jm1 = j - 1,
-                im1 = i - 1;
+            int jm1 = j-1,
+                im1 = i-1;
 
-            gunichar tats = g_utf8_get_char(g_utf8_offset_to_pointer(t, jm1));
+            gunichar tats = g_utf8_get_char (g_utf8_offset_to_pointer (t,jm1) );
 
             // a = above cell, b = left cell, c = left above celli
             int a = d[im1][j] + 1,
                 b = d[i][jm1] + 1,
                 c = d[im1][jm1] + (tats != cats);
 
-            // Now compute the minimum of a, ,  and set MIN(a, , ) to cell d[i][j]
-            d[i][j] = (a < b) ? MIN(a, c) : MIN(b, c);
+            // Now compute the minimum of a,b,c and set MIN(a,b,c) to cell d[i][j]
+            d[i][j] = (a < b) ? MIN (a,c) : MIN (b,c);
         }
     }
 
     // The result is stored in the very right down cell
-    return d[n - 1][m - 1];
+    return d[n-1][m-1];
 }
 
 ///////////////////////////////
 
 // A utf8 aware levenshtein that normalizes ambigious codepoints
 // and validates input-data
-gsize levenshtein_safe_strcmp(const gchar *s, const gchar *t)
+gsize levenshtein_safe_strcmp (const gchar * s, const gchar * t)
 {
     gsize rc = 0;
-    if(g_utf8_validate(s, -1, NULL) == FALSE ||
-            g_utf8_validate(t, -1, NULL) == FALSE) {
+    if (g_utf8_validate (s,-1,NULL) == FALSE ||
+            g_utf8_validate (t,-1,NULL) == FALSE)
         return rc;
-    }
 
-    gchar *s_norm = g_utf8_normalize(s, -1, G_NORMALIZE_ALL_COMPOSE);
-    gchar *t_norm = g_utf8_normalize(t, -1, G_NORMALIZE_ALL_COMPOSE);
+    gchar * s_norm = g_utf8_normalize (s,-1,G_NORMALIZE_ALL_COMPOSE);
+    gchar * t_norm = g_utf8_normalize (t,-1,G_NORMALIZE_ALL_COMPOSE);
 
-    rc = levenshtein_strcmp(s_norm, t_norm);
+    rc = levenshtein_strcmp (s_norm,t_norm);
 
-    g_free(s_norm);
-    g_free(t_norm);
+    g_free (s_norm);
+    g_free (t_norm);
 
     return rc;
 }
@@ -125,57 +118,65 @@ gsize levenshtein_safe_strcmp(const gchar *s, const gchar *t)
  *
  * @return a newly allocated string
  */
-const gchar *const regex_table[][2] = {
+const gchar * const regex_table[][2] =
+{
     {"CD[[:blank:]]*[0-9]+",   ""}, /* 'CD 1'  -> ''    */
-    {"track[[:blank:]]*[0-9]+", ""}, /* 'CD 1'  -> ''    */
-    {"(`|'|\"|\\.|, ",         ""}, /* Punctuation.     */
-    {"feat(\\.|uring).*", ""}, /* "feat." -> " "   */
-    {"feat\\..*", ""}, /* "feat." -> " "   */
-    {"[[:space:]]{2, ",       " "}  /* 'a  b'  -> 'a b' */
+    {"track[[:blank:]]*[0-9]+",""}, /* 'CD 1'  -> ''    */
+    {"(`|'|\"|\\.|,)",         ""}, /* Punctuation.     */
+    {"feat(\\.|uring).*",""}, /* "feat." -> " "   */
+    {"feat\\..*",""}, /* "feat." -> " "   */
+    {"[[:space:]]{2,}",       " "}  /* 'a  b'  -> 'a b' */
 };
 
-const gsize regex_table_size = sizeof(regex_table) / (2 * sizeof(gchar *));
+const gsize regex_table_size = sizeof (regex_table) / (2 * sizeof (gchar*) );
 
-gchar *regex_replace_by_table(const gchar *string, const gchar *const delete_string[][2], gsize string_size)
+gchar * regex_replace_by_table (const gchar * string, const gchar * const delete_string[][2], gsize string_size)
 {
-    gchar *result_string = (gchar *) string;
+    gchar * result_string = (gchar*) string;
 
     /* Match strings to delete */
-    for(gsize it = 0; it < string_size; it++) {
-        GError *match_error = NULL;
-        GRegex *regex = g_regex_new(delete_string[it][0], G_REGEX_CASELESS /*| G_REGEX_MULTILINE*/, 0, &match_error);
-
-        if(regex != NULL) {
-            GMatchInfo *match_info;
-            g_regex_match_full(regex, string, -1, 0, 0, &match_info, &match_error);
-            while(g_match_info_matches(match_info)) {
-                gchar *word = g_match_info_fetch(match_info, 0);
-                gchar *old_memory = result_string;
-                result_string = strreplace(old_memory, word, delete_string[it][1]);
-                if(old_memory != string) {
-                    g_free(old_memory);
+    for (gsize it = 0; it < string_size; it++)
+    {
+        GError * match_error = NULL;
+        GRegex * regex = g_regex_new (delete_string[it][0],G_REGEX_CASELESS /*| G_REGEX_MULTILINE*/,0,&match_error);
+
+        if (regex != NULL)
+        {
+            GMatchInfo * match_info;
+            g_regex_match_full (regex, string, -1, 0, 0, &match_info,&match_error);
+            while (g_match_info_matches (match_info) )
+            {
+                gchar *word = g_match_info_fetch (match_info, 0);
+                gchar * old_memory = result_string;
+                result_string = strreplace (old_memory,word,delete_string[it][1]);
+                if (old_memory != string)
+                {
+                    g_free (old_memory);
                 }
 
-                g_match_info_next(match_info, &match_error);
-                g_free(word);
+                g_match_info_next (match_info, &match_error);
+                g_free (word);
             }
-            g_match_info_free(match_info);
-            g_regex_unref(regex);
+            g_match_info_free (match_info);
+            g_regex_unref (regex);
         }
 
-        if(match_error != NULL) {
-            fprintf(stderr, "glyr: Unexcepted error while matching: %s\n", match_error->message);
-            g_error_free(match_error);
+        if (match_error != NULL)
+        {
+            fprintf (stderr,"glyr: Unexcepted error while matching: %s\n", match_error->message);
+            g_error_free (match_error);
         }
     }
 
     /* Trim it the old way - we have to dup the string anyway */
-    if(result_string != NULL) {
-        gsize result_len = strlen(result_string);
-        gchar *trim = g_malloc0(result_len + 1);
-        trim_copy(result_string, trim);
-        if(result_string != string) {
-            g_free(result_string);
+    if (result_string != NULL)
+    {
+        gsize result_len = strlen (result_string);
+        gchar * trim = g_malloc0 (result_len + 1);
+        trim_copy (result_string,trim);
+        if (result_string != string)
+        {
+            g_free (result_string);
         }
         result_string = trim;
     }
@@ -185,43 +186,48 @@ gchar *regex_replace_by_table(const gchar *string, const gchar *const delete_str
 
 ///////////////////////////////
 
-gsize levenshtein_strcasecmp(const gchar *string, const gchar *other)
+gsize levenshtein_strcasecmp (const gchar * string, const gchar * other)
 {
     gsize diff = 100;
-    if(string != NULL && other != NULL) {
+    if (string != NULL && other != NULL)
+    {
         /* Lowercase UTF8 string might have more or less bytes! */
-        gchar *lower_string = g_utf8_strdown(string, -1);
-        gchar *lower_other  = g_utf8_strdown(other, -1);
+        gchar * lower_string = g_utf8_strdown (string,-1);
+        gchar * lower_other  = g_utf8_strdown (other, -1);
 
-        if(lower_string && lower_other) {
-            diff = levenshtein_safe_strcmp(lower_string, lower_other);
+        if (lower_string && lower_other)
+        {
+            diff = levenshtein_safe_strcmp (lower_string, lower_other);
         }
 
-        g_free(lower_string);
-        g_free(lower_other);
+        g_free (lower_string);
+        g_free (lower_other);
     }
     return diff;
 }
 
 ///////////////////////////////
 
-static gchar *leven_normalize_string(const gchar *str)
+static gchar * leven_normalize_string (const gchar * str)
 {
-    gchar *rv = NULL;
-    gchar *unwinded_string = unwind_artist_name(str);
-    if(unwinded_string != NULL) {
-        gchar *norm_string = regex_replace_by_table(unwinded_string, regex_table, regex_table_size);
-        if(norm_string != NULL) {
-            gchar *pretty_string = beautify_string(norm_string);
-            if(pretty_string != NULL) {
-                remove_tags_from_string(pretty_string, -1, '(', ')');
-                remove_tags_from_string(pretty_string, -1, '[', ']');
-                remove_tags_from_string(pretty_string, -1, '<', '>');
+    gchar * rv = NULL;
+    gchar * unwinded_string = unwind_artist_name (str);
+    if (unwinded_string != NULL)
+    {
+        gchar * norm_string = regex_replace_by_table (unwinded_string,regex_table,regex_table_size);
+        if (norm_string != NULL)
+        {
+            gchar * pretty_string = beautify_string (norm_string);
+            if (pretty_string != NULL)
+            {
+                remove_tags_from_string (pretty_string,-1,'(',')');
+                remove_tags_from_string (pretty_string,-1,'[',']');
+                remove_tags_from_string (pretty_string,-1,'<','>');
                 rv = pretty_string;
             }
-            g_free(norm_string);
+            g_free (norm_string);
         }
-        g_free(unwinded_string);
+        g_free (unwinded_string);
     }
     return rv;
 }
@@ -229,49 +235,54 @@ static gchar *leven_normalize_string(const gchar *str)
 ///////////////////////////////
 
 /* Tries to strip unused strings before comparing with levenshtein_strcasecmp */
-gsize levenshtein_strnormcmp(GlyrQuery *settings, const gchar *string, const gchar *other)
+gsize levenshtein_strnormcmp (GlyrQuery * settings, const gchar * string, const gchar * other)
 {
     gsize diff = 100;
-    if(string != NULL && other != NULL) {
-        gchar *normalized_string = leven_normalize_string(string);
-        gchar *normalized_other  = leven_normalize_string(other);
+    if (string != NULL && other != NULL)
+    {
+        gchar * normalized_string = leven_normalize_string (string);
+        gchar * normalized_other  = leven_normalize_string (other);
 
-        if(normalized_string && normalized_other) {
-            diff = levenshtein_strcasecmp(normalized_string, normalized_other);
+        if (normalized_string && normalized_other)
+        {
+            diff = levenshtein_strcasecmp (normalized_string,normalized_other);
 
             /* Apply correction */
-            gsize str_len = strlen(normalized_string);
-            gsize oth_len = strlen(normalized_other);
+            gsize str_len = strlen (normalized_string);
+            gsize oth_len = strlen (normalized_other);
             gsize ratio = (oth_len + str_len) / 2;
             gsize fuzz  = (settings) ? settings->fuzzyness : GLYR_DEFAULT_FUZZYNESS;
 
             /* Useful for debugging */
-            //g_print("%d:%s <=> %d:%s -> %d\n", gint)str_len,string, gint)oth_len, ther, gint)diff);
+            //g_print("%d:%s <=> %d:%s -> %d\n",(gint)str_len,string,(gint)oth_len,other,(gint)diff);
 
-            if((ratio - diff < ratio / 2 + 1 && diff <= fuzz) || MIN(str_len, oth_len) <= diff) {
+            if ( (ratio - diff < ratio / 2 + 1 && diff <= fuzz) || MIN (str_len,oth_len) <= diff)
+            {
                 /* Examples: Adios <=> Wei or 19 <=> 21 pass levenshtein_strcasecmp */
-                //g_print("warn: The strings might accidentally pass levenshtein: %s <=> %s = %d\n", retty_string, retty_other, gint)diff);
+                //g_print("warn: The strings might accidentally pass levenshtein: %s <=> %s = %d\n",pretty_string,pretty_other,(gint)diff);
                 diff += 100;
             }
         }
 
-        g_free(normalized_string);
-        g_free(normalized_other);
+        g_free (normalized_string);
+        g_free (normalized_other);
     }
     return diff;
 }
 
 ///////////////////////////////
 
-gchar *strreplace(const char *string, const char *subs, const char *with)
+gchar * strreplace (const char * string, const char * subs, const char * with)
 {
-    gchar *result = NULL;
-    if(string != NULL && string[0] != '\0') {
-        gchar **split = g_strsplit(string, subs, 0);
-        if(split != NULL) {
-            result = g_strjoinv(with, split);
+    gchar * result = NULL;
+    if (string != NULL && string[0] != '\0')
+    {
+        gchar ** split = g_strsplit (string,subs,0);
+        if (split != NULL)
+        {
+            result = g_strjoinv (with,split);
         }
-        g_strfreev(split);
+        g_strfreev (split);
     }
     return result;
 }
@@ -281,148 +292,167 @@ gchar *strreplace(const char *string, const char *subs, const char *with)
 /* "Clapton, Eric" -> "Eric Clapton"
  * Cheers Christoph for writing this.
  */
-gchar *unwind_artist_name(const gchar *artist)
+gchar * unwind_artist_name (const gchar * artist)
 {
-    if(NULL == artist) {
+    if (NULL == artist)
+    {
         return NULL;
     }
 
     /*split string in two*/
-    gchar *separator = strchr(artist, ', );
+    gchar * separator = strchr (artist, ',');
 
-    if(separator) {
-        gchar *result = NULL;
-        gchar **strsplit = g_strsplit(artist, ", , 2);
-        if((strsplit[0] != NULL) && (strsplit[1] != NULL)) {
-            char *tmp = NULL;
+    if (separator)
+    {
+        gchar * result = NULL;
+        gchar ** strsplit = g_strsplit (artist, ",", 2);
+        if ( (strsplit[0] != NULL) && (strsplit[1] != NULL) )
+        {
+            char * tmp = NULL;
 
             tmp = strsplit[0];
             strsplit[0] = strsplit[1];
             strsplit[1] = tmp;
         }
 
-        result = g_strjoinv(" ", strsplit);
+        result = g_strjoinv (" ",strsplit);
 
         /*free g_strsplit memory*/
-        g_strfreev(strsplit);
+        g_strfreev (strsplit);
         return result;
-    } else {
+    }
+    else
+    {
         /* nothing done, return just copy*/
-        return g_strdup(artist);
+        return g_strdup (artist);
     }
 }
 
 ///////////////////////////////////////
 
-gchar *prepare_string(const gchar *input, GLYR_NORMALIZATION mode, gboolean do_curl_escape)
+gchar * prepare_string (const gchar * input, GLYR_NORMALIZATION mode, gboolean do_curl_escape)
 {
-    gchar *result = NULL;
-    if(input != NULL) {
-        gchar *downed = g_utf8_strdown(input, -1);
-        if(downed != NULL) {
-            gchar *normalized = g_utf8_normalize(downed, -1, G_NORMALIZE_NFKC);
-            if(normalized != NULL) {
-                if(normalized != NULL && mode & GLYR_NORMALIZE_AGGRESSIVE) {
-                    remove_tags_from_string(normalized, -1, '(', ')');
-                    remove_tags_from_string(normalized, -1, '<', '>');
-                    remove_tags_from_string(normalized, -1, '[', ']');
+    gchar * result = NULL;
+    if (input != NULL)
+    {
+        gchar * downed = g_utf8_strdown (input,-1);
+        if (downed != NULL)
+        {
+            gchar * normalized = g_utf8_normalize (downed,-1,G_NORMALIZE_NFKC);
+            if (normalized != NULL)
+            {
+                if (normalized != NULL && mode & GLYR_NORMALIZE_AGGRESSIVE)
+                {
+                    remove_tags_from_string (normalized,-1,'(',')');
+                    remove_tags_from_string (normalized,-1,'<','>');
+                    remove_tags_from_string (normalized,-1,'[',']');
                 }
 
-                if(mode & GLYR_NORMALIZE_MODERATE || mode & GLYR_NORMALIZE_AGGRESSIVE) {
-                    gchar *no_lint = regex_replace_by_table(normalized, regex_table, regex_table_size);
+                if (mode & GLYR_NORMALIZE_MODERATE || mode & GLYR_NORMALIZE_AGGRESSIVE)
+                {
+                    gchar * no_lint = regex_replace_by_table (normalized,regex_table,regex_table_size);
                     g_free(normalized);
                     normalized = no_lint;
                 }
 
-                if(normalized != NULL) {
-                    if(do_curl_escape) {
-                        char *m_result = curl_easy_escape(NULL, normalized, 0);
-                        result = g_strdup(m_result);
-                        curl_free(m_result);
+                if (normalized != NULL)
+                {
+                    if (do_curl_escape)
+                    {
+                        char * m_result = curl_easy_escape (NULL, normalized, 0);
+                        result = g_strdup (m_result);
+                        curl_free (m_result);
                         g_free(normalized);
-                    } else {
+                    }
+                    else
+                    {
                         result = normalized;
                     }
                 }
-            } else {
+            }
+            else
+            {
                 result = normalized;
             }
-            g_free(downed);
+            g_free (downed);
         }
     }
     return result;
 }
 
-static void swap_string(char **tmp, const char *subs, const char *with)
+static void swap_string (char ** tmp, const char * subs, const char * with)
 {
-    char *swap = *tmp;
-    *tmp = strreplace(swap, subs, with);
-    g_free(swap);
+    char * swap = *tmp;
+    *tmp = strreplace (swap,subs,with);
+    g_free (swap);
 }
 
 /* Prepares the url for you to get downloaded. You don't have to call this. */
-gchar *prepare_url(const gchar *URL, GlyrQuery *s, gboolean do_curl_escape)
+gchar * prepare_url (const gchar * URL, GlyrQuery * s, gboolean do_curl_escape)
 {
-    gchar *tmp = NULL;
-    if(URL != NULL && s != NULL) {
-        tmp = g_strdup(URL);
-
-        gchar *unwinded_artist = unwind_artist_name(s->artist);
-        gchar *p_artist = NULL, * p_album = NULL, * p_title = NULL;
-
-        if(s->normalization & GLYR_NORMALIZE_ARTIST) {
-            p_artist = prepare_string(trim_nocopy(unwinded_artist), s->normalization, do_curl_escape);
-        } else {
-            p_artist = prepare_string(trim_nocopy(unwinded_artist), GLYR_NORMALIZE_NONE, do_curl_escape);
-        }
-
-        if(s->normalization & GLYR_NORMALIZE_ALBUM) {
-            p_album  = prepare_string(s->album, s->normalization, do_curl_escape);
-        } else {
-            p_album  = prepare_string(s->album, GLYR_NORMALIZE_NONE, do_curl_escape);
-        }
-
-        if(s->normalization & GLYR_NORMALIZE_TITLE) {
-            p_title  = prepare_string(s->title, s->normalization, do_curl_escape);
-        } else {
-            p_title  = prepare_string(s->title, GLYR_NORMALIZE_NONE, do_curl_escape);
-        }
-
-        gchar *p_num = g_strdup_printf("%d", s->number * 3);
-
-        swap_string(&tmp, "${artist}", p_artist);
-        swap_string(&tmp, "${album}", p_album);
-        swap_string(&tmp, "${title}", p_title);
-        swap_string(&tmp, "${number}", p_num);
-
-        g_free(p_artist);
-        g_free(p_album);
-        g_free(p_title);
-        g_free(p_num);
-        g_free(unwinded_artist);
+    gchar * tmp = NULL;
+    if (URL != NULL && s != NULL)
+    {
+        tmp = g_strdup (URL);
+
+        gchar * unwinded_artist = unwind_artist_name (s->artist);
+        gchar * p_artist = NULL, * p_album = NULL, * p_title = NULL;
+
+        if (s->normalization & GLYR_NORMALIZE_ARTIST)
+            p_artist = prepare_string (trim_nocopy (unwinded_artist), s->normalization, do_curl_escape);
+        else
+            p_artist = prepare_string (trim_nocopy (unwinded_artist), GLYR_NORMALIZE_NONE, do_curl_escape);
+
+        if (s->normalization & GLYR_NORMALIZE_ALBUM)
+            p_album  = prepare_string (s->album, s->normalization, do_curl_escape);
+        else
+            p_album  = prepare_string (s->album, GLYR_NORMALIZE_NONE, do_curl_escape);
+
+        if (s->normalization & GLYR_NORMALIZE_TITLE)
+            p_title  = prepare_string (s->title, s->normalization, do_curl_escape);
+        else
+            p_title  = prepare_string (s->title, GLYR_NORMALIZE_NONE, do_curl_escape);
+
+        gchar * p_num = g_strdup_printf("%d", s->number * 3);
+
+        swap_string (&tmp,"${artist}",p_artist);
+        swap_string (&tmp,"${album}", p_album);
+        swap_string (&tmp,"${title}", p_title);
+        swap_string (&tmp,"${number}", p_num);
+
+        g_free (p_artist);
+        g_free (p_album);
+        g_free (p_title);
+        g_free (p_num);
+        g_free (unwinded_artist);
     }
     return tmp;
 }
 
 ///////////////////////////////////////
 
-gchar *get_next_word(const gchar *string, const gchar *delim, gsize *offset, gsize len)
+gchar * get_next_word (const gchar * string, const gchar * delim, gsize *offset, gsize len)
 {
-    gchar *word = NULL;
-    if(string && delim && * (offset) < len) {
-        gchar *occurence = strstr(string + (*offset), delim);
-        if(occurence) {
-            word = copy_value(string + (*offset), occurence);
-            * (offset) += (1 + occurence - (string + * (offset)));
-        } else {
-            word = copy_value(string + (*offset), string + len);
+    gchar * word = NULL;
+    if (string && delim && * (offset) < len)
+    {
+        gchar * occurence = strstr (string+ (*offset),delim);
+        if (occurence)
+        {
+            word=copy_value (string+ (*offset),occurence);
+            * (offset) += (1 + occurence - (string + * (offset) ) );
+        }
+        else
+        {
+            word=copy_value (string+ (*offset),string+len);
             * (offset) = len;
         }
     }
-    if(word) {
-        gchar *trim = g_malloc0(len + 1);
-        trim_copy(word, trim);
-        free(word);
+    if (word)
+    {
+        gchar * trim = g_malloc0 (len + 1);
+        trim_copy (word,trim);
+        free (word);
         word = trim;
     }
     return word;
@@ -430,57 +460,74 @@ gchar *get_next_word(const gchar *string, const gchar *delim, gsize *offset, gsi
 
 ///////////////////////////////////////
 
-static int convert_to_char(const gchar *string)
+static int convert_to_char(const gchar * string)
 {
-    if(string != NULL) {
-        if(string[0] == 'x' || string[0] == 'X') {
-            return strtoul(string + 1, NULL, 16);
+    if (string != NULL)
+    {
+        if (string[0] == 'x' || string[0] == 'X') {
+            return strtoul (string + 1, NULL, 16);
         } else {
-            return strtoul(string, NULL, 10);
+            return strtoul (string, NULL, 10);
         }
     }
     return ' ';
 }
 
 /* Translate HTML UTF8 marks to normal UTF8 (&#xFF; or e.g. &#123; -> char 123) */
-char *unescape_html_UTF8(const char *data)
+char *unescape_html_UTF8 (const char * data)
 {
-    char *result = NULL;
-    if(data != NULL) {
-        size_t i = 0, len = strlen(data);
+    char * result = NULL;
+    if (data != NULL)
+    {
+        size_t i = 0, len = strlen (data);
         int tagflag = 0;
         int iB = 0;
 
-        char *tag_open_ptr = NULL;
-        result = g_malloc0(len + 1);
-        for(i = 0; i  < len; ++i) {
-            char *semicol = NULL;
-            if(data[i] == '&' && data[i + 1] == '#' && (semicol = strstr(data + i, ";")) != NULL) {
-                int n = convert_to_char(&data[i + 2]);
-
-                if(n >= 0x800) {
-                    result[iB++] = (char)(0xe0 | ((n >> 12) & 0x0f));
-                    result[iB++] = (char)(0x80 | ((n >> 6) & 0x3f));
-                    result[iB++] = (char)(0x80 | ((n) & 0x3f));
-                } else if(n >= 0x80) {
-                    result[iB++] = (char)(0xc0 | ((n >> 6) & 0x1f));
-                    result[iB++] = (char)(0x80 | ((n) & 0x3f));
-                } else {
+        char * tag_open_ptr = NULL;
+        result = g_malloc0 (len+1);
+        for (i = 0; i  < len; ++i)
+        {
+            char * semicol = NULL;
+            if (data[i] == '&' && data[i+1] == '#' && (semicol = strstr (data+i,";") ) != NULL)
+            {
+                int n = convert_to_char(&data[i+2]);
+
+                if (n >= 0x800)
+                {
+                    result[iB++] = (char) (0xe0 | ( (n >> 12) & 0x0f) );
+                    result[iB++] = (char) (0x80 | ( (n >> 6 ) & 0x3f) );
+                    result[iB++] = (char) (0x80 | ( (n      ) & 0x3f) );
+                }
+                else if (n >= 0x80)
+                {
+                    result[iB++] = (char) (0xc0 | ( (n >> 6) & 0x1f) );
+                    result[iB++] = (char) (0x80 | ( (n     ) & 0x3f) );
+                }
+                else
+                {
                     result[iB++] = (char) n;
                 }
-                i = (int)(semicol - data);
-            } else { /* normal char */
-                if(data[i] == '<') {
-                    tag_open_ptr = (char *) &data[i + 1];
+                i =  (int) (semicol-data);
+            }
+            else /* normal char */
+            {
+                if (data[i] == '<')
+                {
+                    tag_open_ptr = (char*) &data[i+1];
                     tagflag = 1;
                     continue;
                 }
 
-                if(tagflag ==  0) {
+                if (tagflag ==  0 )
+                {
                     result[iB++] = data[i];
-                } else if(data[i] == '>') {
-                    if(tag_open_ptr != NULL) {
-                        if(g_strstr_len(tag_open_ptr, 7, "br") != NULL) {
+                }
+                else if (data[i] == '>')
+                {
+                    if (tag_open_ptr != NULL)
+                    {
+                        if (g_strstr_len (tag_open_ptr,7,"br") != NULL)
+                        {
                             result[iB++] = '\n';
                         }
                     }
@@ -499,7 +546,8 @@ char *unescape_html_UTF8(const char *data)
  * Thanks for this. Probably directly from wikipedia: https://secure.wikimedia.org/wikipedia/en/wiki/List_of_XML_and_HTML_character_entity_references
  * I don't know a way how this can be done easier. But it's working well, so I guess I just let it be...
  */
-const char *html_to_unicode_table[][2] = {
+const char * html_to_unicode_table[][2] =
+{
     { "AElig", "" },
     { "Aacute", "" },
     { "Acirc", "" },
@@ -759,48 +807,54 @@ const char *html_to_unicode_table[][2] = {
 ///////////////////////////////////////
 
 /* returns newly allocated string without unicode like expressions */
-char *strip_html_unicode(const gchar *string)
+char * strip_html_unicode (const gchar * string)
 {
-    if(string == NULL) {
+    if (string == NULL)
         return NULL;
-    }
 
     // Total length, iterator and resultbuf
-    gsize sR_len = strlen(string), sR_i = 0;
-    gchar *sResult = g_malloc0(sR_len + 1);
+    gsize sR_len = strlen (string), sR_i = 0;
+    gchar * sResult = g_malloc0 (sR_len + 1);
 
-    for(gsize aPos = 0; aPos < sR_len; aPos++) {
+    for (gsize aPos = 0; aPos < sR_len; aPos++)
+    {
         // An ampersand might be a hint
-        if(string[aPos] == '&') {
-            gchar *semicolon = NULL;
-            if((semicolon  = strchr(string + aPos, ';')) != NULL) {
+        if (string[aPos] == '&')
+        {
+            gchar * semicolon = NULL;
+            if ( (semicolon  = strchr (string+aPos,';') ) != NULL)
+            {
                 // The distance between '&' and ';'
-                gsize diff = semicolon - (string + aPos);
+                gsize diff = semicolon - (string+aPos);
 
                 // Only translate codes shorter than 10 signs.
-                if(diff > 0 && diff < 8) {
+                if (diff > 0 && diff < 8)
+                {
                     // copy that portion so we can find the translation
                     gchar cmp_buf[diff];
-                    strncpy(cmp_buf, string + aPos + 1 , diff - 1);
-                    cmp_buf[diff - 1] = '\0';
+                    strncpy (cmp_buf, string + aPos + 1 ,diff-1);
+                    cmp_buf[diff-1] = '\0';
 
                     // Now find the 'translation' of this code
                     // This is a bit slow for performance aware applications
                     // Glyr isn't because it has to wait for data from the internet most
                     // of the time. You might want to add some sort of 'Hash'
                     gsize iter = 0;
-                    while(html_to_unicode_table[iter][0] != NULL) {
-                        if(html_to_unicode_table[iter][0] &&  !strcmp(cmp_buf, html_to_unicode_table[iter][0])) {
+                    while ( html_to_unicode_table[iter][0] != NULL )
+                    {
+                        if (html_to_unicode_table[iter][0] &&  !strcmp (cmp_buf,html_to_unicode_table[iter][0]) )
+                        {
                             break;
                         }
                         iter++;
                     }
 
                     // If nothing found we just copy it
-                    if(html_to_unicode_table[iter][0] != NULL && html_to_unicode_table[iter][1] != NULL) {
+                    if (html_to_unicode_table[iter][0] != NULL && html_to_unicode_table[iter][1] != NULL)
+                    {
                         // Copy the translation to the string
-                        gsize trans_len = strlen(html_to_unicode_table[iter][1]);
-                        strncpy(sResult + sR_i, html_to_unicode_table[iter][1], trans_len);
+                        gsize trans_len = strlen (html_to_unicode_table[iter][1]);
+                        strncpy (sResult + sR_i, html_to_unicode_table[iter][1], trans_len);
 
                         // Overjump next bytes.
                         sR_i += trans_len;
@@ -827,23 +881,28 @@ char *strip_html_unicode(const gchar *string)
  * This is only used for HTML tags, there might be utf8 characters,
  * being rendered with the same glyph as '<', but won't escaped.
  */
-gsize remove_tags_from_string(gchar *string, gint length, gchar start, gchar end)
+gsize remove_tags_from_string (gchar * string, gint length, gchar start, gchar end)
 {
-    gchar *tagEnd;
+    gchar * tagEnd;
     gsize ctr = 0;
-    if(string != NULL) {
-        gsize Len = (length < 0) ? strlen(string) : (size_t) length;
-        if(Len != 0) {
-            for(gsize n = Len - 1; n != 0; --n) {
-                if(string[n] == start) {
-                    if((tagEnd = strchr(string + n + 1, end)) != NULL) {
-                        gchar *Tpon = tagEnd + 1;
-                        gsize tLen = Tpon - (string + n);
+    if (string != NULL)
+    {
+        gsize Len = (length < 0) ? strlen (string) : (size_t) length;
+        if (Len != 0)
+        {
+            for (gsize n = Len-1; n != 0; --n)
+            {
+                if (string[n] == start)
+                {
+                    if ( (tagEnd = strchr (string + n + 1,end) ) != NULL)
+                    {
+                        gchar * Tpon = tagEnd + 1;
+                        gsize tLen = Tpon - (string+n);
                         gsize rest = string + Len - tagEnd;
 
                         tLen = (tLen < rest) ? tLen : rest;
-                        memcpy(string + n, Tpon, tLen);
-                        memmove(Tpon, Tpon + tLen, rest - tLen);
+                        memcpy (string+n, Tpon, tLen);
+                        memmove (Tpon,Tpon+tLen,rest-tLen);
                         ctr += tLen;
                     }
                 }
@@ -855,24 +914,27 @@ gsize remove_tags_from_string(gchar *string, gint length, gchar start, gchar end
 
 ///////////////////////////////////////
 
-static gchar *trim_in_text(gchar *string)
+static gchar * trim_in_text (gchar * string)
 {
-    gchar *buffer = NULL;
-    if(string != NULL) {
-        gsize str_len = strlen(string), buf_pos = 0;
-        buffer = g_malloc0(str_len + 1);
+    gchar * buffer = NULL;
+    if (string != NULL)
+    {
+        gsize str_len = strlen (string), buf_pos = 0;
+        buffer = g_malloc0 (str_len + 1);
 
-        gsize space_ctr = 0;
+        gsize space_ctr= 0;
         gsize lfeed_ctr = 0;
 
-        for(gsize it = 0; it < str_len; it++) {
-            gboolean is_space = isspace(string[it]);
-            gboolean is_lfeed = !isblank(string[it]) && is_space;
+        for (gsize it = 0; it < str_len; it++)
+        {
+            gboolean is_space = isspace (string[it]);
+            gboolean is_lfeed = !isblank (string[it]) && is_space;
 
             lfeed_ctr = (is_lfeed) ? lfeed_ctr + 1 : 0;
             space_ctr = (is_space) ? space_ctr + 1 : 0;
 
-            if(space_ctr < 2 || lfeed_ctr) {
+            if (space_ctr < 2 || lfeed_ctr)
+            {
                 buffer[buf_pos++] = string[it];
             }
         }
@@ -884,25 +946,32 @@ static gchar *trim_in_text(gchar *string)
 
 /* Beautify lyrics in general, by removing endline spaces, *
  * trimming everything and removing double newlines        */
-gchar *beautify_string(const gchar *lyrics)
+gchar * beautify_string (const gchar * lyrics)
 {
-    gchar *result = NULL;
+    gchar * result = NULL;
 
     /* Strip special html entities */
-    gchar *strip = unescape_html_UTF8(lyrics);
-    if(strip != NULL) {
+    gchar * strip = unescape_html_UTF8 (lyrics);
+    if (strip != NULL)
+    {
         /* Now convert all unichars like &#[x]num; */
-        gchar *unicode = strip_html_unicode(strip);
+        gchar * unicode = strip_html_unicode (strip);
 
-        if(unicode != NULL) {
-            gsize Len = strlen(unicode);
-            for(gsize i = 0; i < Len; i++) {
+        if (unicode != NULL)
+        {
+            gsize Len = strlen (unicode);
+            for (gsize i = 0; i < Len; i++)
+            {
                 gsize newline_ctr = 0;
                 gsize j = i;
-                for(; j < Len && (unicode[j] == '\n' || unicode[j] == '\r'); j++) {
-                    if(newline_ctr % 3 == 0) {
+                for (; j < Len && (unicode[j] == '\n' || unicode[j] == '\r'); j++)
+                {
+                    if (newline_ctr % 3 == 0)
+                    {
                         unicode[j] = '\n';
-                    } else {
+                    }
+                    else
+                    {
                         unicode[j] = ' ';
                     }
                     newline_ctr++;
@@ -910,21 +979,24 @@ gchar *beautify_string(const gchar *lyrics)
                 i = j + 1;
             }
 
-            remove_tags_from_string(unicode, Len, '<', '>');
+            remove_tags_from_string (unicode,Len,'<','>');
             // gchar * trimmed = trim_after_newline(unicode);
-            gchar *trimmed = trim_in_text(unicode);
-            g_free(unicode);
+            gchar * trimmed = trim_in_text (unicode);
+            g_free (unicode);
 
-            if(trimmed && g_utf8_validate(trimmed, -1, NULL) == TRUE) {
-                result = g_utf8_normalize(trimmed, -1, G_NORMALIZE_NFKC);
-                g_free(trimmed);
-            } else {
+            if (trimmed && g_utf8_validate (trimmed,-1,NULL) == TRUE)
+            {
+                result = g_utf8_normalize (trimmed,-1,G_NORMALIZE_NFKC);
+                g_free (trimmed);
+            }
+            else
+            {
                 result = trimmed;
             }
 
-            trim_inplace(result);
+            trim_inplace (result);
         }
-        g_free(strip);
+        g_free (strip);
     }
     return result;
 }
@@ -933,23 +1005,26 @@ gchar *beautify_string(const gchar *lyrics)
 ///////////////////////////////////////
 
 /* Does not necessarely handle unicode, just ascii */
-void trim_copy(gchar *input, gchar *output)
+void trim_copy (gchar *input, gchar *output)
 {
     gchar *end = output;
     gchar c;
 
     /* skip spaces at start */
-    while(input[0] && isspace(*input)) {
+    while (input[0] && isspace (*input) )
+    {
         ++input;
     }
 
     /* copy the rest while remembering the last non-whitespace */
-    while(input[0]) {
+    while (input[0])
+    {
         // copy character
         c = * (output++) = * (input++);
 
         /* if its not a whitespace, this *could* be the last character */
-        if(!isspace(c)) {
+        if ( !isspace (c) )
+        {
             end = output;
         }
     }
@@ -961,36 +1036,33 @@ void trim_copy(gchar *input, gchar *output)
 
 ///////////////////////////////////////
 
-void trim_inplace(gchar *s)
+void trim_inplace (gchar *s)
 {
-    trim_copy(s, s);
+    trim_copy (s, s);
 }
 
 ///////////////////////////////////////
 
 /* Returns new pointer */
-gchar *trim_nocopy(gchar *s)
+gchar * trim_nocopy (gchar * s)
 {
-    gchar *start = s;
-    gchar *end = NULL;
+    gchar * start = s;
+    gchar * end = NULL;
 
     /* skip spaces at start */
-    while(*start && isspace(*start)) {
+    while (*start && isspace (*start) )
         ++start;
-    }
 
     /* iterate over the rest remebering last non-whitespace */
     char *i = start;
-    while(*i) {
-        if(!isspace(* (i++))) {
+    while (*i)
+    {
+        if ( !isspace (* (i++) ) )
             end = i;
-        }
     }
 
     /* white the terminating zero after last non-whitespace */
-    if(end != NULL) {
-        *end = 0;
-    }
+    if (end !=NULL) *end = 0;
 
     return start;
 }
@@ -998,14 +1070,16 @@ gchar *trim_nocopy(gchar *s)
 ///////////////////////////////////////
 
 /* Just copies the value from begin to start (excluding end[0]) */
-gchar *copy_value(const gchar *begin, const gchar *end)
+gchar * copy_value (const gchar * begin, const gchar * end)
 {
-    if(begin && end) {
+    if (begin && end)
+    {
         gsize length = end - begin;
-        gchar *buffer = g_malloc0(length + 1);
+        gchar * buffer = g_malloc0 (length+1);
 
-        if(buffer != NULL) {
-            strncpy(buffer, begin, length);
+        if (buffer != NULL)
+        {
+            strncpy (buffer,begin,length);
             buffer[length] = '\0';
         }
         return buffer;
@@ -1015,15 +1089,19 @@ gchar *copy_value(const gchar *begin, const gchar *end)
 
 ///////////////////////////////////////
 
-void chomp_breakline(gchar *string)
+void chomp_breakline (gchar * string)
 {
-    if(string != NULL) {
-        gsize len = strlen(string);
-        while(--len) {
-            if(string[len] == '\n') {
+    if (string != NULL)
+    {
+        gsize len = strlen (string);
+        while (--len)
+        {
+            if (string[len] == '\n')
+            {
                 string[len] = '\0';
-                if(len != 0 && string[len - 1] == '\r') {
-                    string[len - 1] = '\0';
+                if (len != 0 && string[len-1] == '\r')
+                {
+                    string[len-1] = '\0';
                 }
                 break;
             }
@@ -1033,33 +1111,39 @@ void chomp_breakline(gchar *string)
 
 ///////////////////////////////////////
 
-gchar *convert_charset(const gchar *string, gchar *from, gchar *to, gsize *new_size)
+gchar * convert_charset (const gchar * string, gchar * from, gchar * to, gsize * new_size)
 {
-    gchar *conv_string = NULL;
+    gchar * conv_string = NULL;
     GIConv converter;
-    if((converter = g_iconv_open(from, to)) != (GIConv) - 1) {
-        GError *err_step_one = NULL;
-        conv_string = g_convert_with_iconv(string, -1, converter, NULL, new_size, &err_step_one);
-        if(conv_string == NULL) {
-            g_print("conversion-error: %s\n", err_step_one->message);
+    if ( (converter = g_iconv_open (from,to) ) != (GIConv)-1)
+    {
+        GError * err_step_one = NULL;
+        conv_string = g_convert_with_iconv (string,-1,converter,NULL,new_size,&err_step_one);
+        if (conv_string == NULL)
+        {
+            g_print ("conversion-error: %s\n",err_step_one->message);
         }
-        g_iconv_close(converter);
-    } else {
-        g_print("Unable to convert charsets.\n");
+        g_iconv_close (converter);
+    }
+    else
+    {
+        g_print ("Unable to convert charsets.\n");
     }
     return conv_string;
 }
 
 ///////////////////////////////////////
 
-gchar *get_search_value(gchar *ref, gchar *name, gchar *end_string)
+gchar * get_search_value (gchar * ref, gchar * name, gchar * end_string)
 {
-    gchar *result = NULL;
-    if(ref && name) {
-        gchar *begin = strstr(ref, name);
-        if(begin != NULL) {
-            begin += strlen(name);
-            result = copy_value(begin, strstr(begin, end_string));
+    gchar * result = NULL;
+    if (ref && name)
+    {
+        gchar * begin = strstr (ref,name);
+        if (begin != NULL)
+        {
+            begin += strlen (name);
+            result = copy_value (begin,strstr (begin,end_string) );
         }
     }
     return result;
@@ -1068,43 +1152,45 @@ gchar *get_search_value(gchar *ref, gchar *name, gchar *end_string)
 ///////////////////////////////////////
 
 /* Note: Not case-sens:  -> a! */
-const gchar *const umlaut_table[][2] = {
+const gchar * const umlaut_table[][2] =
+{
     {"",  "a"},
     {"",  "u"},
     {"",  "o"},
     {"", "ss"},
-    {"\\s", "-"}
+    {"\\s","-"}
 };
 
-const gsize umlaut_table_size = sizeof(umlaut_table) / (2 * sizeof(gchar *));
+const gsize umlaut_table_size = sizeof (umlaut_table) / (2 * sizeof (gchar*) );
 
 /* Replaces umlauts like  with an approx. like a */
-gchar *translate_umlauts(gchar *string)
+gchar * translate_umlauts (gchar * string)
 {
-    gchar *result = NULL;
-    if(string != NULL) {
-        result = regex_replace_by_table(string, umlaut_table, umlaut_table_size);
+    gchar * result = NULL;
+    if (string != NULL)
+    {
+        result = regex_replace_by_table (string,umlaut_table,umlaut_table_size);
     }
     return result;
 }
 
 /* Match string against a GRegex */
-gboolean regex_match_compiled(const gchar *string, const GRegex *cRegex)
+gboolean regex_match_compiled (const gchar * string, const GRegex * cRegex)
 {
     gboolean retv = FALSE;
-    if(string != NULL) {
-        if(cRegex == NULL) {
+    if (string != NULL)
+    {
+        if (cRegex == NULL)
             return TRUE;
-        }
 
-        retv = g_regex_match(cRegex, string, 0, NULL);
+        retv = g_regex_match (cRegex, string, 0, NULL);
     }
     return retv;
 }
 
 #if 0
-int main(int argc, char *argv[])
+int main (int argc, char * argv[])
 {
-    printf("%s\n", regex_replace_by_table(argv[1], regex_table, regex_table_size));
+    printf ("%s\n", regex_replace_by_table (argv[1], regex_table, regex_table_size) );
 }
 #endif
diff --git a/lib/testing.c b/lib/testing.c
index 7298ee1..d56764f 100644
--- a/lib/testing.c
+++ b/lib/testing.c
@@ -26,16 +26,20 @@
 
 /////////////////////////////////
 
-static MetaDataSource *get_metadata_struct(const char *provider_name, GLYR_GET_TYPE type)
+static MetaDataSource * get_metadata_struct (const char * provider_name, GLYR_GET_TYPE type)
 {
-    MetaDataSource *result = NULL;
-    if(provider_name && type !=  GLYR_GET_UNKNOWN) {
-        gsize name_len = strlen(provider_name);
-        GList *source_list = r_getSList();
-        for(GList *elem = source_list; elem; elem = elem->next) {
-            MetaDataSource *src = elem->data;
-            if(src != NULL) {
-                if(g_ascii_strncasecmp(provider_name, src->name, name_len) == 0 && src->type == type) {
+    MetaDataSource * result = NULL;
+    if (provider_name && type !=  GLYR_GET_UNKNOWN)
+    {
+        gsize name_len = strlen (provider_name);
+        GList * source_list = r_getSList();
+        for (GList * elem = source_list; elem; elem = elem->next)
+        {
+            MetaDataSource * src = elem->data;
+            if (src != NULL)
+            {
+                if (g_ascii_strncasecmp (provider_name,src->name,name_len) == 0 && src->type == type)
+                {
                     result = src;
                     break;
                 }
@@ -47,19 +51,23 @@ static MetaDataSource *get_metadata_struct(const char *provider_name, GLYR_GET_T
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-const char *glyr_testing_call_url(const char *provider_name, GLYR_GET_TYPE type, GlyrQuery *query)
+__attribute__ ( (visibility ("default") ) )
+const char * glyr_testing_call_url (const char * provider_name, GLYR_GET_TYPE type, GlyrQuery * query)
 {
-    const char *result = NULL;
-    if(query != NULL) {
-        MetaDataSource *src = get_metadata_struct(provider_name, type);
-        if(src != NULL) {
-            const char *url = src->get_url(query);
-            if(url != NULL) {
-                result = prepare_url(url, query, TRUE);
+    const char * result = NULL;
+    if (query != NULL)
+    {
+        MetaDataSource * src = get_metadata_struct (provider_name,type);
+        if (src != NULL)
+        {
+            const char * url = src->get_url (query);
+            if (url != NULL)
+            {
+                result = prepare_url (url,query,TRUE);
 
-                if(src->free_url) {
-                    g_free((gchar *) url);
+                if (src->free_url)
+                {
+                    g_free ( (gchar*) url);
                 }
             }
         }
@@ -69,27 +77,32 @@ const char *glyr_testing_call_url(const char *provider_name, GLYR_GET_TYPE type,
 
 /////////////////////////////////
 
-__attribute__((visibility("default")))
-GlyrMemCache *glyr_testing_call_parser(const char *provider_name, GLYR_GET_TYPE type, GlyrQuery *query, GlyrMemCache *cache)
+__attribute__ ( (visibility ("default") ) )
+GlyrMemCache * glyr_testing_call_parser (const char * provider_name, GLYR_GET_TYPE type, GlyrQuery * query, GlyrMemCache * cache)
 {
-    GlyrMemCache *result = NULL;
-    if(query && cache) {
-        MetaDataSource *src = get_metadata_struct(provider_name, type);
-        if(src != NULL) {
+    GlyrMemCache * result = NULL;
+    if (query && cache)
+    {
+        MetaDataSource * src = get_metadata_struct (provider_name,type);
+        if (src != NULL)
+        {
             cb_object fake;
             fake.cache = cache;
             fake.s     = query;
-            GList *result_list = src->parser(&fake);
+            GList * result_list = src->parser (&fake);
 
-            if(result_list != NULL) {
+            if (result_list != NULL)
+            {
                 result = result_list->data;
             }
 
-            for(GList *elem = result_list; elem; elem = elem->next) {
-                GlyrMemCache *item = elem->data;
-                if(item != NULL) {
-                    update_md5sum(item);
-                    item->prov = g_strdup(provider_name);
+            for (GList * elem = result_list; elem; elem = elem->next)
+            {
+                GlyrMemCache * item = elem->data;
+                if (item != NULL)
+                {
+                    update_md5sum (item);
+                    item->prov = g_strdup (provider_name);
                     item->type = src->data_type;
                     item->prev = (elem->prev) ? (elem->prev->data) : NULL;
                     item->next = (elem->next) ? (elem->next->data) : NULL;
diff --git a/spec/capi/check_api.c b/spec/capi/check_api.c
index 4d23b77..93b0705 100644
--- a/spec/capi/check_api.c
+++ b/spec/capi/check_api.c
@@ -25,35 +25,35 @@
 //--------------------
 //--------------------
 
-START_TEST(test_glyr_init)
+START_TEST (test_glyr_init)
 {
     GlyrQuery q;
-    fail_unless(glyr_get(NULL, NULL, NULL) == NULL, "glyr_get() should return NULL without INIT");
-    fail_unless(glyr_get(&q, NULL, NULL) == NULL, "glyr_get() should still return NULL, even with uninitalized query.");
+    fail_unless (glyr_get (NULL,NULL,NULL) == NULL,"glyr_get() should return NULL without INIT");
+    fail_unless (glyr_get (&q,NULL,NULL) == NULL,"glyr_get() should still return NULL, even with uninitalized query.");
 
     glyr_init();
-    fail_unless(glyr_get(NULL, NULL, NULL) == NULL, "glyr_get() should return NULL without INIT");
-    fail_unless(glyr_get(&q, NULL, NULL) == NULL, "should not access bad memory");
+    fail_unless (glyr_get (NULL,NULL,NULL) == NULL,"glyr_get() should return NULL without INIT");
+    fail_unless (glyr_get (&q,NULL,NULL) == NULL,"should not access bad memory");
 
     glyr_init();
-    fail_unless(glyr_get(NULL, NULL, NULL) == NULL, "glyr_get() should return NULL without INIT");
-    fail_unless(glyr_get(&q, NULL, NULL) == NULL, "should not access bad memory");
+    fail_unless (glyr_get (NULL,NULL,NULL) == NULL,"glyr_get() should return NULL without INIT");
+    fail_unless (glyr_get (&q,NULL,NULL) == NULL,"should not access bad memory");
 
     glyr_cleanup();
     glyr_cleanup();
-    fail_unless(glyr_get(NULL, NULL, NULL) == NULL, "glyr_get() should return NULL without INIT");
-    fail_unless(glyr_get(&q, NULL, NULL) == NULL, "should not access bad memory");
+    fail_unless (glyr_get (NULL,NULL,NULL) == NULL,"glyr_get() should return NULL without INIT");
+    fail_unless (glyr_get (&q,NULL,NULL) == NULL,"should not access bad memory");
 
-    glyr_query_init(&q);
-    fail_unless(q.is_initalized == 0xDEADBEEF, NULL);
-    fail_unless(glyr_get(&q, NULL, NULL) == NULL, "should not access bad memory");
-    glyr_query_destroy(&q);
+    glyr_query_init (&q);
+    fail_unless (q.is_initalized == 0xDEADBEEF,NULL);
+    fail_unless (glyr_get (&q,NULL,NULL) == NULL,"should not access bad memory");
+    glyr_query_destroy (&q);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_destroy_before_init)
+START_TEST (test_glyr_destroy_before_init)
 {
     glyr_cleanup();
     glyr_init();
@@ -63,120 +63,120 @@ END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_query_init)
+START_TEST (test_glyr_query_init)
 {
     GlyrQuery q;
 
     /* Crash? */
-    glyr_query_init(NULL);
+    glyr_query_init (NULL);
 
-    glyr_query_init(&q);
-    fail_unless(q.is_initalized == 0xDEADBEEF, NULL);
+    glyr_query_init (&q);
+    fail_unless (q.is_initalized == 0xDEADBEEF,NULL);
 
-    GlyrQuery *alloc = malloc(sizeof(GlyrQuery));
-    glyr_query_init(alloc);
-    fail_unless(alloc->is_initalized == 0xDEADBEEF, NULL);
+    GlyrQuery * alloc = malloc (sizeof (GlyrQuery) );
+    glyr_query_init (alloc);
+    fail_unless (alloc->is_initalized == 0xDEADBEEF,NULL);
 
-    glyr_query_destroy(&q);
+    glyr_query_destroy (&q);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_cache_free)
+START_TEST (test_glyr_cache_free)
 {
-    GlyrMemCache *test = glyr_cache_new();
-    glyr_cache_free(NULL);
-    glyr_cache_free(test);
+    GlyrMemCache * test = glyr_cache_new();
+    glyr_cache_free (NULL);
+    glyr_cache_free (test);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_cache_copy)
+START_TEST (test_glyr_cache_copy)
 {
-    GlyrMemCache *test = glyr_cache_new();
-    glyr_cache_set_data(test, g_strdup("some data"), -1);
-    test->next = (GlyrMemCache *) 0x1010;
-    test->prev = (GlyrMemCache *) 0x0101;
-
-    GlyrMemCache *copy = glyr_cache_copy(test);
-    fail_unless(memcmp(copy->data, test->data, test->size) == 0, "Should have the same data");
-    fail_unless(copy->next == NULL, NULL);
-    fail_unless(copy->prev == NULL, NULL);
-
-    glyr_cache_free(copy);
-    glyr_cache_free(test);
+    GlyrMemCache * test = glyr_cache_new();
+    glyr_cache_set_data (test,g_strdup ("some data"),-1);
+    test->next = (GlyrMemCache*) 0x1010;
+    test->prev = (GlyrMemCache*) 0x0101;
+
+    GlyrMemCache * copy = glyr_cache_copy (test);
+    fail_unless (memcmp (copy->data,test->data,test->size) == 0,"Should have the same data");
+    fail_unless (copy->next == NULL,NULL);
+    fail_unless (copy->prev == NULL,NULL);
+
+    glyr_cache_free (copy);
+    glyr_cache_free (test);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_query_destroy)
+START_TEST (test_glyr_query_destroy)
 {
     GlyrQuery q;
-    glyr_query_destroy(NULL);
-    glyr_query_destroy(&q);
-    glyr_query_init(&q);
-    glyr_query_destroy(&q);
+    glyr_query_destroy (NULL);
+    glyr_query_destroy (&q);
+    glyr_query_init (&q);
+    glyr_query_destroy (&q);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_free_list)
+START_TEST (test_glyr_free_list)
 {
-    glyr_free_list(NULL);
-    GlyrMemCache *new1 = glyr_cache_new();
-    GlyrMemCache *new2 = glyr_cache_new();
-    GlyrMemCache *new3 = glyr_cache_new();
+    glyr_free_list (NULL);
+    GlyrMemCache * new1 = glyr_cache_new();
+    GlyrMemCache * new2 = glyr_cache_new();
+    GlyrMemCache * new3 = glyr_cache_new();
     new2->next = new3;
     new2->prev = new1;
-    glyr_free_list(new2);
+    glyr_free_list (new2);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_cache_set_data)
+START_TEST (test_glyr_cache_set_data)
 {
-    glyr_cache_set_data(NULL, "lala", 10);
+    glyr_cache_set_data (NULL,"lala",10);
 
-    GlyrMemCache *c = glyr_cache_new();
-    c->data = g_strdup("Hello?");
-    c->size = strlen("Hello?");
-    glyr_cache_update_md5sum(c);
+    GlyrMemCache * c = glyr_cache_new();
+    c->data = g_strdup ("Hello?");
+    c->size = strlen ("Hello?");
+    glyr_cache_update_md5sum (c);
     unsigned char old_sum[16] = {0};
-    memcpy(old_sum, c->md5sum, 16);
+    memcpy (old_sum,c->md5sum,16);
     size_t old_size = c->size;
 
-    glyr_cache_set_data(c, g_strdup(" World!"), -1);
+    glyr_cache_set_data (c,g_strdup (" World!"),-1);
 
-    fail_if(g_strcmp0(c->data, " World!"), NULL);
-    fail_if(old_size == c->size, NULL);
-    fail_if(!memcmp(old_sum, c->md5sum, 16), NULL);
+    fail_if (g_strcmp0 (c->data," World!"),NULL);
+    fail_if (old_size == c->size,NULL);
+    fail_if (!memcmp (old_sum,c->md5sum,16),NULL);
 
-    glyr_cache_free(c);
+    glyr_cache_free (c);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_cache_write)
+START_TEST (test_glyr_cache_write)
 {
     glyr_init();
 
-    glyr_cache_write(NULL, "/tmp");
-    GlyrMemCache *tmp = glyr_cache_new();
-    glyr_cache_write(tmp, NULL);
+    glyr_cache_write (NULL,"/tmp");
+    GlyrMemCache * tmp = glyr_cache_new();
+    glyr_cache_write (tmp,NULL);
 
-    glyr_cache_set_data(tmp, g_strdup("Test data of the cache"), -1);
-    glyr_cache_write(tmp, "stdout");
-    glyr_cache_write(tmp, "stderr");
-    glyr_cache_write(tmp, "null");
-    glyr_cache_write(tmp, "/tmp/test.txt");
+    glyr_cache_set_data (tmp,g_strdup ("Test data of the cache"),-1);
+    glyr_cache_write (tmp,"stdout");
+    glyr_cache_write (tmp,"stderr");
+    glyr_cache_write (tmp,"null");
+    glyr_cache_write (tmp,"/tmp/test.txt");
 
-    glyr_cache_free(tmp);
+    glyr_cache_free (tmp);
     glyr_cleanup();
 }
 END_TEST
@@ -185,52 +185,52 @@ END_TEST
 //--------------------
 //--------------------
 
-START_TEST(test_glyr_download)
+START_TEST (test_glyr_download)
 {
     glyr_init();
-    atexit(glyr_cleanup);
-    GlyrMemCache *c = glyr_download("www.duckduckgo.com", NULL);
-    fail_unless(c != NULL, "Could not load www.google.de");
-    glyr_cache_free(c);
+    atexit (glyr_cleanup);
+    GlyrMemCache * c = glyr_download ("www.duckduckgo.com",NULL);
+    fail_unless (c != NULL,"Could not load www.google.de");
+    glyr_cache_free (c);
 }
 END_TEST
 
 //--------------------
 
-Suite *create_test_suite(void)
+Suite * create_test_suite (void)
 {
-    Suite *s = suite_create("Libglyr API");
+    Suite *s = suite_create ("Libglyr API");
 
     /* Core test case */
-    TCase *tc_core = tcase_create("Init");
-    tcase_add_test(tc_core, test_glyr_init);
-    tcase_add_test(tc_core, test_glyr_destroy_before_init);
-    tcase_add_test(tc_core, test_glyr_query_init);
-    tcase_add_test(tc_core, test_glyr_query_destroy);
-    tcase_add_test(tc_core, test_glyr_free_list);
-    tcase_add_test(tc_core, test_glyr_cache_free);
-    tcase_add_test(tc_core, test_glyr_cache_copy);
-    tcase_add_test(tc_core, test_glyr_cache_set_data);
-    tcase_add_test(tc_core, test_glyr_cache_write);
-    tcase_add_test(tc_core, test_glyr_download);
-    suite_add_tcase(s, tc_core);
+    TCase * tc_core = tcase_create ("Init");
+    tcase_add_test (tc_core, test_glyr_init);
+    tcase_add_test (tc_core, test_glyr_destroy_before_init);
+    tcase_add_test (tc_core, test_glyr_query_init);
+    tcase_add_test (tc_core, test_glyr_query_destroy);
+    tcase_add_test (tc_core, test_glyr_free_list);
+    tcase_add_test (tc_core, test_glyr_cache_free);
+    tcase_add_test (tc_core, test_glyr_cache_copy);
+    tcase_add_test (tc_core, test_glyr_cache_set_data);
+    tcase_add_test (tc_core, test_glyr_cache_write);
+    tcase_add_test (tc_core, test_glyr_download);
+    suite_add_tcase (s, tc_core);
     return s;
 }
 
 //--------------------
 
-int main(void)
+int main (void)
 {
     init();
 
     int number_failed;
     Suite *s = create_test_suite();
 
-    SRunner *sr = srunner_create(s);
-    srunner_set_log(sr, "check_glyr_api.log");
-    srunner_run_all(sr, CK_VERBOSE);
+    SRunner * sr = srunner_create (s);
+    srunner_set_log (sr, "check_glyr_api.log");
+    srunner_run_all (sr, CK_VERBOSE);
 
-    number_failed = srunner_ntests_failed(sr);
-    srunner_free(sr);
+    number_failed = srunner_ntests_failed (sr);
+    srunner_free (sr);
     return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
 };
diff --git a/spec/capi/check_dbc.c b/spec/capi/check_dbc.c
index 3638d14..a9c7fb6 100644
--- a/spec/capi/check_dbc.c
+++ b/spec/capi/check_dbc.c
@@ -28,31 +28,31 @@
 
 //--------------------
 
-static int counter_callback(GlyrQuery *q, GlyrMemCache *c, void *userptr)
+static int counter_callback (GlyrQuery * q, GlyrMemCache * c, void * userptr)
 {
-    int *i = userptr;
+    int * i = userptr;
     *i += 1;
     return 0;
 }
 
-static int count_db_items(GlyrDatabase *db)
+static int count_db_items (GlyrDatabase * db)
 {
     int c = 0;
-    glyr_db_foreach(db, counter_callback, &c);
+    glyr_db_foreach (db,counter_callback,&c);
     return c;
 }
 
-static void cleanup_db(void)
+static void cleanup_db (void)
 {
-    system("rm -rf /tmp/check/");
+    system ("rm -rf /tmp/check/");
 }
 
 
-static GlyrDatabase *setup_db(void)
+static GlyrDatabase * setup_db (void)
 {
     cleanup_db();
-    system("mkdir -p /tmp/check");
-    return glyr_db_init("/tmp/check");
+    system ("mkdir -p /tmp/check");
+    return glyr_db_init ("/tmp/check");
 }
 
 //--------------------
@@ -60,290 +60,291 @@ static GlyrDatabase *setup_db(void)
 //--------------------
 //--------------------
 
-START_TEST(test_create_db)
+START_TEST (test_create_db)
 {
-    glyr_db_init(NULL);
-    GlyrDatabase *db = glyr_db_init("/tmp/");
-    glyr_db_destroy(db);
-    glyr_db_destroy(NULL);
+    glyr_db_init (NULL);
+    GlyrDatabase * db = glyr_db_init ("/tmp/");
+    glyr_db_destroy (db);
+    glyr_db_destroy (NULL);
 
-    system("rm /tmp/metadata.db");
+    system ("rm /tmp/metadata.db");
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_simple_db)
+START_TEST (test_simple_db)
 {
     GlyrQuery q;
-    setup(&q, GLYR_GET_LYRICS, 10);
-    glyr_opt_artist(&q, "Equi");
-    glyr_opt_title(&q, "lala");
+    setup (&q,GLYR_GET_LYRICS,10);
+    glyr_opt_artist (&q,"Equi");
+    glyr_opt_title (&q,"lala");
 
-    GlyrDatabase *db = setup_db();
+    GlyrDatabase * db = setup_db();
 
-    GlyrMemCache *ct = glyr_cache_new();
+    GlyrMemCache * ct = glyr_cache_new();
 
-    glyr_cache_set_data(ct, g_strdup("test"), -1);
+    glyr_cache_set_data (ct,g_strdup ("test"),-1);
 
-    glyr_db_insert(NULL, &q, (GlyrMemCache *) 0x1);
-    fail_unless(count_db_items(db) == 0, NULL);
-    glyr_db_insert(db, NULL, (GlyrMemCache *) 0x1);
-    fail_unless(count_db_items(db) == 0, NULL);
-    glyr_db_insert(db, &q, NULL);
-    fail_unless(count_db_items(db) == 0, NULL);
+    glyr_db_insert (NULL,&q, (GlyrMemCache*) 0x1);
+    fail_unless (count_db_items (db) == 0, NULL);
+    glyr_db_insert (db,NULL, (GlyrMemCache*) 0x1);
+    fail_unless (count_db_items (db) == 0, NULL);
+    glyr_db_insert (db,&q,NULL);
+    fail_unless (count_db_items (db) == 0, NULL);
 
-    glyr_db_insert(db, &q, ct);
-    GlyrMemCache *c = glyr_db_lookup(db, &q);
-    fail_unless(c != NULL, NULL);
-    fail_unless(c->data != NULL, NULL);
-    fail_unless(count_db_items(db) == 1, NULL);
+    glyr_db_insert (db,&q,ct);
+    GlyrMemCache * c = glyr_db_lookup (db,&q);
+    fail_unless (c != NULL, NULL);
+    fail_unless (c->data != NULL, NULL);
+    fail_unless (count_db_items (db) == 1, NULL);
 
-    glyr_db_destroy(db);
-    glyr_cache_free(ct);
-    glyr_query_destroy(&q);
+    glyr_db_destroy (db);
+    glyr_cache_free (ct);
+    glyr_query_destroy (&q);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_iter_db)
+START_TEST (test_iter_db)
 {
     GlyrQuery q;
-    setup(&q, GLYR_GET_LYRICS, 10);
-    glyr_opt_artist(&q, "Equi");
-    glyr_opt_title(&q, "lala");
+    setup (&q,GLYR_GET_LYRICS,10);
+    glyr_opt_artist (&q,"Equi");
+    glyr_opt_title (&q,"lala");
 
-    GlyrDatabase *db = setup_db();
+    GlyrDatabase * db = setup_db();
 
     GlyrQuery nugget;
-    setup(&nugget, GLYR_GET_COVERART, 40);
-    glyr_opt_artist(&nugget, "A very special artist");
-    glyr_opt_album(&nugget, "A very special album");
+    setup (&nugget,GLYR_GET_COVERART,40);
+    glyr_opt_artist (&nugget,"A very special artist");
+    glyr_opt_album (&nugget,"A very special album");
 
-    GTimer *insert_time = g_timer_new();
+    GTimer * insert_time = g_timer_new();
 
     const int N = 5000;
-    for(int i = 0; i < N; i++) {
-        GlyrMemCache *ct = glyr_cache_new();
-        glyr_cache_set_data(ct, g_strdup_printf("test# %d", i + 1), -1);
-        ct->dsrc = g_strdup_printf("Dummy url %d", i + 1);
+    for (int i = 0; i < N; i++)
+    {
+        GlyrMemCache * ct = glyr_cache_new();
+        glyr_cache_set_data (ct,g_strdup_printf ("test# %d",i+1),-1);
+        ct->dsrc = g_strdup_printf ("Dummy url %d",i+1);
 
-        if(i % 2) {
+        if (i % 2)
             ct->rating = N ;
-        } else {
+        else
             ct->rating = N ;
-        }
 
-        if(i % 23) {
-            glyr_db_insert(db, &q, ct);
-        } else {
-            glyr_db_insert(db, &nugget, ct);
-        }
+        if (i % 23)
+            glyr_db_insert (db,&q,ct);
+        else
+            glyr_db_insert (db,&nugget,ct);
 
-        glyr_cache_free(ct);
+        glyr_cache_free (ct);
     }
 
-    g_timer_stop(insert_time);
-    g_message("Used %.5f seconds to insert..", g_timer_elapsed(insert_time, NULL));
+    g_timer_stop (insert_time);
+    g_message ("Used %.5f seconds to insert..",g_timer_elapsed (insert_time,NULL) );
 
     /* Check if N items are in DB */
-    int cdb = count_db_items(db);
-    g_message("Counted %d items", cdb);
-    fail_unless(cdb == N, NULL);
+    int cdb = count_db_items (db);
+    g_message ("Counted %d items",cdb);
+    fail_unless (cdb == N, NULL);
 
     /* Test if case-insensitivity works */
-    glyr_opt_artist(&q, "eQuI");
-    glyr_opt_title(&q, "LALA");
+    glyr_opt_artist (&q,"eQuI");
+    glyr_opt_title (&q,"LALA");
 
     float fine_grained = 0.0;
-    GTimer *grain_time = g_timer_new();
+    GTimer * grain_time = g_timer_new();
 
-    g_timer_start(insert_time);
+    g_timer_start (insert_time);
 
-    GlyrMemCache *c, * ptr;
-    for(int i = 1; i <= N / 10; i++) {
-        g_timer_start(grain_time);
+    GlyrMemCache * c, * ptr;
+    for (int i = 1; i <= N/10; i++)
+    {
+        g_timer_start (grain_time);
         /* Get a list of the caches */
-        if(i % 10) {
-            c = glyr_db_lookup(db, &q);
-        } else {
-            c = glyr_db_lookup(db, &nugget);
-        }
+        if (i % 10)
+            c = glyr_db_lookup (db,&q);
+        else
+            c = glyr_db_lookup (db,&nugget);
 
-        g_timer_stop(grain_time);
-        fine_grained += g_timer_elapsed(grain_time, NULL);
+        g_timer_stop (grain_time);
+        fine_grained += g_timer_elapsed (grain_time,NULL);
 
         ptr = c;
-        fail_if(ptr == NULL);
+        fail_if (ptr == NULL);
 
         int last_rating = INT_MAX;
         int ctr = 0;
-        while(ptr) {
+        while (ptr)
+        {
             ctr++;
-            fail_unless(last_rating >= ptr->rating);
+            fail_unless (last_rating >= ptr->rating);
             last_rating = ptr->rating;
             ptr = ptr->next;
         }
-        glyr_free_list(c);
+        glyr_free_list (c);
 
         /* Test if we got exactly 10 or 42 items, (honoring number setting) */
 
-        if(i % 10) {
-            fail_unless(ctr == 10);
-        } else {
-            fail_unless(ctr == 40);
-        }
+        if (i % 10)
+            fail_unless (ctr == 10);
+        else
+            fail_unless (ctr == 40);
     }
 
 
-    g_timer_stop(insert_time);
-    g_message("Used %.5f seconds to lookup..", g_timer_elapsed(insert_time, NULL));
-    g_message("Used %.5f for actual lookup..", fine_grained);
+    g_timer_stop (insert_time);
+    g_message ("Used %.5f seconds to lookup..",g_timer_elapsed (insert_time,NULL) );
+    g_message ("Used %.5f for actual lookup..",fine_grained);
 
-    glyr_db_destroy(db);
-    glyr_query_destroy(&q);
-    glyr_query_destroy(&nugget);
+    glyr_db_destroy (db);
+    glyr_query_destroy (&q);
+    glyr_query_destroy (&nugget);
 
-    g_timer_destroy(insert_time);
-    g_timer_destroy(grain_time);
+    g_timer_destroy (insert_time);
+    g_timer_destroy (grain_time);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_sorted_rating)
+START_TEST (test_sorted_rating)
 {
     const int N = 10;
 
-    GlyrDatabase *db = setup_db();
+    GlyrDatabase * db = setup_db();
 
     GlyrQuery q;
-    glyr_query_init(&q);
-    setup(&q, GLYR_GET_LYRICS, N);
+    glyr_query_init (&q);
+    setup (&q,GLYR_GET_LYRICS,N);
 
-    for(int i = 0; i < N; ++i) {
+    for (int i = 0; i < N; ++i)
+    {
         int rate = (i / 2) + 1;
 
-        GlyrMemCache *ct = glyr_cache_new();
-        fail_if(ct == NULL);
+        GlyrMemCache * ct = glyr_cache_new();
+        fail_if (ct == NULL);
 
-        glyr_cache_set_data(ct, g_strdup_printf("MyLyrics %d", i), -1);
-        ct->dsrc = g_strdup("http://MyLyrics.com");
+        glyr_cache_set_data (ct,g_strdup_printf ("MyLyrics %d",i),-1);
+        ct->dsrc = g_strdup ("http://MyLyrics.com");
         ct->rating = rate;
-        glyr_db_insert(db, &q, ct);
+        glyr_db_insert (db,&q,ct);
 
-        glyr_cache_free(ct);
+        glyr_cache_free (ct);
     }
 
-    fail_unless(count_db_items(db) == N);
+    fail_unless (count_db_items (db) == N);
 
-    GlyrMemCache *list = glyr_db_lookup(db, &q);
-    GlyrMemCache *iter = list;
-    fail_if(list == NULL);
+    GlyrMemCache * list = glyr_db_lookup (db,&q);
+    GlyrMemCache * iter = list;
+    fail_if (list == NULL);
 
     double last_timestamp = DBL_MAX;
     int last_rating = INT_MAX;
-    while(iter) {
-        glyr_cache_print(iter);
-        fail_unless(last_rating >= iter->rating);
-        if(last_rating == iter->rating) {
-            fail_unless(last_timestamp >= iter->timestamp);
-        }
+    while (iter)
+    {
+        glyr_cache_print (iter);
+        fail_unless (last_rating >= iter->rating);
+        if (last_rating == iter->rating)
+            fail_unless (last_timestamp >= iter->timestamp);
 
         last_timestamp = iter->timestamp;
         last_rating = iter->rating;
         iter = iter->next;
     }
 
-    glyr_free_list(list);
+    glyr_free_list (list);
 }
 END_TEST
 
 //--------------------
 
 /* Write artist|album|title, select only artist|title */
-START_TEST(test_intelligent_lookup)
+START_TEST (test_intelligent_lookup)
 {
-    GlyrDatabase *db = setup_db();
+    GlyrDatabase * db = setup_db();
 
     GlyrQuery alt;
-    glyr_query_init(&alt);
+    glyr_query_init (&alt);
 
-    gchar *artist = "";
-    gchar *album  = "Ot Serdca k Nebu";
-    gchar *title  = "Pokrovy Nebesnogo Startsa (Shrouds Of Celestial Sage)";
+    gchar * artist = "";
+    gchar * album  = "Ot Serdca k Nebu";
+    gchar * title  = "Pokrovy Nebesnogo Startsa (Shrouds Of Celestial Sage)";
 
-    glyr_opt_artist(&alt, artist);
-    glyr_opt_album(&alt, album);
-    glyr_opt_title(&alt, title);
-    glyr_opt_type(&alt, GLYR_GET_LYRICS);
+    glyr_opt_artist (&alt,artist);
+    glyr_opt_album (&alt,album );
+    glyr_opt_title (&alt,title );
+    glyr_opt_type  (&alt,GLYR_GET_LYRICS);
 
-    GlyrMemCache *subject = glyr_cache_new();
-    glyr_cache_set_data(subject, g_strdup("These are lyrics. Really."), -1);
+    GlyrMemCache * subject = glyr_cache_new();
+    glyr_cache_set_data (subject,g_strdup ("These are lyrics. Really."),-1);
 
-    glyr_db_insert(db, &alt, subject);
+    glyr_db_insert (db,&alt,subject);
 
-    GlyrMemCache *one = glyr_db_lookup(db, &alt);
-    fail_if(one == NULL, NULL);
-    fail_if(memcmp(one->md5sum, subject->md5sum, 16) != 0, NULL);
-    glyr_cache_free(one);
+    GlyrMemCache * one = glyr_db_lookup (db,&alt);
+    fail_if (one == NULL,NULL);
+    fail_if (memcmp (one->md5sum,subject->md5sum,16) != 0, NULL);
+    glyr_cache_free (one);
 
     alt.album = NULL;
-    GlyrMemCache *two = glyr_db_lookup(db, &alt);
-    fail_if(two == NULL, NULL);
-    fail_if(memcmp(two->md5sum, subject->md5sum, 16) != 0, NULL);
-    glyr_cache_free(two);
-
-    fail_unless(count_db_items(db) == 1, NULL);
-    int deleted = glyr_db_delete(db, &alt);
-    fail_unless(deleted == 1, NULL);
-    fail_unless(count_db_items(db) == 0, NULL);
-
-    glyr_query_destroy(&alt);
-    glyr_db_destroy(db);
+    GlyrMemCache * two = glyr_db_lookup (db,&alt);
+    fail_if (two == NULL,NULL);
+    fail_if (memcmp (two->md5sum,subject->md5sum,16) != 0, NULL);
+    glyr_cache_free (two);
+
+    fail_unless (count_db_items (db) == 1,NULL);
+    int deleted = glyr_db_delete (db,&alt);
+    fail_unless (deleted == 1,NULL);
+    fail_unless (count_db_items (db) == 0,NULL);
+
+    glyr_query_destroy (&alt);
+    glyr_db_destroy (db);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_db_editplace)
+START_TEST (test_db_editplace)
 {
 
-    GlyrDatabase *db = setup_db();
-    if(db != NULL) {
-        fail_unless(count_db_items(db) == 0, NULL);
+    GlyrDatabase * db = setup_db();
+    if (db != NULL)
+    {
+        fail_unless (count_db_items (db) == 0, NULL);
 
-        GlyrMemCache *test_data = glyr_cache_new();
-        glyr_cache_set_data(test_data, g_strdup("my test data"), -1);
+        GlyrMemCache * test_data = glyr_cache_new();
+        glyr_cache_set_data (test_data,g_strdup ("my test data"),-1);
         GlyrQuery q;
-        setup(&q, GLYR_GET_LYRICS, 1);
-        glyr_db_insert(db, &q, test_data);
+        setup (&q,GLYR_GET_LYRICS,1);
+        glyr_db_insert (db,&q,test_data);
 
-        fail_unless(count_db_items(db) == 1, NULL);
+        fail_unless (count_db_items (db) == 1, NULL);
 
-        GlyrMemCache *edit_one = glyr_cache_new();
-        glyr_cache_set_data(edit_one, g_strdup("my new data"), -1);
-        glyr_db_edit(db, &q, edit_one);
+        GlyrMemCache * edit_one = glyr_cache_new();
+        glyr_cache_set_data (edit_one,g_strdup ("my new data"),-1);
+        glyr_db_edit (db,&q,edit_one);
 
-        fail_unless(count_db_items(db) == 1, NULL);
-        GlyrMemCache *lookup_one = glyr_db_lookup(db, &q);
-        fail_unless(memcmp(lookup_one->data, edit_one->data, edit_one->size) == 0, NULL);
+        fail_unless (count_db_items (db) == 1, NULL);
+        GlyrMemCache * lookup_one = glyr_db_lookup (db,&q);
+        fail_unless (memcmp (lookup_one->data,edit_one->data,edit_one->size) == 0, NULL);
 
-        GlyrMemCache *edit_two = glyr_cache_new();
-        glyr_cache_set_data(edit_two, g_strdup("my even new data"), -1);
-        glyr_db_replace(db, edit_one->md5sum, &q, edit_two);
+        GlyrMemCache * edit_two = glyr_cache_new();
+        glyr_cache_set_data (edit_two,g_strdup ("my even new data"),-1);
+        glyr_db_replace (db,edit_one->md5sum,&q,edit_two);
 
-        fail_unless(count_db_items(db) == 1, NULL);
-        GlyrMemCache *lookup_two = glyr_db_lookup(db, &q);
-        fail_unless(memcmp(lookup_two->data, edit_two->data, edit_two->size) == 0, NULL);
+        fail_unless (count_db_items (db) == 1, NULL);
+        GlyrMemCache * lookup_two = glyr_db_lookup (db,&q);
+        fail_unless (memcmp (lookup_two->data,edit_two->data,edit_two->size) == 0, NULL);
 
-        glyr_cache_free(lookup_one);
-        glyr_cache_free(lookup_two);
-        glyr_cache_free(edit_one);
-        glyr_cache_free(edit_two);
-        glyr_cache_free(test_data);
-        glyr_db_destroy(db);
+        glyr_cache_free (lookup_one);
+        glyr_cache_free (lookup_two);
+        glyr_cache_free (edit_one);
+        glyr_cache_free (edit_two);
+        glyr_cache_free (test_data);
+        glyr_db_destroy (db);
     }
 }
 END_TEST
@@ -351,38 +352,38 @@ END_TEST
 
 //--------------------
 
-Suite *create_test_suite(void)
+Suite * create_test_suite (void)
 {
-    Suite *s = suite_create("Libglyr");
+    Suite *s = suite_create ("Libglyr");
 
     /* Core test case */
-    TCase *tc_dbcache = tcase_create("DBCache");
-    tcase_set_timeout(tc_dbcache, GLYR_DEFAULT_TIMEOUT * 4);
-    tcase_add_test(tc_dbcache, test_create_db);
-    tcase_add_test(tc_dbcache, test_simple_db);
-    tcase_add_test(tc_dbcache, test_iter_db);
-    tcase_add_test(tc_dbcache, test_sorted_rating);
-    tcase_add_test(tc_dbcache, test_intelligent_lookup);
-    tcase_add_test(tc_dbcache, test_db_editplace);
-    suite_add_tcase(s, tc_dbcache);
+    TCase * tc_dbcache = tcase_create ("DBCache");
+    tcase_set_timeout (tc_dbcache,GLYR_DEFAULT_TIMEOUT * 4);
+    tcase_add_test (tc_dbcache, test_create_db);
+    tcase_add_test (tc_dbcache, test_simple_db);
+    tcase_add_test (tc_dbcache, test_iter_db);
+    tcase_add_test (tc_dbcache, test_sorted_rating);
+    tcase_add_test (tc_dbcache, test_intelligent_lookup);
+    tcase_add_test (tc_dbcache, test_db_editplace);
+    suite_add_tcase (s, tc_dbcache);
     return s;
 }
 
 //--------------------
 
-int main(void)
+int main (void)
 {
     init();
 
     int number_failed;
-    Suite *s = create_test_suite();
+    Suite * s = create_test_suite();
 
-    SRunner *sr = srunner_create(s);
-    srunner_set_log(sr, "check_glyr_opt.log");
-    srunner_run_all(sr, CK_VERBOSE);
+    SRunner * sr = srunner_create (s);
+    srunner_set_log (sr, "check_glyr_opt.log");
+    srunner_run_all (sr, CK_VERBOSE);
 
-    number_failed = srunner_ntests_failed(sr);
-    srunner_free(sr);
+    number_failed = srunner_ntests_failed (sr);
+    srunner_free (sr);
 
     cleanup_db();
     return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
diff --git a/spec/capi/check_opt.c b/spec/capi/check_opt.c
index 809ab44..43265dc 100644
--- a/spec/capi/check_opt.c
+++ b/spec/capi/check_opt.c
@@ -22,114 +22,116 @@
 
 //--------------------
 
-static GLYR_ERROR test_callback_ok(GlyrMemCache *c, GlyrQuery *q)
+static GLYR_ERROR test_callback_ok (GlyrMemCache * c, GlyrQuery * q)
 {
     return GLYRE_OK;
 }
 
-static GLYR_ERROR test_callback_post(GlyrMemCache *c, GlyrQuery *q)
+static GLYR_ERROR test_callback_post (GlyrMemCache * c, GlyrQuery * q)
 {
     return GLYRE_STOP_POST;
 }
 
-static GLYR_ERROR test_callback_pre(GlyrMemCache *c, GlyrQuery *q)
+static GLYR_ERROR test_callback_pre (GlyrMemCache * c, GlyrQuery * q)
 {
     return GLYRE_STOP_PRE;
 }
 
-static GLYR_ERROR test_callback_skip1(GlyrMemCache *c, GlyrQuery *q)
+static GLYR_ERROR test_callback_skip1 (GlyrMemCache * c, GlyrQuery * q)
 {
     GLYR_ERROR rc = GLYRE_OK;
-    int *counter = q->callback.user_pointer;
-    if(counter[0]++ % 2 == 0) {
+    int * counter = q->callback.user_pointer;
+    if (counter[0]++ % 2 == 0)
+    {
         rc = GLYRE_SKIP;
     }
     return rc;
 }
 
-static GLYR_ERROR test_callback_skip2(GlyrMemCache *c, GlyrQuery *q)
+static GLYR_ERROR test_callback_skip2 (GlyrMemCache * c, GlyrQuery * q)
 {
     return GLYRE_SKIP;
 }
 
-START_TEST(test_glyr_opt_dlcallback)
+START_TEST (test_glyr_opt_dlcallback)
 {
     GlyrQuery q;
-    GlyrMemCache *list;
+    GlyrMemCache * list;
     gint length = -1;
-    setup(&q, GLYR_GET_ARTIST_PHOTOS, 2);
-    glyr_opt_useragent(&q, "I am a useragent.");
-    glyr_opt_verbosity(&q, 0);
-
-    glyr_opt_dlcallback(&q, test_callback_ok, NULL);
-    list = glyr_get(&q, NULL, &length);
-    g_print("L = %d\n", length);
-    fail_unless(length == 2, NULL);
-    glyr_free_list(list);
-
-    glyr_opt_dlcallback(&q, test_callback_post, NULL);
-    list = glyr_get(&q, NULL, &length);
-    g_print("L = %d\n", length);
-    fail_unless(length == 1, NULL);
-    glyr_free_list(list);
-
-    glyr_opt_dlcallback(&q, test_callback_pre, NULL);
-    list = glyr_get(&q, NULL, &length);
-    g_print("L = %d\n", length);
-    fail_unless(length == 0, NULL);
-    glyr_free_list(list);
+    setup (&q,GLYR_GET_ARTIST_PHOTOS,2);
+    glyr_opt_useragent (&q,"I am a useragent.");
+    glyr_opt_verbosity (&q,0);
+
+    glyr_opt_dlcallback (&q,test_callback_ok,NULL);
+    list = glyr_get (&q,NULL,&length);
+    g_print ("L = %d\n",length);
+    fail_unless (length == 2,NULL);
+    glyr_free_list (list);
+
+    glyr_opt_dlcallback (&q,test_callback_post,NULL);
+    list = glyr_get (&q,NULL,&length);
+    g_print ("L = %d\n",length);
+    fail_unless (length == 1,NULL);
+    glyr_free_list (list);
+
+    glyr_opt_dlcallback (&q,test_callback_pre,NULL);
+    list = glyr_get (&q,NULL,&length);
+    g_print ("L = %d\n",length);
+    fail_unless (length == 0,NULL);
+    glyr_free_list (list);
 
     int ctr = 0;
-    glyr_opt_dlcallback(&q, test_callback_skip1, &ctr);
-    list = glyr_get(&q, NULL, &length);
-    g_print("L = %d\n", length);
-    fail_unless(length == 1, NULL);
-    glyr_free_list(list);
-
-    glyr_opt_dlcallback(&q, test_callback_skip2, NULL);
-    list = glyr_get(&q, NULL, &length);
-    fail_unless(length == 0, NULL);
-    g_print("L = %d\n", length);
-    glyr_free_list(list);
-
-    glyr_query_destroy(&q);
+    glyr_opt_dlcallback (&q,test_callback_skip1,&ctr);
+    list = glyr_get (&q,NULL,&length);
+    g_print ("L = %d\n",length);
+    fail_unless (length == 1,NULL);
+    glyr_free_list (list);
+
+    glyr_opt_dlcallback (&q,test_callback_skip2,NULL);
+    list = glyr_get (&q,NULL,&length);
+    fail_unless (length == 0,NULL);
+    g_print ("L = %d\n",length);
+    glyr_free_list (list);
+
+    glyr_query_destroy (&q);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_opt_redirects)
+START_TEST (test_glyr_opt_redirects)
 {
     GlyrQuery q;
-    setup(&q, GLYR_GET_COVERART, 1);
+    setup (&q,GLYR_GET_COVERART,1);
 
-    glyr_opt_from(&q, "amazon");
-    glyr_opt_redirects(&q, 0);
+    glyr_opt_from (&q,"amazon");
+    glyr_opt_redirects (&q,0);
 
     int length = 0;
     GLYR_ERROR err = GLYRE_OK;
-    GlyrMemCache *list = glyr_get(&q, &err, &length);
-    fail_unless(list == NULL, "should fail due to redirects");
-    if(err != GLYRE_OK) {
-        puts(glyr_strerror(err));
+    GlyrMemCache * list = glyr_get (&q,&err,&length);
+    fail_unless (list == NULL,"should fail due to redirects");
+    if (err != GLYRE_OK)
+    {
+        puts (glyr_strerror (err) );
     }
 
-    unsetup(&q, list);
+    unsetup (&q,list);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_opt_number)
+START_TEST (test_glyr_opt_number)
 {
     GlyrQuery q;
     int length = 0;
-    setup(&q, GLYR_GET_ARTIST_PHOTOS, 4);
-    GlyrMemCache *list = glyr_get(&q, NULL, &length);
+    setup (&q,GLYR_GET_ARTIST_PHOTOS,4);
+    GlyrMemCache * list = glyr_get (&q,NULL,&length);
 
-    fail_unless(length == 4, NULL);
+    fail_unless (length == 4,NULL);
 
-    unsetup(&q, list);
+    unsetup (&q,list);
 }
 END_TEST
 
@@ -137,71 +139,71 @@ END_TEST
 // from
 // plugmax
 
-START_TEST(test_glyr_opt_allowed_formats)
+START_TEST (test_glyr_opt_allowed_formats)
 {
     GlyrQuery q;
-    setup(&q, GLYR_GET_COVERART, 1);
-    glyr_opt_verbosity(&q, 0);
-    glyr_opt_allowed_formats(&q, "png");
+    setup (&q,GLYR_GET_COVERART,1);
+    glyr_opt_verbosity (&q,0);
+    glyr_opt_allowed_formats (&q,"png");
 
     int length = 0;
-    GlyrMemCache *list = glyr_get(&q, NULL, &length);
+    GlyrMemCache * list = glyr_get (&q,NULL,&length);
 
-    fail_if(strcmp(list->img_format, "png") != 0, NULL);
+    fail_if (strcmp (list->img_format,"png") != 0,NULL);
 
-    unsetup(&q, list);
+    unsetup (&q,list);
 }
 END_TEST
 
 //--------------------
 
-START_TEST(test_glyr_opt_proxy)
+START_TEST (test_glyr_opt_proxy)
 {
     GlyrQuery q;
-    setup(&q, GLYR_GET_COVERART, 1);
-    glyr_opt_verbosity(&q, 0);
-    glyr_opt_proxy(&q, "I can haz Existence?");
+    setup (&q,GLYR_GET_COVERART,1);
+    glyr_opt_verbosity (&q,0);
+    glyr_opt_proxy (&q,"I can haz Existence?");
 
-    GlyrMemCache *list = glyr_get(&q, NULL, NULL);
-    fail_unless(list == NULL, NULL);
+    GlyrMemCache * list = glyr_get (&q,NULL,NULL);
+    fail_unless (list == NULL,NULL);
 
-    glyr_cache_free(list);
-    glyr_query_destroy(&q);
+    glyr_cache_free (list);
+    glyr_query_destroy (&q);
 }
 END_TEST
 
 //--------------------
 
-Suite *create_test_suite(void)
+Suite * create_test_suite (void)
 {
-    Suite *s = suite_create("Libglyr");
+    Suite *s = suite_create ("Libglyr");
 
     /* Core test case */
-    TCase *tc_options = tcase_create("Options");
-    tcase_set_timeout(tc_options, GLYR_DEFAULT_TIMEOUT * 4);
-    tcase_add_test(tc_options, test_glyr_opt_dlcallback);
-    tcase_add_test(tc_options, test_glyr_opt_redirects);
-    tcase_add_test(tc_options, test_glyr_opt_number);
-    tcase_add_test(tc_options, test_glyr_opt_allowed_formats);
-    tcase_add_test(tc_options, test_glyr_opt_proxy);
-    suite_add_tcase(s, tc_options);
+    TCase * tc_options = tcase_create ("Options");
+    tcase_set_timeout (tc_options,GLYR_DEFAULT_TIMEOUT * 4);
+    tcase_add_test (tc_options, test_glyr_opt_dlcallback);
+    tcase_add_test (tc_options, test_glyr_opt_redirects);
+    tcase_add_test (tc_options, test_glyr_opt_number);
+    tcase_add_test (tc_options, test_glyr_opt_allowed_formats);
+    tcase_add_test (tc_options, test_glyr_opt_proxy);
+    suite_add_tcase (s, tc_options);
     return s;
 }
 
 //--------------------
 
-int main(void)
+int main (void)
 {
     init();
 
     int number_failed;
-    Suite *s = create_test_suite();
+    Suite * s = create_test_suite();
 
-    SRunner *sr = srunner_create(s);
-    srunner_set_log(sr, "check_glyr_opt.log");
-    srunner_run_all(sr, CK_VERBOSE);
+    SRunner * sr = srunner_create (s);
+    srunner_set_log (sr, "check_glyr_opt.log");
+    srunner_run_all (sr, CK_VERBOSE);
 
-    number_failed = srunner_ntests_failed(sr);
-    srunner_free(sr);
+    number_failed = srunner_ntests_failed (sr);
+    srunner_free (sr);
     return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
 };
diff --git a/spec/capi/test_common.c b/spec/capi/test_common.c
index 6f44a31..d0bb3a2 100644
--- a/spec/capi/test_common.c
+++ b/spec/capi/test_common.c
@@ -24,38 +24,38 @@
 
 #include "../../lib/glyr.h"
 
-void setup(GlyrQuery *q, GLYR_GET_TYPE type, int num)
+void setup (GlyrQuery * q, GLYR_GET_TYPE type, int num)
 {
-    glyr_query_init(q);
-    glyr_opt_artist(q, "Equilibrium");
-    glyr_opt_album(q, "Sagas");
-    glyr_opt_title(q, "Wurzelbert");
-    glyr_opt_type(q, type);
-    glyr_opt_number(q, num);
-    glyr_opt_verbosity(q, 4);
+    glyr_query_init (q);
+    glyr_opt_artist (q,"Equilibrium");
+    glyr_opt_album (q, "Sagas");
+    glyr_opt_title (q, "Wurzelbert");
+    glyr_opt_type (q, type);
+    glyr_opt_number (q,num);
+    glyr_opt_verbosity (q,4);
 }
 
 //--------------------
 
-GlyrQuery *setup_alloc(GLYR_GET_TYPE type, int num)
+GlyrQuery * setup_alloc (GLYR_GET_TYPE type, int num)
 {
-    GlyrQuery *new = g_malloc0(sizeof(GlyrQuery));
-    setup(new, type, num);
+    GlyrQuery * new = g_malloc0 (sizeof (GlyrQuery) );
+    setup (new,type,num);
     return new;
 }
 
 //--------------------
 
-void unsetup(GlyrQuery *q, GlyrMemCache *list)
+void unsetup (GlyrQuery * q, GlyrMemCache * list)
 {
-    glyr_free_list(list);
-    glyr_query_destroy(q);
+    glyr_free_list (list);
+    glyr_query_destroy (q);
 }
 
 //--------------------
 
-void init(void)
+void init (void)
 {
     glyr_init();
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 }
diff --git a/src/examples/async_queue.c b/src/examples/async_queue.c
index f2845c8..1c91f39 100644
--- a/src/examples/async_queue.c
+++ b/src/examples/async_queue.c
@@ -31,77 +31,83 @@
 
 /////////////////////////////////
 
-typedef struct _FinishedNotify {
+typedef struct _FinishedNotify
+{
     gint counter;
-    GAsyncQueue *queue;
+    GAsyncQueue * queue;
 
 } FinishedNotify;
 
 /////////////////////////////////
 
 /* Our polling thread */
-gpointer apollo_orbiter(gpointer gp_queue)
+gpointer apollo_orbiter (gpointer gp_queue)
 {
-    FinishedNotify *pn = gp_queue;
-    g_async_queue_ref(pn->queue);
+    FinishedNotify * pn = gp_queue;
+    g_async_queue_ref (pn->queue);
 
-    while(TRUE) {
-        g_print("\n-----------\n\n");
-        gpointer thread_data = g_async_queue_pop(pn->queue);
+    while (TRUE)
+    {
+        g_print ("\n-----------\n\n");
+        gpointer thread_data = g_async_queue_pop (pn->queue);
 
-        if(thread_data == THREAD_TERMINATOR) {
-            g_printerr("\n-- Terminating --\n");
+        if (thread_data == THREAD_TERMINATOR)
+        {
+            g_printerr ("\n-- Terminating --\n");
             break;
-        } else {
-            GlyrQuery *q = thread_data;
-            GlyrMemCache *head = glyr_get(q, NULL, NULL);
-            if(head != NULL) {
-                g_print("//////// ITEM %d ////////\n", ++pn->counter);
-                glyr_cache_print(head);
-                glyr_free_list(head);
-                g_print("/////////////////////////\n");
+        }
+        else
+        {
+            GlyrQuery * q = thread_data;
+            GlyrMemCache * head = glyr_get (q,NULL,NULL);
+            if (head != NULL)
+            {
+                g_print ("//////// ITEM %d ////////\n",++pn->counter);
+                glyr_cache_print (head);
+                glyr_free_list (head);
+                g_print ("/////////////////////////\n");
             }
-            glyr_query_destroy(q);
+            glyr_query_destroy (q);
         }
     }
 
-    g_async_queue_unref(pn->queue);
+    g_async_queue_unref (pn->queue);
     return NULL;
 }
 
 /////////////////////////////////
 
-void build_queries(GlyrQuery *one, GlyrQuery *two, GlyrQuery *three)
+void build_queries (GlyrQuery * one, GlyrQuery * two, GlyrQuery * three)
 {
-    glyr_query_init(one);
-    glyr_query_init(two);
-    glyr_query_init(three);
+    glyr_query_init (one);
+    glyr_query_init (two);
+    glyr_query_init (three);
 
-    glyr_opt_artist(one, "Diablo Swing Orchestra");
-    glyr_opt_title(one, "Balrog Boogie");
-    glyr_opt_type(one, GLYR_GET_LYRICS);
+    glyr_opt_artist (one,"Diablo Swing Orchestra");
+    glyr_opt_title (one,"Balrog Boogie");
+    glyr_opt_type  (one, GLYR_GET_LYRICS);
 
-    glyr_opt_artist(two, "Farin Urlaub");
-    glyr_opt_download(two, FALSE);
-    glyr_opt_type(two, GLYR_GET_ARTIST_PHOTOS);
+    glyr_opt_artist (two, "Farin Urlaub");
+    glyr_opt_download (two,FALSE);
+    glyr_opt_type  (two, GLYR_GET_ARTIST_PHOTOS);
 
-    glyr_opt_artist(three, "Knorkator");
-    glyr_opt_type(three, GLYR_GET_ARTIST_PHOTOS);
+    glyr_opt_artist (three, "Knorkator");
+    glyr_opt_type  (three, GLYR_GET_ARTIST_PHOTOS);
 }
 
 /////////////////////////////////
 
-gint sort_async_queue_jobs(gconstpointer a, gconstpointer b, gpointer data)
+gint sort_async_queue_jobs (gconstpointer a, gconstpointer b, gpointer data)
 {
     return (a == THREAD_TERMINATOR) ? -1 : (b == THREAD_TERMINATOR) ? 1 : 0;
 }
 
 /////////////////////////////////
 
-int main(void)
+int main (void)
 {
     glyr_init();
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 
     /* Create a new async queue */
     FinishedNotify notify;
@@ -109,39 +115,42 @@ int main(void)
     notify.counter = 0;
 
     /* Initialize a new thread */
-    GError *err = NULL;
-    GThread *apollo = g_thread_new("apollo", apollo_orbiter, &notify);
+    GError * err = NULL;
+    GThread * apollo = g_thread_new("apollo", apollo_orbiter, &notify);
 
-    if(apollo != NULL) {
+    if (apollo != NULL)
+    {
         /* Push a few jobs */
-        GlyrQuery one, two, three;
-        build_queries(&one, &two, &three);
-        g_async_queue_push(notify.queue, &one);
-        g_async_queue_push(notify.queue, &two);
-        g_async_queue_push(notify.queue, &three);
+        GlyrQuery one,two,three;
+        build_queries (&one,&two,&three);
+        g_async_queue_push (notify.queue,&one  );
+        g_async_queue_push (notify.queue,&two  );
+        g_async_queue_push (notify.queue,&three);
 
 #define ABORT_IMMEDIATELY FALSE
 
 #if ABORT_IMMEDIATELY
         /* Test if it really aborts immediately, if not it crashes :-) */
-        g_async_queue_push(notify.queue, (gpointer) 0x2);
+        g_async_queue_push (notify.queue, (gpointer) 0x2);
 #endif
 
         /* Terminate by pushing a special value */
-        g_async_queue_push(notify.queue, THREAD_TERMINATOR);
+        g_async_queue_push (notify.queue,THREAD_TERMINATOR);
 
 #if ABORT_IMMEDIATELY
         /* Sort the THREAD_TERMINATOR before anything else. */
-        g_async_queue_sort(notify.queue, sort_async_queue_jobs, NULL);
+        g_async_queue_sort (notify.queue,sort_async_queue_jobs,NULL);
 #endif
 
         /* Wait till he finished */
-        g_thread_join(apollo);
-    } else {
-        g_printerr("Could not create thread: %s\n", err->message);
-        g_error_free(err);
+        g_thread_join (apollo);
+    }
+    else
+    {
+        g_printerr ("Could not create thread: %s\n",err->message);
+        g_error_free (err);
     }
 
-    g_async_queue_unref(notify.queue);
+    g_async_queue_unref (notify.queue);
     return EXIT_SUCCESS;
 }
diff --git a/src/examples/dbcache.c b/src/examples/dbcache.c
index 6a0c6ca..cc5fc4c 100644
--- a/src/examples/dbcache.c
+++ b/src/examples/dbcache.c
@@ -33,7 +33,7 @@
 #include "../../lib/glyr.h"
 #include "../../lib/cache.h"
 
-int main(int argc, char *argv[])
+int main (int argc, char * argv[])
 {
     int length = -1;
     GlyrQuery query;
@@ -43,64 +43,71 @@ int main(int argc, char *argv[])
 
     /* Initialize..*/
     glyr_init();
-    glyr_query_init(&query);
+    glyr_query_init (&query);
 
     /* Create a new database in the /tmp folder
      * A new file called 'metadata.db' will pop
      * up there. (GLYR_DB_FILENAME expands to 'metadata.db')
      */
-    db = glyr_db_init("/tmp/");
+    db = glyr_db_init ("/tmp/");
 
     /* Set some random settings */
-    glyr_opt_verbosity(&query, 2);
-    glyr_opt_artist(&query, "Equilibrium");
-    glyr_opt_album(&query, "Sagas");
-    glyr_opt_title(&query, "Blut im Auge");
-    glyr_opt_type(&query, GLYR_GET_LYRICS);
+    glyr_opt_verbosity (&query,2);
+    glyr_opt_artist (&query,"Equilibrium");
+    glyr_opt_album (&query,"Sagas");
+    glyr_opt_title (&query,"Blut im Auge");
+    glyr_opt_type (&query,GLYR_GET_LYRICS);
 
     /* Tell libglyr to automatically lookup before searching the web */
-    glyr_opt_lookup_db(&query, db);
+    glyr_opt_lookup_db (&query, db);
 
     /* Also tell it to write newly found items to the db */
-    glyr_opt_db_autowrite(&query, TRUE);
+    glyr_opt_db_autowrite (&query, TRUE);
 
-    list = glyr_get(&query, &get_error, &length);
-    if(list != NULL) {
-        for(GlyrMemCache *cache = list; cache != NULL; cache = cache->next) {
+    list = glyr_get (&query, &get_error, &length);
+    if (list != NULL)
+    {
+        for (GlyrMemCache *cache=list; cache!=NULL; cache=cache->next)
+        {
             /* Copy a cache and modify it somehow */
-            if(cache->cached) {
-                GlyrMemCache *new = glyr_cache_copy(cache);
-                glyr_cache_set_data(new, g_strdup("edited\n"), -1);
+            if (cache->cached)
+            {
+                GlyrMemCache *new = glyr_cache_copy (cache);
+                glyr_cache_set_data (new,g_strdup ("edited\n"), -1);
 
                 bool which_edit = false;
-                if(which_edit == false) {
+                if (which_edit == false)
+                {
                     /* There are two way to edit it..
                      * One is to delete all caches according to query, and replace it
                      * by something else.
                      */
-                    glyr_db_edit(db, &query, new);
-                } else {
+                    glyr_db_edit (db, &query, new);
+                }
+                else
+                {
                     /* ..or find a cache via it's md5sum and replace it.
                      * You may choose one of them.
                      */
-                    glyr_db_replace(db, cache->md5sum, &query, new);
+                    glyr_db_replace (db, cache->md5sum, &query, new);
                 }
-                glyr_cache_free(new);
+                glyr_cache_free (new);
             }
 
             /* Print a nice representation */
-            glyr_cache_print(cache);
+            glyr_cache_print (cache);
 
             /* Now delete it if it was 'edited' */
-            if(cache->cached && strcmp(cache->data, "edited\n") == 0) {
-                glyr_db_delete(db, &query);
+            if (cache->cached && strcmp (cache->data,"edited\n") == 0)
+            {
+                glyr_db_delete (db, &query);
             }
         }
     }
 
     /* Cleanup */
-    glyr_free_list(list);
-    glyr_query_destroy(&query);
-    glyr_db_destroy(db);
+    glyr_free_list (list);
+    glyr_query_destroy (&query);
+    glyr_db_destroy (db);
     glyr_cleanup();
 }
diff --git a/src/examples/dbtest.c b/src/examples/dbtest.c
index 5b24523..5a6b6fe 100644
--- a/src/examples/dbtest.c
+++ b/src/examples/dbtest.c
@@ -3,51 +3,51 @@
 #include <glib.h>
 #include <stdlib.h>
 
-void do_insert(GlyrQuery *q, GlyrDatabase *db, char *artist, char *album)
+void do_insert (GlyrQuery * q, GlyrDatabase * db, char * artist, char * album)
 {
-    glyr_query_init(q);
-    glyr_opt_artist(q, artist);
-    glyr_opt_album(q, album);
-    glyr_opt_type(q, GLYR_GET_COVERART);
+    glyr_query_init (q);
+    glyr_opt_artist (q,artist);
+    glyr_opt_album (q,album);
+    glyr_opt_type (q,GLYR_GET_COVERART);
 
-    GlyrMemCache *c = glyr_cache_new();
-    glyr_cache_set_data(c, g_strdup("Dummy"), -1);
+    GlyrMemCache * c = glyr_cache_new();
+    glyr_cache_set_data (c,g_strdup ("Dummy"),-1);
     c->rating = -1;
     //    c->dsrc = g_strdup("Hello World"); // Argh.
 
-    glyr_db_insert(db, q, c);
-    glyr_cache_free(c);
+    glyr_db_insert (db,q,c);
+    glyr_cache_free (c);
 }
 
-void do_lookup(GlyrQuery *q, GlyrDatabase *db)
+void do_lookup (GlyrQuery * q, GlyrDatabase * db)
 {
-    GlyrMemCache *c = glyr_db_lookup(db, q);
-    g_assert(c);
-    glyr_cache_print(c);
-    g_assert(c->rating == -1);
-    glyr_cache_free(c);
+    GlyrMemCache * c = glyr_db_lookup (db,q);
+    g_assert (c);
+    glyr_cache_print (c);
+    g_assert (c->rating == -1);
+    glyr_cache_free (c);
 }
 
 
-int main(int argc, char const *argv[])
+int main (int argc, char const *argv[])
 {
-    system("rm /home/chris/metadata.db");
+    system ("rm /home/chris/metadata.db");
     glyr_init();
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 
-    GlyrDatabase *db = glyr_db_init("/home/chris");
-    g_assert(db);
+    GlyrDatabase * db = glyr_db_init ("/home/chris");
+    g_assert (db);
 
-    GlyrQuery q1, q2;
+    GlyrQuery q1,q2;
 
-    do_insert(&q1, db, "Equilibrium", "Sagas");
-    do_insert(&q2, db, "Letzte Instanz", "Kalter Glanz");
+    do_insert (&q1,db,"Equilibrium","Sagas");
+    do_insert (&q2,db,"Letzte Instanz","Kalter Glanz");
 
-    do_lookup(&q1, db);
-    do_lookup(&q2, db);
+    do_lookup (&q1,db);
+    do_lookup (&q2,db);
 
-    glyr_query_destroy(&q1);
-    glyr_query_destroy(&q2);
-    glyr_db_destroy(db);
+    glyr_query_destroy (&q1);
+    glyr_query_destroy (&q2);
+    glyr_db_destroy (db);
     return EXIT_SUCCESS;
 }
diff --git a/src/examples/example.c b/src/examples/example.c
index 2424b4e..a92853b 100644
--- a/src/examples/example.c
+++ b/src/examples/example.c
@@ -35,27 +35,28 @@
 #include "../../lib/glyr.h"
 
 
-static void print_item(GlyrMemCache *cacheditem, int num)
+static void print_item (GlyrMemCache * cacheditem, int num)
 {
-    fprintf(stderr, "\n------- ITEM #%d --------\n", num);
-    glyr_cache_print(cacheditem);
-    fprintf(stderr, "\n------------------------\n");
+    fprintf (stderr,"\n------- ITEM #%d --------\n",num);
+    glyr_cache_print (cacheditem);
+    fprintf (stderr,"\n------------------------\n");
 }
 
 /////////////////////////////////
 
 /* This is called whenever glyr gets a ready to use item */
-static GLYR_ERROR funny_callback(GlyrMemCache *c, GlyrQuery *q)
+static GLYR_ERROR funny_callback (GlyrMemCache * c, GlyrQuery * q)
 {
     /* You can pass a void pointer to the callback,
      * by passing it as third argument to glyr_opt_dlcallback()
      */
-    int *i = q->callback.user_pointer;
+    int * i = q->callback.user_pointer;
 
-    if(*i == 1) {
-        puts("=> Gentlemen, we received an item.");
-        puts("=> We originally wanted more, but we decide to stop here.");
-        puts("=> Therefore we return GLYRE_STOP_PRE. Goodbye.");
+    if (*i == 1)
+    {
+        puts ("=> Gentlemen, we received an item.");
+        puts ("=> We originally wanted more, but we decide to stop here.");
+        puts ("=> Therefore we return GLYRE_STOP_PRE. Goodbye.");
         return GLYRE_STOP_PRE;
         /*
          * You can also return:
@@ -70,62 +71,63 @@ static GLYR_ERROR funny_callback(GlyrMemCache *c, GlyrQuery *q)
 
 /////////////////////////////////
 
-int main(int argc, char *argv[])
+int main (int argc, char * argv[])
 {
     /* You need to call this before anything happens */
     glyr_init();
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 
     /* Initialize a new query (this may allocate memory) */
     GlyrQuery q;
-    glyr_query_init(&q);
+    glyr_query_init (&q);
 
     /* Say we want a Songtext */
     GLYR_GET_TYPE type = GLYR_GET_LYRICS;
-    glyr_opt_type(&q, type);
+    glyr_opt_type (&q,type);
 
     /* Set at least the required fields to your needs        *
      * For lyrics those are 'artist' and 'title', ('album')  *
      * is strictly optional and may be used by a few plugins */
-    glyr_opt_artist(&q, (char *) "Die Apokalyptischen Reiter");
-    glyr_opt_album(&q, (char *) "Riders on the Storm");
-    glyr_opt_title(&q, (char *) "Friede sei mit dir");
+    glyr_opt_artist (&q, (char*) "Die Apokalyptischen Reiter");
+    glyr_opt_album (&q, (char*) "Riders on the Storm");
+    glyr_opt_title (&q, (char*) "Friede sei mit dir");
 
     /* Execute a func when getting one item */
     int this_be_my_counter = 0;
-    glyr_opt_dlcallback(&q, funny_callback, &this_be_my_counter);
+    glyr_opt_dlcallback (&q,funny_callback,&this_be_my_counter);
 
     /* For the start: Enable verbosity */
-    glyr_opt_verbosity(&q, 2);
+    glyr_opt_verbosity (&q,2);
 
     /* Download 5 (or less) items */
-    glyr_opt_number(&q, 5);
+    glyr_opt_number (&q,5);
 
     /* Just search, without downloading items */
-    glyr_opt_download(&q, 0);
+    glyr_opt_download (&q,0);
 
     /* Call the most important command: GET!
      * This returned a list of (GlyrMemCache *)s
      * Each containing ONE item. (i.e. a songtext)
      */
     GLYR_ERROR err;
-    GlyrMemCache *it = glyr_get(&q, &err, NULL);
+    GlyrMemCache * it = glyr_get (&q,&err,NULL);
 
-    if(err != GLYRE_OK) {
-        fprintf(stderr, "E:%s\n", glyr_strerror(err));
-    }
+    if (err != GLYRE_OK)
+        fprintf (stderr,"E:%s\n",glyr_strerror (err) );
 
     /* Now iterate through it... */
-    if(it != NULL) {
-        GlyrMemCache *start = it;
+    if (it != NULL)
+    {
+        GlyrMemCache * start = it;
 
         int counter = 0;
-        while(it != NULL) {
+        while (it != NULL)
+        {
             /* This has the same effect as in the callback,
              * Just that it's executed just once after all DL is done.
              * Commented out, as this would print it twice
              * */
-            print_item(it, counter);
+            print_item (it,counter);
 
             /* Every cache has a link to the next and prev one (or NULL respectively) */
             it = it->next;
@@ -134,10 +136,10 @@ int main(int argc, char *argv[])
 
         /* The contents of it are dynamically allocated. */
         /* So better free them if you're not keen on memoryleaks */
-        glyr_free_list(start);
+        glyr_free_list (start);
     }
     /* Destroy query (reset to default values and free dyn memory) */
     /* You could start right off to use this query in another glyr_get */
-    glyr_query_destroy(&q);
+    glyr_query_destroy (&q);
     return EXIT_SUCCESS;
 }
diff --git a/src/examples/exit_signal.c b/src/examples/exit_signal.c
index 37aab70..de71c59 100644
--- a/src/examples/exit_signal.c
+++ b/src/examples/exit_signal.c
@@ -9,51 +9,52 @@
  * Example on using the glyr_signal_exit() method.
  * -----------------------------------------------*/
 
-static GLYR_ERROR funny_callback(GlyrMemCache *c, GlyrQuery *q)
+static GLYR_ERROR funny_callback (GlyrMemCache * c, GlyrQuery * q)
 {
-    glyr_cache_print(c);
+    glyr_cache_print (c);
     return GLYRE_OK;
 }
 
-static void *killer_thread(void *arg)
+static void * killer_thread (void * arg)
 {
-    GlyrQuery *q = arg;
-    g_usleep(rand() % 10000000);
+    GlyrQuery * q = arg;
+    g_usleep (rand() % 10000000);
 
-    g_printerr("####### SENDING EXIT ######\n");
-    glyr_signal_exit(q);
+    g_printerr ("####### SENDING EXIT ######\n");
+    glyr_signal_exit (q);
     return NULL;
 }
 
-int main(int argc, const char *argv[])
+int main (int argc, const char *argv[])
 {
-    srand(time(NULL));
+    srand (time (NULL) );
     glyr_init();
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 
     GlyrQuery q;
-    glyr_query_init(&q);
+    glyr_query_init (&q);
 
-    glyr_opt_type(&q, GLYR_GET_COVERART);
-    glyr_opt_artist(&q, "Equilibrium");
-    glyr_opt_album(&q, "Sagas");
-    glyr_opt_number(&q, 42);
-    glyr_opt_verbosity(&q, 3);
-    glyr_opt_dlcallback(&q, funny_callback, NULL);
+    glyr_opt_type (&q,GLYR_GET_COVERART);
+    glyr_opt_artist (&q,"Equilibrium");
+    glyr_opt_album (&q,"Sagas");
+    glyr_opt_number (&q,42);
+    glyr_opt_verbosity (&q,3);
+    glyr_opt_dlcallback (&q,funny_callback,NULL);
 
-    g_printerr("-- Starting GET\n");
+    g_printerr ("-- Starting GET\n");
 
-    GThread *killer = g_thread_new("killer_thread", killer_thread, (gpointer) &q);
+    GThread * killer = g_thread_new("killer_thread", killer_thread, (gpointer) &q);
 
     gint len = 0;
-    GlyrMemCache *list = glyr_get(&q, NULL, &len);
-    if(list != NULL) {
-        glyr_free_list(list);
+    GlyrMemCache * list = glyr_get (&q,NULL,&len);
+    if (list != NULL)
+    {
+        glyr_free_list (list);
     }
-    glyr_query_destroy(&q);
-    g_printerr("Got %d size\n", len);
-    g_printerr("-- Ending GET\n");
-    g_thread_join(killer);
+    glyr_query_destroy (&q);
+    g_printerr ("Got %d size\n",len);
+    g_printerr ("-- Ending GET\n");
+    g_thread_join (killer);
 
     return EXIT_SUCCESS;
 }
diff --git a/src/examples/getinfo.c b/src/examples/getinfo.c
index 8271991..ea842fe 100644
--- a/src/examples/getinfo.c
+++ b/src/examples/getinfo.c
@@ -26,42 +26,45 @@
  * (This does about the same as glyrc --list)
  * -------------------------------------------------------- */
 
-int main(int argc, const char *argv[])
+int main (int argc, const char *argv[])
 {
     /* We need to init first*/
     glyr_init();
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 
-    GlyrFetcherInfo *info = glyr_info_get();
-    if(info != NULL) {
+    GlyrFetcherInfo * info = glyr_info_get();
+    if (info != NULL)
+    {
         /* Iterate over all getters */
-        for(GlyrFetcherInfo *elem0 = info; elem0; elem0 = elem0->next) {
+        for (GlyrFetcherInfo * elem0 = info; elem0; elem0 = elem0->next)
+        {
             /* Iterate over all providers */
-            g_print(" %s => %d\n", elem0->name, elem0->type);
-            for(GlyrSourceInfo *elem1 = elem0->head; elem1; elem1 = elem1->next) {
-                g_print("   # %s [%c]\n", elem1->name, elem1->key);
-                g_print("     - Quality: %d\n", elem1->quality);
-                g_print("     - Speed:   %d\n", elem1->speed);
-                g_print("     - Type:    %d\n", elem1->type);
+            g_print (" %s => %d\n",elem0->name,elem0->type);
+            for (GlyrSourceInfo * elem1 = elem0->head; elem1; elem1 = elem1->next)
+            {
+                g_print ("   # %s [%c]\n",elem1->name,elem1->key);
+                g_print ("     - Quality: %d\n",elem1->quality);
+                g_print ("     - Speed:   %d\n",elem1->speed);
+                g_print ("     - Type:    %d\n",elem1->type);
             }
 
             /* Test which fields are required for a certain getter */
-            g_print(" + Requires: (%s%s%s)\n",
-                    elem0->reqs & GLYR_REQUIRES_ARTIST ? "Artist " : "",
-                    elem0->reqs & GLYR_REQUIRES_ALBUM  ? "Album "  : "",
-                    elem0->reqs & GLYR_REQUIRES_TITLE  ? "Title"   : ""
-                   );
+            g_print (" + Requires: (%s%s%s)\n",
+                     elem0->reqs & GLYR_REQUIRES_ARTIST ? "Artist " : "",
+                     elem0->reqs & GLYR_REQUIRES_ALBUM  ? "Album "  : "",
+                     elem0->reqs & GLYR_REQUIRES_TITLE  ? "Title"   : ""
+                    );
 
             /* And which are optional? */
-            g_print(" + Optional: (%s%s%s)\n",
-                    elem0->reqs & GLYR_OPTIONAL_ARTIST ? "Artist " : "",
-                    elem0->reqs & GLYR_OPTIONAL_ALBUM  ? "Album "  : "",
-                    elem0->reqs & GLYR_OPTIONAL_TITLE  ? "Title"   : ""
-                   );
+            g_print (" + Optional: (%s%s%s)\n",
+                     elem0->reqs & GLYR_OPTIONAL_ARTIST ? "Artist " : "",
+                     elem0->reqs & GLYR_OPTIONAL_ALBUM  ? "Album "  : "",
+                     elem0->reqs & GLYR_OPTIONAL_TITLE  ? "Title"   : ""
+                    );
 
-            g_print("\n///////////////////////////////\n");
+            g_print ("\n///////////////////////////////\n");
         }
     }
-    glyr_info_free(info);
+    glyr_info_free (info);
     return EXIT_SUCCESS;
 }
diff --git a/src/examples/musictree.c b/src/examples/musictree.c
index 44323a3..c24a9d7 100644
--- a/src/examples/musictree.c
+++ b/src/examples/musictree.c
@@ -15,29 +15,30 @@
  * to enable it.
  * -------------------------------------------------- */
 
-static void configure(GlyrQuery *s)
+static void configure (GlyrQuery * s)
 {
-    glyr_query_init(s);
-    glyr_opt_artist(s, "Die Apokalyptischen Reiter");
-    glyr_opt_album(s, "Moral & Wahnsinn");
-    glyr_opt_title(s, "Die Boten");
-    glyr_opt_verbosity(s, 2);
-    glyr_opt_type(s, GLYR_GET_COVERART);
+    glyr_query_init (s);
+    glyr_opt_artist (s,"Die Apokalyptischen Reiter");
+    glyr_opt_album (s,"Moral & Wahnsinn");
+    glyr_opt_title (s,"Die Boten");
+    glyr_opt_verbosity (s,2);
+    glyr_opt_type (s,GLYR_GET_COVERART);
 }
 
-static void printme(GlyrMemCache *start)
+static void printme (GlyrMemCache * start)
 {
-    GlyrMemCache *i = start;
-    while(i != NULL) {
-        glyr_cache_print(i);
-        puts("--------------------");
+    GlyrMemCache * i = start;
+    while (i != NULL)
+    {
+        glyr_cache_print (i);
+        puts ("--------------------");
         i = i->next;
     }
-    glyr_free_list(start);
+    glyr_free_list (start);
 }
 
 /* Dummy - you will have to replace this yourself */
-static gchar *get_music_file_path(void)
+static gchar * get_music_file_path (void)
 {
     /* Relative directories are possible - but should be avoided
      * Instead the file you could also just pass the containing
@@ -46,31 +47,31 @@ static gchar *get_music_file_path(void)
     return "src/examples/musictree_dir/artist/album/file.mp3";
 }
 
-int main(void)
+int main (void)
 {
     /* Init */
     glyr_init();
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 
     /* Fill some silly values */
     GlyrQuery query;
 
     /* Regular stuff */
-    configure(&query);
+    configure (&query);
 
     /* Musictree relevant */
 
     /* Please refer to the documentation here */
-    glyr_opt_musictree_path(&query, get_music_file_path());
+    glyr_opt_musictree_path (&query,get_music_file_path() );
 
     /* We only want musictree */
-    glyr_opt_from(&query, "musictree");
+    glyr_opt_from (&query,"musictree");
 
     /* Try to get 4 covers - you will get just 2 */
-    glyr_opt_number(&query, 4);
+    glyr_opt_number (&query,4);
 
-    GlyrMemCache *cache = glyr_get(&query, NULL, NULL);
-    printme(cache);
+    GlyrMemCache * cache = glyr_get (&query,NULL,NULL);
+    printme (cache);
 
     return EXIT_SUCCESS;
 }
diff --git a/src/examples/rating.c b/src/examples/rating.c
index 99fb4d1..5bc7998 100644
--- a/src/examples/rating.c
+++ b/src/examples/rating.c
@@ -37,51 +37,56 @@
  * 4) 'rm /tmp/metadata.db' to start again.
  */
 
-int main(int argc, const char *argv[])
+int main (int argc, const char *argv[])
 {
-    int amount_to_get = (argc > 1) ? strtol(argv[1], NULL, 10) : 3;
+    int amount_to_get = (argc > 1) ? strtol (argv[1],NULL,10) : 3;
     GLYR_ERROR err;
 
     glyr_init();
-    atexit(glyr_cleanup);
-    srand(time(NULL));
+    atexit (glyr_cleanup);
+    srand (time (NULL) );
 
-    GlyrDatabase *db = glyr_db_init("/tmp");
-    if(db != NULL) {
+    GlyrDatabase * db = glyr_db_init ("/tmp");
+    if (db != NULL)
+    {
         GlyrQuery q;
-        glyr_query_init(&q);
-        glyr_opt_artist(&q, "Die Apokalyptischen Reiter");
-        glyr_opt_type(&q, GLYR_GET_ARTIST_PHOTOS);
-        glyr_opt_download(&q, false);
-        glyr_opt_number(&q, amount_to_get);
+        glyr_query_init (&q);
+        glyr_opt_artist (&q,"Die Apokalyptischen Reiter");
+        glyr_opt_type (&q,GLYR_GET_ARTIST_PHOTOS);
+        glyr_opt_download (&q,false);
+        glyr_opt_number (&q,amount_to_get);
 
-        glyr_opt_lookup_db(&q, db);
+        glyr_opt_lookup_db (&q,db);
 
         /* Say, we want to manage the writing part ourself */
-        glyr_opt_db_autowrite(&q, false);
+        glyr_opt_db_autowrite (&q,false);
 
         /* Now either get me some from the web or the db */
-        GlyrMemCache *list = glyr_get(&q, &err, NULL);
-        if(err != GLYRE_OK) {
-            fprintf(stderr, "Error occured: %s\n", glyr_strerror(err));
+        GlyrMemCache * list = glyr_get (&q,&err,NULL);
+        if (err != GLYRE_OK)
+        {
+            fprintf (stderr,"Error occured: %s\n",glyr_strerror (err) );
         }
 
-        if(list != NULL) {
-            for(GlyrMemCache *cache = list; cache; cache = cache->next) {
-                puts("-----------------");
-                glyr_cache_print(cache);
-                puts("-----------------");
+        if (list != NULL)
+        {
+            for (GlyrMemCache * cache = list; cache; cache = cache->next)
+            {
+                puts ("-----------------");
+                glyr_cache_print (cache);
+                puts ("-----------------");
 
                 /* Give it some rating if not already cached */
-                if(cache->cached == false) {
+                if (cache->cached == false)
+                {
                     cache->rating = rand() % 100;
-                    glyr_db_insert(db, &q, cache);
+                    glyr_db_insert (db,&q,cache);
                 }
             }
-            glyr_free_list(list);
+            glyr_free_list (list);
         }
-        glyr_query_destroy(&q);
-        glyr_db_destroy(db);
+        glyr_query_destroy (&q);
+        glyr_db_destroy (db);
     }
     return EXIT_SUCCESS;
 }
diff --git a/src/examples/simple.c b/src/examples/simple.c
index 827463e..be65563 100644
--- a/src/examples/simple.c
+++ b/src/examples/simple.c
@@ -28,45 +28,46 @@
 /* use this include path for your project, or directly clone libglyr to your project */
 //#include <glyr/glyr.h>
 
-int main(void)
+int main (void)
 {
     /* Init this thing, the only two methods not being threadsafe */
     glyr_init();
     /* Also clear ressources on exit */
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 
     /* This struct is used to store all settings you do via glyr_opt_* */
     GlyrQuery q;
     /* We also should set it to standard values */
-    glyr_query_init(&q);
+    glyr_query_init (&q);
 
     /* We want lyrics, well, I want. */
-    glyr_opt_type(&q, GLYR_GET_LYRICS);
+    glyr_opt_type (&q,GLYR_GET_LYRICS);
 
     /* Set random artist/title -  you could also omit the album line */
-    glyr_opt_artist(&q, (char *) "Die rzte");
-    glyr_opt_album(&q, (char *) "Die Bestie in Menschengestalt");
-    glyr_opt_title(&q, (char *) "FaFaFa");
+    glyr_opt_artist (&q, (char*) "Die rzte");
+    glyr_opt_album (&q, (char*) "Die Bestie in Menschengestalt");
+    glyr_opt_title (&q, (char*) "FaFaFa");
 
     /* If any error occured it will be saved here, or GLYRE_OK */
     /* You could have also passed a NULL pointer to glyr_get() if you're not interested in this */
     GLYR_ERROR err;
 
     /* Now get the job done! The 3rd  */
-    GlyrMemCache *head = glyr_get(&q, &err, NULL);
+    GlyrMemCache * head = glyr_get (&q,&err,NULL);
 
     /* The results are stored in the GlyrMemCache struct -
        you are most likely only interested in the fields data, size and type*/
-    if(head != NULL) {
+    if (head != NULL)
+    {
         /* head contains also a pointer to the next element, you can use it therefore as linkedlist */
         //        puts(head->data);
-        glyr_cache_print(head);
+        glyr_cache_print (head);
 
         /* We have to free it again also, you can pass ANY pointer of the list, it works in both directions */
-        glyr_free_list(head);
+        glyr_free_list (head);
     }
 
     /* glyr_query_init  may allocate memory - free it. */
-    glyr_query_destroy(&q);
+    glyr_query_destroy (&q);
     return err;
 }
diff --git a/src/examples/threads.c b/src/examples/threads.c
index dcce0e4..799b3db 100644
--- a/src/examples/threads.c
+++ b/src/examples/threads.c
@@ -30,70 +30,72 @@
  * libglyr is fully thread-compatible as long every thread uses it's own query.
 */
 
-static void *call_get(void *p)
+static void * call_get (void * p)
 {
-    GlyrMemCache *r = glyr_get(p, NULL, NULL);
-    puts("Thread finished");
+    GlyrMemCache * r = glyr_get (p,NULL,NULL);
+    puts ("Thread finished");
     return r;
 }
 
-static void configure(GlyrQuery *s, GLYR_GET_TYPE type)
+static void configure (GlyrQuery * s, GLYR_GET_TYPE type)
 {
-    glyr_query_init(s);
-    glyr_opt_artist(s, "Die Apokalyptischen Reiter");
-    glyr_opt_album(s, "Moral & Wahnsinn");
-    glyr_opt_title(s, "Die Boten");
-    glyr_opt_verbosity(s, 1);
-    glyr_opt_type(s, type);
-    glyr_opt_from(s, NULL);
+    glyr_query_init (s);
+    glyr_opt_artist (s,"Die Apokalyptischen Reiter");
+    glyr_opt_album (s,"Moral & Wahnsinn");
+    glyr_opt_title (s,"Die Boten");
+    glyr_opt_verbosity (s,1);
+    glyr_opt_type  (s,type);
+    glyr_opt_from (s,NULL);
 }
 
-static void printme(GlyrMemCache *start)
+static void printme (GlyrMemCache * start)
 {
-    GlyrMemCache *i = start;
-    while(i != NULL) {
-        glyr_cache_write(i, "stdout");
+    GlyrMemCache * i = start;
+    while (i != NULL)
+    {
+        glyr_cache_write (i,"stdout");
         i = i->next;
     }
-    glyr_free_list(start);
+    glyr_free_list (start);
 }
 
-int main(void)
+int main (void)
 {
     /* Init */
     glyr_init();
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 
     /* Fill some silly values */
     GlyrQuery query_long, query_longer;
-    configure(&query_long, GLYR_GET_SIMILAR_ARTISTS);
-    configure(&query_longer, GLYR_GET_LYRICS);
+    configure (&query_long,GLYR_GET_SIMILAR_ARTISTS);
+    configure (&query_longer,GLYR_GET_LYRICS);
 
-    GlyrDatabase *db = glyr_db_init("/tmp");
-    glyr_opt_lookup_db(&query_long, db);
-    glyr_opt_lookup_db(&query_longer, db);
+    GlyrDatabase * db = glyr_db_init ("/tmp");
+    glyr_opt_lookup_db (&query_long,db);
+    glyr_opt_lookup_db (&query_longer,db);
 
-    GlyrMemCache *a, * b;
+    GlyrMemCache * a, * b;
 
     /* Create two threads */
-    GThread *thread_a = g_thread_new("call_get", call_get, (gpointer) &query_long);
-    GThread *thread_b = g_thread_new("call_get", call_get, (gpointer) &query_longer);
+    GThread * thread_a = g_thread_new ("call_get", call_get, (gpointer) &query_long);
+    GThread * thread_b = g_thread_new ("call_get", call_get, (gpointer) &query_longer);
 
-    puts("Running!");
+    puts ("Running!");
 
     /* Wait for threads to join, get results */
-    a = g_thread_join(thread_a);
-    b = g_thread_join(thread_b);
+    a = g_thread_join (thread_a);
+    b = g_thread_join (thread_b);
 
-    puts("Joined!\n---> Data: ");
+    puts ("Joined!\n---> Data: ");
 
-    if(a && b) {
-        printme(a);
-        puts("-------------");
-        printme(b);
+    if (a && b)
+    {
+        printme (a);
+        puts ("-------------");
+        printme (b);
     }
 
-    glyr_query_destroy(&query_long);
-    glyr_query_destroy(&query_longer);
+    glyr_query_destroy (&query_long);
+    glyr_query_destroy (&query_longer);
     return EXIT_SUCCESS;
 }
diff --git a/src/glyrc/autohelp.c b/src/glyrc/autohelp.c
index a93bc0f..2f2bdc9 100644
--- a/src/glyrc/autohelp.c
+++ b/src/glyrc/autohelp.c
@@ -25,72 +25,85 @@
 
 #include "colorprint.h"
 
-void suggest_other_getter(GlyrQuery *query, const char *wrong_input)
+void suggest_other_getter (GlyrQuery * query, const char * wrong_input)
 {
-    if(query->verbosity <= 0) {
+    if (query->verbosity <= 0)
+    {
         return;
     }
 
-    GlyrFetcherInfo *fetcher = glyr_info_get();
-    if(fetcher != NULL) {
+    GlyrFetcherInfo * fetcher = glyr_info_get();
+    if (fetcher != NULL)
+    {
         gboolean did_you_mean_printed = FALSE;
-        GlyrFetcherInfo *it = fetcher;
-        while(it != NULL) {
-            if(glyr_levenshtein_strnormcmp(wrong_input, it->name) < 7) {
-                if(did_you_mean_printed == FALSE) {
-                    cvprint(DEFAULT, "\nDid you mean this?\n");
+        GlyrFetcherInfo * it = fetcher;
+        while (it != NULL)
+        {
+            if (glyr_levenshtein_strnormcmp (wrong_input,it->name) < 7)
+            {
+                if (did_you_mean_printed == FALSE)
+                {
+                    cvprint (DEFAULT,"\nDid you mean this?\n");
                     did_you_mean_printed = TRUE;
                 }
-                cvprint(GREEN, "  * %s\n", it->name);
+                cvprint (GREEN,"  * %s\n",it->name);
             }
             it = it->next;
         }
-        glyr_info_free(fetcher);
+        glyr_info_free (fetcher);
     }
 }
 
 /////////////////////////////////
 
-void suggest_other_provider(GlyrQuery *query, const char *wrong_input)
+void suggest_other_provider (GlyrQuery * query, const char * wrong_input)
 {
-    if(query->verbosity <= 0) {
+    if (query->verbosity <= 0)
+    {
         return;
     }
 
-    GlyrFetcherInfo *fetcher = glyr_info_get();
-    GlyrFetcherInfo *it = fetcher;
-    while(it != NULL) {
-        if(it->type == query->type) {
+    GlyrFetcherInfo * fetcher = glyr_info_get();
+    GlyrFetcherInfo * it = fetcher;
+    while (it != NULL)
+    {
+        if (it->type == query->type)
+        {
             break;
         }
 
         it = it->next;
     }
 
-    if(it != NULL && wrong_input) {
+    if (it != NULL && wrong_input)
+    {
         gboolean did_you_mean_printed = FALSE;
-        GlyrSourceInfo *head = it->head;
-        GHashTable *key_table = g_hash_table_new(g_direct_hash, g_direct_equal);
-        while(head != NULL) {
-            gchar **tokens = g_strsplit(wrong_input, GLYR_DEFAULT_FROM_ARGUMENT_DELIM, 0);
-            for(int i = 0; tokens[i] != NULL; i++) {
-                gchar *token = tokens[i];
-                if(glyr_levenshtein_strnormcmp(token, head->name) < 5 &&
-                        g_hash_table_lookup(key_table, head->name) == NULL) {
-                    if(did_you_mean_printed == FALSE) {
-                        cvprint(DEFAULT, "\nI would suggest the following similar providers:\n");
+        GlyrSourceInfo * head = it->head;
+        GHashTable * key_table = g_hash_table_new (g_direct_hash,g_direct_equal);
+        while (head != NULL)
+        {
+            gchar ** tokens = g_strsplit (wrong_input,GLYR_DEFAULT_FROM_ARGUMENT_DELIM,0);
+            for (int i = 0; tokens[i] != NULL; i++)
+            {
+                gchar * token = tokens[i];
+                if (glyr_levenshtein_strnormcmp (token,head->name) < 5 &&
+                        g_hash_table_lookup (key_table,head->name) == NULL)
+                {
+                    if (did_you_mean_printed == FALSE)
+                    {
+                        cvprint (DEFAULT,"\nI would suggest the following similar providers:\n");
                         did_you_mean_printed = TRUE;
                     }
-                    cvprint(GREEN, "  * %s\n", head->name);
-                    g_hash_table_insert(key_table, head->name, head);
+                    cvprint (GREEN,"  * %s\n",head->name);
+                    g_hash_table_insert (key_table,head->name,head);
                 }
             }
             head = head->next;
-            g_strfreev(tokens);
+            g_strfreev (tokens);
         }
-        g_hash_table_destroy(key_table);
+        g_hash_table_destroy (key_table);
     }
-    glyr_info_free(fetcher);
+    glyr_info_free (fetcher);
 }
 
 /////////////////////////////////
diff --git a/src/glyrc/colorprint.c b/src/glyrc/colorprint.c
index 9b5b1a1..004618d 100644
--- a/src/glyrc/colorprint.c
+++ b/src/glyrc/colorprint.c
@@ -30,33 +30,32 @@ static bool global_enable_color = true;
 
 /////////////////////////////
 
-static void printcol(FILE *stream, termcolor fg)
+static void printcol (FILE * stream, termcolor fg)
 {
-    fprintf(stream, "%c[0;%dm", 0x1B, fg + 30);
+    fprintf (stream,"%c[0;%dm", 0x1B, fg + 30);
 }
 
 /////////////////////////////
 
-static void resetcolor(FILE *stream)
+static void resetcolor (FILE * stream)
 {
-    fprintf(stream, "%c[0m", 0x1B);
+    fprintf (stream,"%c[0m",0x1B);
 }
 
-void cprint(termcolor col, gint verbosity, GlyrQuery *s, const char *fmt, ...)
+void cprint (termcolor col,gint verbosity, GlyrQuery * s, const char * fmt, ...)
 {
-    if((s && verbosity <= s->verbosity) || verbosity == -1) {
-        if(col != DEFAULT && global_enable_color) {
-            printcol(GLYR_OUTPUT, col);
-        }
+    if ( (s && verbosity <= s->verbosity) || verbosity == -1)
+    {
+        if (col != DEFAULT && global_enable_color)
+            printcol (GLYR_OUTPUT,col);
 
         va_list param;
-        va_start(param, fmt);
-        g_logv("Glyrc", G_LOG_LEVEL_INFO, fmt, param);
-        va_end(param);
+        va_start (param,fmt);
+        g_logv ("Glyrc",G_LOG_LEVEL_INFO,fmt,param);
+        va_end (param);
 
-        if(col != DEFAULT && global_enable_color) {
-            resetcolor(GLYR_OUTPUT);
-        }
+        if (col != DEFAULT && global_enable_color)
+            resetcolor (GLYR_OUTPUT);
 
         fflush(stdout);
     }
@@ -65,11 +64,11 @@ void cprint(termcolor col, gint verbosity, GlyrQuery *s, const char *fmt, ...)
 
 /////////////////////////////
 
-void enable_color(bool enable)
+void enable_color (bool enable)
 {
     global_enable_color = enable;
 }
 
 /////////////////////////////
 
-void enable_color(bool enable);
+void enable_color (bool enable);
diff --git a/src/glyrc/escape.c b/src/glyrc/escape.c
index c02e109..dba3ccc 100644
--- a/src/glyrc/escape.c
+++ b/src/glyrc/escape.c
@@ -25,7 +25,7 @@
 #include "escape.h"
 
 static int     global_item_counter = 0;
-static char   *global_write_path   = NULL;
+static char *  global_write_path   = NULL;
 
 #define EXPAND_FUNC(NAME)    \
     static char * expand_##NAME( \
@@ -33,135 +33,141 @@ static char   *global_write_path   = NULL;
                                  GlyrMemCache * c     \
                                )
 
-EXPAND_FUNC(type)
+EXPAND_FUNC (type)
 {
-    return g_strdup(glyr_get_type_to_string(q->type));
+    return g_strdup (glyr_get_type_to_string (q->type) );
 }
 
-EXPAND_FUNC(artist)
+EXPAND_FUNC (artist)
 {
-    return g_strdup(q->artist);
+    return g_strdup (q->artist);
 }
 
-EXPAND_FUNC(album)
+EXPAND_FUNC (album)
 {
-    return g_strdup(q->album);
+    return g_strdup (q->album);
 }
 
-EXPAND_FUNC(title)
+EXPAND_FUNC (title)
 {
-    return g_strdup(q->title);
+    return g_strdup (q->title);
 }
 
-EXPAND_FUNC(size)
+EXPAND_FUNC (size)
 {
-    return g_strdup_printf("%lu", c->size);
+    return g_strdup_printf ("%lu",c->size);
 }
 
-EXPAND_FUNC(format)
+EXPAND_FUNC (format)
 {
-    return c->is_image ? g_strdup(c->img_format) : g_strdup("txt");
+    return c->is_image ? g_strdup (c->img_format) : g_strdup ("txt");
 }
 
-EXPAND_FUNC(source)
+EXPAND_FUNC (source)
 {
-    return g_strdup(c->dsrc);
+    return g_strdup (c->dsrc);
 }
 
-EXPAND_FUNC(prov)
+EXPAND_FUNC (prov)
 {
-    return g_strdup(c->prov);
+    return g_strdup (c->prov);
 }
 
-EXPAND_FUNC(cksum)
+EXPAND_FUNC (cksum)
 {
-    return glyr_md5sum_to_string(c->md5sum);
+    return glyr_md5sum_to_string (c->md5sum);
 }
 
-EXPAND_FUNC(rating)
+EXPAND_FUNC (rating)
 {
-    return g_strdup_printf("%d", c->rating);
+    return g_strdup_printf ("%d",c->rating);
 }
 
-EXPAND_FUNC(duration)
+EXPAND_FUNC (duration)
 {
-    return g_strdup_printf("%d", c->duration);
+    return g_strdup_printf ("%d",c->duration);
 }
 
-EXPAND_FUNC(number)
+EXPAND_FUNC (number)
 {
-    return g_strdup_printf("%d", global_item_counter);
+    return g_strdup_printf ("%d",global_item_counter);
 }
 
-EXPAND_FUNC(path)
+EXPAND_FUNC (path)
 {
-    return g_strdup(global_write_path);
+    return g_strdup (global_write_path);
 }
 
 ////////////////////////
 
-typedef char *(* ExpandFunction)(GlyrQuery *, GlyrMemCache *);
+typedef char * (* ExpandFunction) (GlyrQuery *,GlyrMemCache *);
 
-#define EXPAND(tname, scp) { \
+#define EXPAND(tname,escp) { \
         .name = #tname,          \
                 .func = expand_##tname,  \
                         .escape_slashes = escp   \
     }                            \
- 
-struct escape_table {
-    const char *name;
+                                       
+struct escape_table
+{
+    const char * name;
     ExpandFunction func;
     bool escape_slashes;
-} _escapes[] = {
-    EXPAND(type, false),
-    EXPAND(artist, true),
-    EXPAND(album, true),
-    EXPAND(title, true),
-    EXPAND(size, false),
-    EXPAND(format, false),
-    EXPAND(source, false),
-    EXPAND(prov, false),
-    EXPAND(cksum, false),
-    EXPAND(rating, false),
-    EXPAND(duration, false),
-    EXPAND(number, false),
-    EXPAND(path, false)
+} _escapes[] =
+{
+    EXPAND (type,false),
+    EXPAND (artist,true),
+    EXPAND (album,true),
+    EXPAND (title,true),
+    EXPAND (size,false),
+    EXPAND (format,false),
+    EXPAND (source,false),
+    EXPAND (prov,false),
+    EXPAND (cksum,false),
+    EXPAND (rating,false),
+    EXPAND (duration,false),
+    EXPAND (number,false),
+    EXPAND (path,false)
 };
 
-const size_t _escape_table_size = (sizeof(_escapes) / sizeof(struct escape_table));
+const size_t _escape_table_size = (sizeof (_escapes) /sizeof (struct escape_table) );
 
 ////////////////////////
 
-static void utf8_replace_char(char *string, char a, char b)
+static void utf8_replace_char (char * string, char a, char b)
 {
-    if(string != NULL) {
-        if(g_utf8_validate(string, -1, NULL) == false) {
+    if (string != NULL)
+    {
+        if (g_utf8_validate (string,-1,NULL) == false)
             return;
-        }
 
-        while(*string) {
-            if(*string == a) {
+        while (*string)
+        {
+            if (*string == a)
+            {
                 *string = b;
             }
-            string = g_utf8_next_char(string);
+            string = g_utf8_next_char (string);
         }
     }
 }
 
 ////////////////////////
 
-static char *lookup_escape(const char *escape, size_t escape_len, GlyrQuery *q,  GlyrMemCache *c, bool *is_valid)
+static char * lookup_escape (const char * escape, size_t escape_len, GlyrQuery * q,  GlyrMemCache * c, bool * is_valid)
 {
-    for(size_t i = 0; i < _escape_table_size; ++i) {
-        if(_escapes[i].name == NULL) {
+    for (size_t i = 0; i < _escape_table_size; ++i)
+    {
+        if (_escapes[i].name == NULL)
             continue;
-        }
 
-        if(strncmp(escape, _escapes[i].name, escape_len) == 0) {
+        if (strncmp (escape,_escapes[i].name,escape_len) == 0)
+        {
             *is_valid = true;
-            char *result = _escapes[i].func(q, c);
-            if(_escapes[i].escape_slashes) {
-                utf8_replace_char(result, '/', '|');
+            char * result = _escapes[i].func (q,c);
+            if (_escapes[i].escape_slashes)
+            {
+                utf8_replace_char (result,'/','|');
             }
             return result;
         }
@@ -172,101 +178,111 @@ static char *lookup_escape(const char *escape, size_t escape_len, GlyrQuery *q,
 
 ////////////////////////
 
-static size_t estimate_alloc_size(const char *str)
+static size_t estimate_alloc_size (const char * str)
 {
     int colons = 0, normal = 0;
-    while(*str)
-        if(*str++ == ':') {
+    while (*str)
+        if (*str++ == ':')
             colons++;
-        } else {
+        else
             normal++;
-        }
 
     return (colons / 2 + 1) * 128 + normal + 1;
 }
 
 ////////////////////////
 
-char *escape_colon_expr(const char *path, GlyrQuery *q, GlyrMemCache *c)
+char * escape_colon_expr (const char * path, GlyrQuery * q, GlyrMemCache * c)
 {
-    char *retv = NULL;
-    if(path && q && c) {
-        size_t maxbufsize = estimate_alloc_size(path);
+    char * retv = NULL;
+    if (path && q && c)
+    {
+        size_t maxbufsize = estimate_alloc_size (path);
         size_t off = 0;
         bool always_copy = false;
-        retv = g_malloc0(maxbufsize + 1);
-
-        size_t path_len = strlen(path);
-        for(size_t i = 0; i < path_len; ++i) {
-            if(always_copy == false && path[i] == ':') {
-                const char *escape_begin = &path[i + 1];
-                char *end_colon = strchr(escape_begin, ':');
-                if(end_colon != NULL) {
+        retv = g_malloc0 (maxbufsize+1);
+
+        size_t path_len = strlen (path);
+        for (size_t i = 0; i < path_len; ++i)
+        {
+            if (always_copy == false && path[i] == ':')
+            {
+                const char * escape_begin = &path[i+1];
+                char * end_colon = strchr (escape_begin,':');
+                if (end_colon != NULL)
+                {
                     bool is_valid = false;
                     size_t escape_len = end_colon - escape_begin;
-                    if(escape_len == 0) {
+                    if (escape_len == 0)
                         continue;
-                    }
 
-                    char *subsitution = lookup_escape(escape_begin, escape_len, q, c, &is_valid);
-                    if(subsitution != NULL) {
-                        size_t subs_len = strlen(subsitution);
-                        memcpy(&retv[off], subsitution, subs_len);
+                    char * subsitution = lookup_escape (escape_begin,escape_len,q,c,&is_valid);
+                    if (subsitution != NULL)
+                    {
+                        size_t subs_len = strlen (subsitution);
+                        memcpy (&retv[off],subsitution,subs_len);
                         off += subs_len;
-                        g_free(subsitution);
-                    } else if(is_valid == false) {
-                        strncpy(retv + off, &path[i], escape_len + 2);
+                        g_free (subsitution);
+                    }
+                    else if (is_valid == false)
+                    {
+                        strncpy (retv+off,&path[i],escape_len + 2);
                         off += escape_len + 2;
                     }
                     i += escape_len + 1;
-                } else {
+                }
+                else
+                {
                     always_copy = true;
                     i--;
                 }
-            } else {
+            }
+            else
+            {
                 retv[off++] = path[i];
             }
 
-            if(off >= maxbufsize) {
-                fprintf(stderr, "ERROR: Ouch! Buffersize too small. Hack: Add some :: to your string.\n");
+            if (off >= maxbufsize)
+            {
+                fprintf (stderr,"ERROR: Ouch! Buffersize too small. Hack: Add some :: to your string.\n");
                 break;
             }
         }
     }
-    if(q && q->verbosity >= 4) {
-        printf(">>> %s\n", retv);
+    if (q && q->verbosity >= 4)
+    {
+        printf (">>> %s\n",retv);
     }
     return retv;
 }
 
 ////////////////////////
 
-void increment_item_counter(void)
+void increment_item_counter (void)
 {
     ++global_item_counter;
 }
 
 ////////////////////////
 
-int get_item_counter(void)
+int get_item_counter (void)
 {
     return global_item_counter;
 }
 
 ////////////////////////
 
-char *get_write_path(void)
+char * get_write_path (void)
 {
     return global_write_path;
 }
 
 ////////////////////////
 
-void set_write_path(char *path)
+void set_write_path (char * path)
 {
-    if(global_write_path != NULL) {
-        g_free(global_write_path);
-    }
+    if (global_write_path != NULL)
+        g_free (global_write_path);
 
     global_write_path = path;
 }
diff --git a/src/glyrc/glyrc.c b/src/glyrc/glyrc.c
index 452dee5..fc84896 100644
--- a/src/glyrc/glyrc.c
+++ b/src/glyrc/glyrc.c
@@ -67,9 +67,10 @@
 ////////////////////////////////////////////////////////////////
 
 /* Shared data of main/callback */
-typedef struct {
-    char *output_path;
-    char *exec_on_call;
+typedef struct
+{
+    char * output_path;
+    char * exec_on_call;
     bool as_one;
     bool append_format;
 
@@ -84,19 +85,19 @@ typedef struct {
     .as_one       = false, \
     .append_format= false  \
 }                          \
- 
+                                                     
 //////////////////////////
 
-static GlyrQuery *glob_lastQuery = NULL;
+static GlyrQuery * glob_lastQuery = NULL;
 
 ////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////
 
-void log_func(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer user_data)
+void log_func (const gchar *log_domain,GLogLevelFlags log_level,const gchar *message, gpointer user_data)
 {
-    fputs(message, GLYR_OUTPUT);
+    fputs (message,GLYR_OUTPUT);
 }
 
 ////////////////////////////////////////////////////////////////
@@ -105,21 +106,22 @@ void log_func(const gchar *log_domain, GLogLevelFlags log_level, const gchar *me
 #define STACK_FRAME_SIZE 20
 
 /* Obtain a backtrace and print it to stdout. */
-static void print_trace(void)
+static void print_trace (void)
 {
-    void *array[STACK_FRAME_SIZE];
-    char **bt_info_list;
+    void * array[STACK_FRAME_SIZE];
+    char ** bt_info_list;
     gsize size, it = 0;
 
-    size = backtrace(array, STACK_FRAME_SIZE);
-    bt_info_list = backtrace_symbols(array, size);
+    size = backtrace (array, STACK_FRAME_SIZE);
+    bt_info_list = backtrace_symbols (array, size);
 
-    for(it = 0; it < size; it++) {
-        cvprint(DEFAULT, "    [#%02u] %s\n", (gint) it + 1, bt_info_list[it]);
+    for (it = 0; it < size; it++)
+    {
+        cvprint (DEFAULT,"    [#%02u] %s\n", (gint) it+1, bt_info_list[it]);
     }
 
-    cvprint(DEFAULT, "\n%zd calls in total are shown.\n", size);
-    g_free(bt_info_list);
+    cvprint (DEFAULT,"\n%zd calls in total are shown.\n", size);
+    g_free (bt_info_list);
 }
 #endif
 
@@ -127,68 +129,70 @@ static void print_trace(void)
 ////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////
 
-static void sig_handler(int signal)
+static void sig_handler (int signal)
 {
-    switch(signal) {
+    switch (signal)
+    {
     case SIGABRT :
     case SIGFPE  :
     case SIGSEGV : /* sigh */
-        cvprint(RED, "\nFATAL: libglyr stopped/crashed due to a %s of death.\n", g_strsignal(signal));
-        cvprint(DEFAULT, "       This is entirely the fault of the libglyr developers. Yes, we failed. Sorry. Now what to do:\n");
-        cvprint(DEFAULT, "       It would be just natural to blame us now, so just visit <https://github.com/sahib/glyr/issues>\n");
-        cvprint(DEFAULT, "       and throw hard words like 'backtrace', 'bug report' or even the '$(command I issued' at them).\n");
-        cvprint(DEFAULT, "       The libglyr developers will try to fix it as soon as possible so please stop pulling their hair.\n");
+        cvprint (RED,"\nFATAL: libglyr stopped/crashed due to a %s of death.\n",g_strsignal (signal) );
+        cvprint (DEFAULT,"       This is entirely the fault of the libglyr developers. Yes, we failed. Sorry. Now what to do:\n");
+        cvprint (DEFAULT,"       It would be just natural to blame us now, so just visit <https://github.com/sahib/glyr/issues>\n");
+        cvprint (DEFAULT,"       and throw hard words like 'backtrace', 'bug report' or even the '$(command I issued' at them).\n");
+        cvprint (DEFAULT,"       The libglyr developers will try to fix it as soon as possible so please stop pulling their hair.\n");
 #ifdef __linux__
-        cvprint(DEFAULT, "\nA list of the last called functions follows, please add this to your report:\n");
+        cvprint (DEFAULT,"\nA list of the last called functions follows, please add this to your report:\n");
         print_trace();
 #endif
-        cvprint(DEFAULT, "\n(Thanks, and Sorry for any bad feelings.)\n\n");
+        cvprint (DEFAULT,"\n(Thanks, and Sorry for any bad feelings.)\n\n");
         break;
     }
-    exit(EXIT_FAILURE);
+    exit (EXIT_FAILURE);
 }
 
 ////////////////////////////////////////////////////////////////
 
-static void init_signals(void)
+static void init_signals (void)
 {
     /* Only register for crashes */
-    signal(SIGSEGV, sig_handler);
-    signal(SIGABRT, sig_handler);
-    signal(SIGFPE,  sig_handler);
+    signal (SIGSEGV, sig_handler);
+    signal (SIGABRT, sig_handler);
+    signal (SIGFPE,  sig_handler);
 }
 
 ////////////////////////////////////////////////////////////////
 
-static void handle_cancel(int signo)
+static void handle_cancel (int signo)
 {
-    cvprint(YELLOW, "Canceling..\n");
-    if(glob_lastQuery != NULL) {
-        glyr_signal_exit(glob_lastQuery);
+    cvprint (YELLOW,"Canceling..\n");
+    if (glob_lastQuery != NULL)
+    {
+        glyr_signal_exit (glob_lastQuery);
     }
 }
 
 ////////////////////////////////////////////////////////////////
 
-static char *create_cache_directory(void)
+static char * create_cache_directory (void)
 {
-    char *xdg_cache_dir = g_strdup(g_getenv("XDG_CACHE_HOME"));
+    char * xdg_cache_dir = g_strdup(g_getenv("XDG_CACHE_HOME"));
     if(xdg_cache_dir == NULL) {
-        xdg_cache_dir = (char *) g_getenv("HOME");
+        xdg_cache_dir = (char *)g_getenv("HOME");
         if(xdg_cache_dir == NULL) {
             xdg_cache_dir = g_strdup("/tmp");
         } else {
             xdg_cache_dir = g_strdup_printf("%s%c.cache",
-                                            xdg_cache_dir,
-                                            G_DIR_SEPARATOR
-                                           );
+                xdg_cache_dir,
+                G_DIR_SEPARATOR
+            );
         }
     }
 
-    char *full_path = g_strdup_printf("%s%cglyrc",
-                                      xdg_cache_dir,
-                                      G_DIR_SEPARATOR
-                                     );
+    char * full_path = g_strdup_printf("%s%cglyrc",
+        xdg_cache_dir,
+        G_DIR_SEPARATOR
+    );
 
     if(!g_file_test(full_path, G_FILE_TEST_IS_DIR)) {
         g_printerr("<%s> does not exist yet. Creating...", full_path);
@@ -198,7 +202,7 @@ static char *create_cache_directory(void)
         } else {
             g_printerr("done.\n");
         }
-
+        
     }
 
     g_free(xdg_cache_dir);
@@ -207,26 +211,26 @@ static char *create_cache_directory(void)
 
 ////////////////////////////////////////////////////////////////
 
-static void init_cancel_handler(GlyrQuery *p_lastQuery)
+static void init_cancel_handler (GlyrQuery * p_lastQuery)
 {
     glob_lastQuery = p_lastQuery;
-    signal(SIGINT, handle_cancel);
+    signal (SIGINT, handle_cancel);
 }
 
 ////////////////////////////////////////////////////////////////
 // --------------------------------------------------------- //
 ///////////////////////////////////////////////////////////////
 
-static void print_version(GlyrQuery *s)
+static void print_version (GlyrQuery * s)
 {
-    cprint(DEFAULT, -1, s, "%s\n\n", glyr_version());
+    cprint (DEFAULT,-1,s, "%s\n\n",glyr_version() );
 
-    cprint(DEFAULT, -1, s, "libglyr is licensed under the terms of the GPLv3.\n");
-    cprint(DEFAULT, -1, s, "Please refer to the COPYING file you received with glyr.\n\n");
-    cprint(DEFAULT, -1, s, "Email bugs to <sahib@online.de> or use the bugtracker\n"
-           "at https://github.com/sahib/glyr/issues - Thank you! \n");
+    cprint (DEFAULT,-1,s, "libglyr is licensed under the terms of the GPLv3.\n");
+    cprint (DEFAULT,-1,s, "Please refer to the COPYING file you received with glyr.\n\n");
+    cprint (DEFAULT,-1,s, "Email bugs to <sahib@online.de> or use the bugtracker\n"
+            "at https://github.com/sahib/glyr/issues - Thank you! \n");
 
-    exit(0);
+    exit (0);
 }
 
 
@@ -234,150 +238,155 @@ static void print_version(GlyrQuery *s)
 // --------------------------------------------------------- //
 ////////////////////////////////////////////////////////////////
 
-void help_short(GlyrQuery *s)
+void help_short (GlyrQuery * s)
 {
-    cprint(DEFAULT, -1, s, "Usage: glyrc [GETTER] (options)\n\nwhere [GETTER] must be one of:\n");
-    GlyrFetcherInfo *info  = glyr_info_get();
-    GlyrFetcherInfo *track = info;
-    while(info != NULL) {
-        cprint(DEFAULT, -1, NULL, " - %s\n", info->name);
+    cprint (DEFAULT,-1,s,"Usage: glyrc [GETTER] (options)\n\nwhere [GETTER] must be one of:\n");
+    GlyrFetcherInfo * info  = glyr_info_get();
+    GlyrFetcherInfo * track = info;
+    while (info != NULL)
+    {
+        cprint (DEFAULT,-1,NULL," - %s\n", info->name);
         info = info->next;
     }
-    glyr_info_free(track);
+    glyr_info_free (track);
 
 #define IN "    "
-    cprint(DEFAULT, -1, s, "\nGENERAL OPTIONS:\n"
-           IN"-f --from                String: Providers from where to get metadata. Refer to glyrc --list for a full list\n"
-           IN"-n --number              Integer: Download max. <n> items. Amount of actual downloaded items may be less.\n"
-           IN"-l --lang                String: Language settings. Used by a few getters to deliever localized data. Given in ISO 639-1 codes like 'de'\n"
-           IN"-o --only-lang           Only use providers that offer language specific data, this only applies for text items.\n"
-           IN"-z --fuzzyness           Integer: Set threshold for level of Levenshtein algorithm.\n"
-           IN"-q --qsratio             Float: How to weight quality/speed; 1.0 = full quality, 0.0 = full speed.\n"
-           IN"-x --plugmax             Integer. Maximum number od download a plugin may deliever. Use to make results more vary.\n"
-           IN"-v --verbosity           Integer. Set verbosity from 0 to 4. See online-README for details.\n"
-           IN"-w --write               Path: Write metadata to the dir <d>, or filename <d>, special values stdout, stderr and null are supported\n"
-           IN"                               Certain escapes are escaped inside the filename in the form :X:, where X may be one of:\n"
-           IN"                                  * type     : The getter used in this query (e.g. cover)\n"
-           IN"                                  * artist   : Artist - as passed by -a\n"
-           IN"                                  * album    : Album  - as passed by -b\n"
-           IN"                                  * title    : Title  - as passed by -t\n"
-           IN"                                  * size     : Size in bytes\n"
-           IN"                                  * format   : The image format or 'txt' for textitems\n"
-           IN"                                  * source   : The source URL of this item\n"
-           IN"                                  * prov     : The Provider of this item\n"
-           IN"                                  * cksum    : a md5sum of the data\n"
-           IN"                                  * rating   : (Usually 0)\n"
-           IN"                                  * duration : (Only for tracks) Duration in seconds\n"
-           IN"                                  * number   : An index incremented with each item (starting with 1)\n"
-           IN"\n"
-           IN"                               The default format is ':artist:_:album:_:title:_:type:_:number:.:format:'\n"
-           IN"                               Strings containing '/' are replaced with '|' automatically,\n"
-           IN"                               so --write ':artist:' for AC/DC will result in AC|DC\n"
-           IN"\n"
-           "\nNETWORK OPTIONS\n"
-           IN"-p --parallel            Integer: Define the number of downloads that may be performed in parallel.\n"
-           IN"-u --useragent           String: The useragent to use during HTTP requests\n"
-           IN"-r --redirects           Integer. Define the number of redirects that are allowed.\n"
-           IN"-m --timeout             Integer. Define the maximum number in seconds after which a download is cancelled.\n"
-           IN"-k --proxy               String: Set the proxy to use in the form of [protocol://][user:pass@]yourproxy.domain[:port]\n"
-           "\nPROVIDER SPECIFIC OPTIONS\n"
-           IN"-d --download            Download Images.\n"
-           IN"-D --skip-download       Don't download images, but return the URLs to them (act like a search engine)\n"
-           IN"-a --artist              String: Artist name to search for\n"
-           IN"-b --album               String: Album name to search for\n"
-           IN"-t --title               String: Songname to search for\n"
-           IN"-e --maxsize             Integer: (images only) The maximum size a cover may have.\n"
-           IN"-i --minsize             Integer: (images only) The minimum size a cover may have.\n"
-           IN"-F --formats             String: A semicolon separated list of imageformats that are allowed. e.g.: \"png;jpeg\"\n"
-           IN"-8 --force-utf8          Forces utf8 encoding for text items, invalid encodings get sorted out\n"
-           "\nMISC OPTIONS\n"
-           IN"-L --list                List all fetchers and source providers for each and exit.\n"
-           IN"-h --help                This text you unlucky wanderer are viewing.\n"
-           IN"-V --version             Print the version string.\n"
-           IN"-U --update              Updates libglyr if new version is available.\n"
-           IN"-g --as-one              (Textitems only) Output all results as one (useful for tracklist and albumlist).\n"
-           IN"-G --no-as-one           Disables --as-one (Default)\n"
-           IN"-y --color               Enables colored output for glyrc (Default)\n"
-           IN"-Y --no-color            Prints no colored output\n"
-           IN"-s --musictree-path <p>  <p> is a path to your music directory. Glyr might fetch things like folger.jpg from there;\n"
-           IN"-j --callback            Command: Set a bash command to be executed when a item is finished downloading;\n"
-           IN"                                  All escapes mentioned in --write are supported too, and additonally:\n"
-           IN"                                    * path : The path were the item was written to.\n"
-           "\nDATABASE OPTIONS\n"
-           IN"-c --cache <folder>      Creates or opens an existing cache at <folder>/metadata.db and lookups data from there.\n"
-           IN"cache select [Query]     Selects data from the cache; you can use any other option behind this.\n"
-           IN"cache delete [Query]     Instead of searching for this element, the element is deleted from the database. Needs --cache.\n"
-           IN"cache list               List all items in the database (including the artist / album / title / type) - Needs --cache.\n"
-           IN"\nExamples:\n\n"
-           IN"    glyrc cover --artist SomeBand --album SomeAlbum\n"
-           IN"   \n"
-           IN"  DB:\n\n"
-           IN"    glyrc lyrics -a A -b B --cache /tmp # Write found items to cache; create it if not existant\n"
-           IN"    glyrc cache list --cache /tmp # List all in the cache\n"
-           IN"    glyrc cache delete cover -a Equilibrium -b Sagas --cache /tmp # Delete artist/album\n"
-           IN"    glyrc cache select lyrics -a Knorkator -t 'A' -n 2 --cache /tmp # Search for two items in cache and print them\n"
-           IN"\n"
-           IN"The return code will be 0 on success, 1 on any failure. No distinction is made which error happened.\n"
-           IN"\n\n"
-           "With each item received you get a link to the original source, please refer to the individual terms of use,\n"
-           "copying and distributing of this data might be not allowed.\n"
-           "A more detailed version of this help can be found online: https://github.com/sahib/glyr/wiki/Commandline-arguments\n"
-          );
-
-    cprint(DEFAULT, -1, s, "\nAUTHOR: (C) Christopher Pahl - 2011, <sahib@online.de>\n%s\n\n", glyr_version());
-    exit(EXIT_FAILURE);
+    cprint (DEFAULT,-1,s,"\nGENERAL OPTIONS:\n"
+            IN"-f --from                String: Providers from where to get metadata. Refer to glyrc --list for a full list\n"
+            IN"-n --number              Integer: Download max. <n> items. Amount of actual downloaded items may be less.\n"
+            IN"-l --lang                String: Language settings. Used by a few getters to deliever localized data. Given in ISO 639-1 codes like 'de'\n"
+            IN"-o --only-lang           Only use providers that offer language specific data, this only applies for text items.\n"
+            IN"-z --fuzzyness           Integer: Set threshold for level of Levenshtein algorithm.\n"
+            IN"-q --qsratio             Float: How to weight quality/speed; 1.0 = full quality, 0.0 = full speed.\n"
+            IN"-x --plugmax             Integer. Maximum number od download a plugin may deliever. Use to make results more vary.\n"
+            IN"-v --verbosity           Integer. Set verbosity from 0 to 4. See online-README for details.\n"
+            IN"-w --write               Path: Write metadata to the dir <d>, or filename <d>, special values stdout, stderr and null are supported\n"
+            IN"                               Certain escapes are escaped inside the filename in the form :X:, where X may be one of:\n"
+            IN"                                  * type     : The getter used in this query (e.g. cover)\n"
+            IN"                                  * artist   : Artist - as passed by -a\n"
+            IN"                                  * album    : Album  - as passed by -b\n"
+            IN"                                  * title    : Title  - as passed by -t\n"
+            IN"                                  * size     : Size in bytes\n"
+            IN"                                  * format   : The image format or 'txt' for textitems\n"
+            IN"                                  * source   : The source URL of this item\n"
+            IN"                                  * prov     : The Provider of this item\n"
+            IN"                                  * cksum    : a md5sum of the data\n"
+            IN"                                  * rating   : (Usually 0)\n"
+            IN"                                  * duration : (Only for tracks) Duration in seconds\n"
+            IN"                                  * number   : An index incremented with each item (starting with 1)\n"
+            IN"\n"
+            IN"                               The default format is ':artist:_:album:_:title:_:type:_:number:.:format:'\n"
+            IN"                               Strings containing '/' are replaced with '|' automatically,\n"
+            IN"                               so --write ':artist:' for AC/DC will result in AC|DC\n"
+            IN"\n"
+            "\nNETWORK OPTIONS\n"
+            IN"-p --parallel            Integer: Define the number of downloads that may be performed in parallel.\n"
+            IN"-u --useragent           String: The useragent to use during HTTP requests\n"
+            IN"-r --redirects           Integer. Define the number of redirects that are allowed.\n"
+            IN"-m --timeout             Integer. Define the maximum number in seconds after which a download is cancelled.\n"
+            IN"-k --proxy               String: Set the proxy to use in the form of [protocol://][user:pass@]yourproxy.domain[:port]\n"
+            "\nPROVIDER SPECIFIC OPTIONS\n"
+            IN"-d --download            Download Images.\n"
+            IN"-D --skip-download       Don't download images, but return the URLs to them (act like a search engine)\n"
+            IN"-a --artist              String: Artist name to search for\n"
+            IN"-b --album               String: Album name to search for\n"
+            IN"-t --title               String: Songname to search for\n"
+            IN"-e --maxsize             Integer: (images only) The maximum size a cover may have.\n"
+            IN"-i --minsize             Integer: (images only) The minimum size a cover may have.\n"
+            IN"-F --formats             String: A semicolon separated list of imageformats that are allowed. e.g.: \"png;jpeg\"\n"
+            IN"-8 --force-utf8          Forces utf8 encoding for text items, invalid encodings get sorted out\n"
+            "\nMISC OPTIONS\n"
+            IN"-L --list                List all fetchers and source providers for each and exit.\n"
+            IN"-h --help                This text you unlucky wanderer are viewing.\n"
+            IN"-V --version             Print the version string.\n"
+            IN"-U --update              Updates libglyr if new version is available.\n"
+            IN"-g --as-one              (Textitems only) Output all results as one (useful for tracklist and albumlist).\n"
+            IN"-G --no-as-one           Disables --as-one (Default)\n"
+            IN"-y --color               Enables colored output for glyrc (Default)\n"
+            IN"-Y --no-color            Prints no colored output\n"
+            IN"-s --musictree-path <p>  <p> is a path to your music directory. Glyr might fetch things like folger.jpg from there;\n"
+            IN"-j --callback            Command: Set a bash command to be executed when a item is finished downloading;\n"
+            IN"                                  All escapes mentioned in --write are supported too, and additonally:\n"
+            IN"                                    * path : The path were the item was written to.\n"
+            "\nDATABASE OPTIONS\n"
+            IN"-c --cache <folder>      Creates or opens an existing cache at <folder>/metadata.db and lookups data from there.\n"
+            IN"cache select [Query]     Selects data from the cache; you can use any other option behind this.\n"
+            IN"cache delete [Query]     Instead of searching for this element, the element is deleted from the database. Needs --cache.\n"
+            IN"cache list               List all items in the database (including the artist / album / title / type) - Needs --cache.\n"
+            IN"\nExamples:\n\n"
+            IN"    glyrc cover --artist SomeBand --album SomeAlbum\n"
+            IN"   \n"
+            IN"  DB:\n\n"
+            IN"    glyrc lyrics -a A -b B --cache /tmp # Write found items to cache; create it if not existant\n"
+            IN"    glyrc cache list --cache /tmp # List all in the cache\n"
+            IN"    glyrc cache delete cover -a Equilibrium -b Sagas --cache /tmp # Delete artist/album\n"
+            IN"    glyrc cache select lyrics -a Knorkator -t 'A' -n 2 --cache /tmp # Search for two items in cache and print them\n"
+            IN"\n"
+            IN"The return code will be 0 on success, 1 on any failure. No distinction is made which error happened.\n"
+            IN"\n\n"
+            "With each item received you get a link to the original source, please refer to the individual terms of use,\n"
+            "copying and distributing of this data might be not allowed.\n"
+            "A more detailed version of this help can be found online: https://github.com/sahib/glyr/wiki/Commandline-arguments\n"
+           );
+
+    cprint (DEFAULT,-1,s,"\nAUTHOR: (C) Christopher Pahl - 2011, <sahib@online.de>\n%s\n\n",glyr_version() );
+    exit (EXIT_FAILURE);
 #undef IN
 }
 
 ////////////////////////////////////////////////////////////////
 
-static void visualize_from_options(void)
+static void visualize_from_options (void)
 {
-    cprint(WHITE, -1, NULL, "# First line is the name of the fetcher you can use,\n"
-           "# Second is the providername with the shortkey in []\n"
-           "# Some unimportant information follows intented by '-'\n\n");
-
-    GlyrFetcherInfo *info = glyr_info_get();
-    if(info != NULL) {
-        for(GlyrFetcherInfo *elem0 = info; elem0; elem0 = elem0->next) {
-            cvprint(BLUE, " %s => %d\n", elem0->name, elem0->type);
-            for(GlyrSourceInfo *elem1 = elem0->head; elem1; elem1 = elem1->next) {
-                cvprint(CYAN, "   # %s [%c]\n", elem1->name, elem1->key);
-                cvprint(YELLOW, "     - Quality: %d\n", elem1->quality);
-                cvprint(YELLOW, "     - Speed:   %d\n", elem1->speed);
-                cvprint(YELLOW, "     - Type:    %s\n", glyr_get_type_to_string(elem1->type));
+    cprint (WHITE,-1,NULL,"# First line is the name of the fetcher you can use,\n"
+            "# Second is the providername with the shortkey in []\n"
+            "# Some unimportant information follows intented by '-'\n\n");
+
+    GlyrFetcherInfo * info = glyr_info_get();
+    if (info != NULL)
+    {
+        for (GlyrFetcherInfo * elem0 = info; elem0; elem0 = elem0->next)
+        {
+            cvprint (BLUE," %s => %d\n",elem0->name,elem0->type);
+            for (GlyrSourceInfo * elem1 = elem0->head; elem1; elem1 = elem1->next)
+            {
+                cvprint (CYAN,"   # %s [%c]\n",elem1->name,elem1->key);
+                cvprint (YELLOW,"     - Quality: %d\n",elem1->quality);
+                cvprint (YELLOW,"     - Speed:   %d\n",elem1->speed);
+                cvprint (YELLOW,"     - Type:    %s\n",glyr_get_type_to_string (elem1->type) );
             }
 
-            cvprint(GREEN, " + Requires: (%s%s%s)\n",
-                    elem0->reqs & GLYR_REQUIRES_ARTIST ? "Artist " : "",
-                    elem0->reqs & GLYR_REQUIRES_ALBUM  ? "Album "  : "",
-                    elem0->reqs & GLYR_REQUIRES_TITLE  ? "Title"   : ""
-                   );
-            cvprint(MAGENTA, " + Optional: (%s%s%s)\n",
-                    elem0->reqs & GLYR_OPTIONAL_ARTIST ? "Artist " : "",
-                    elem0->reqs & GLYR_OPTIONAL_ALBUM  ? "Album "  : "",
-                    elem0->reqs & GLYR_OPTIONAL_TITLE  ? "Title"   : ""
-                   );
-
-            cvprint(BLUE, "\n///////////////////////////////\n\n");
+            cvprint (GREEN," + Requires: (%s%s%s)\n",
+                     elem0->reqs & GLYR_REQUIRES_ARTIST ? "Artist " : "",
+                     elem0->reqs & GLYR_REQUIRES_ALBUM  ? "Album "  : "",
+                     elem0->reqs & GLYR_REQUIRES_TITLE  ? "Title"   : ""
+                    );
+            cvprint (MAGENTA," + Optional: (%s%s%s)\n",
+                     elem0->reqs & GLYR_OPTIONAL_ARTIST ? "Artist " : "",
+                     elem0->reqs & GLYR_OPTIONAL_ALBUM  ? "Album "  : "",
+                     elem0->reqs & GLYR_OPTIONAL_TITLE  ? "Title"   : ""
+                    );
+
+            cvprint (BLUE,"\n///////////////////////////////\n\n");
         }
 
-        cvprint(WHITE, "\nFollowing providers work with all types:\n");
-        cvprint(WHITE, "  # local     [l] (A local SQLite DB cache; see --cache)\n");
-        cvprint(WHITE, "  # musictree [t] (Gets items from your music directory (folder.jpg etc) --musictree-path)\n");
-        cvprint(WHITE, "\nThe string 'all' in --from enables all providers.\n");
-        cvprint(WHITE, "You can disable certain providers from this by prepending a '-':\n");
-        cvprint(WHITE, "  \"all;-lastfm\"\n");
-        cvprint(DEFAULT, "\n///////////////////////////////\n");
+        cvprint (WHITE,"\nFollowing providers work with all types:\n");
+        cvprint (WHITE,"  # local     [l] (A local SQLite DB cache; see --cache)\n");
+        cvprint (WHITE,"  # musictree [t] (Gets items from your music directory (folder.jpg etc) --musictree-path)\n");
+        cvprint (WHITE,"\nThe string 'all' in --from enables all providers.\n");
+        cvprint (WHITE,"You can disable certain providers from this by prepending a '-':\n");
+        cvprint (WHITE,"  \"all;-lastfm\"\n");
+        cvprint (DEFAULT,"\n///////////////////////////////\n");
     }
-    glyr_info_free(info);
+    glyr_info_free (info);
 }
 
 ////////////////////////////////////////////////////////////////
 
-static void parse_commandline_general(int argc, char *const *argv, GlyrQuery *glyrs, callback_data_t *CBData, GlyrDatabase **db)
+static void parse_commandline_general (int argc, char * const * argv, GlyrQuery * glyrs, callback_data_t * CBData, GlyrDatabase ** db)
 {
-    static struct option long_options[] = {
+    static struct option long_options[] =
+    {
         {"from",          required_argument, 0, 'f'},
         {"write",         required_argument, 0, 'w'},
         {"parallel",      required_argument, 0, 'p'},
@@ -410,134 +419,143 @@ static void parse_commandline_general(int argc, char *const *argv, GlyrQuery *gl
         {"lang",          required_argument, 0, 'l'},
         {"fuzzyness",     required_argument, 0, 'z'},
         {"callback",      required_argument, 0, 'j'},
-        {"musictree-path", required_argument, 0, 's'},
+        {"musictree-path",required_argument, 0, 's'},
         {"normalization", required_argument, 0, 'N'},
         {0,               0,                 0, '0'}
     };
 
     opterr = 0;
-    while(TRUE) {
+    while (TRUE)
+    {
         gint c;
         gint option_index = 0;
-        if((c = getopt_long(argc, argv, "N:f:W:w:p:r:m:x:u:v:q:c::F:hVodDLa:b:t:i:e:s:n:l:z:j:k:8gGyY", long_options, &option_index)) == -1) {
+        if ( (c = getopt_long (argc, argv, "N:f:W:w:p:r:m:x:u:v:q:c::F:hVodDLa:b:t:i:e:s:n:l:z:j:k:8gGyY",long_options, &option_index) ) == -1)
+        {
             break;
         }
 
-        switch(c) {
-        case 'w': {
-            char *dirname = g_path_get_dirname(optarg);
-            gsize opt_len = strlen(optarg);
-            if(g_ascii_strncasecmp(optarg, "stdout", opt_len) == 0 ||
-                    g_ascii_strncasecmp(optarg, "stderr", opt_len) == 0 ||
-                    g_ascii_strncasecmp(optarg, "null",  opt_len) == 0 ||
-                    g_file_test(dirname, G_FILE_TEST_IS_DIR | G_FILE_TEST_EXISTS) == TRUE) {
+        switch (c)
+        {
+        case 'w':
+        {
+            char * dirname = g_path_get_dirname (optarg);
+            gsize opt_len = strlen (optarg);
+            if (g_ascii_strncasecmp (optarg,"stdout",opt_len) == 0 ||
+                g_ascii_strncasecmp (optarg,"stderr",opt_len) == 0 ||
+                g_ascii_strncasecmp (optarg,"null",  opt_len) == 0 ||
+                g_file_test (dirname,G_FILE_TEST_IS_DIR | G_FILE_TEST_EXISTS) == TRUE)
+            {
                 CBData->output_path = optarg;
-                g_free(dirname);
-            } else {
-                g_free(dirname);
-                cprint(DEFAULT, -1, NULL, "'%s' does not seem to be an valid directory!\n", optarg);
-                exit(-1);
+                g_free (dirname);
+            }
+            else
+            {
+                g_free (dirname);
+                cprint (DEFAULT,-1,NULL,"'%s' does not seem to be an valid directory!\n",optarg);
+                exit (-1);
             }
             break;
         }
         case 'f':
-            glyr_opt_from(glyrs, optarg);
+            glyr_opt_from (glyrs,optarg);
             break;
         case 'v':
-            glyr_opt_verbosity(glyrs, atoi(optarg));
+            glyr_opt_verbosity (glyrs,atoi (optarg) );
             break;
         case 'p':
-            glyr_opt_parallel(glyrs, atoi(optarg));
+            glyr_opt_parallel (glyrs,atoi (optarg) );
             break;
         case 'r':
-            glyr_opt_redirects(glyrs, atoi(optarg));
+            glyr_opt_redirects (glyrs,atoi (optarg) );
             break;
         case 'm':
-            glyr_opt_timeout(glyrs, atoi(optarg));
+            glyr_opt_timeout (glyrs,atoi (optarg) );
             break;
         case 'u':
-            glyr_opt_useragent(glyrs, optarg);
+            glyr_opt_useragent (glyrs,optarg);
             break;
         case 'x':
-            glyr_opt_plugmax(glyrs, atoi(optarg));
+            glyr_opt_plugmax (glyrs,atoi (optarg) );
             break;
         case 'V':
-            print_version(glyrs);
+            print_version (glyrs);
             break;
         case 'h':
-            help_short(glyrs);
+            help_short (glyrs);
             break;
         case 'a':
-            glyr_opt_artist(glyrs, optarg);
+            glyr_opt_artist (glyrs,optarg);
             break;
         case 'b':
-            glyr_opt_album(glyrs, optarg);
+            glyr_opt_album (glyrs,optarg);
             break;
         case 't':
-            glyr_opt_title(glyrs, optarg);
+            glyr_opt_title (glyrs,optarg);
             break;
         case 'i':
-            glyr_opt_img_minsize(glyrs, atoi(optarg));
+            glyr_opt_img_minsize (glyrs,atoi (optarg) );
             break;
         case 'e':
-            glyr_opt_img_maxsize(glyrs, atoi(optarg));
+            glyr_opt_img_maxsize (glyrs,atoi (optarg) );
             break;
         case 'n':
-            glyr_opt_number(glyrs, atoi(optarg));
+            glyr_opt_number (glyrs,atoi (optarg) );
             break;
         case 'o':
-            glyr_opt_lang_aware_only(glyrs, true);
+            glyr_opt_lang_aware_only (glyrs,true);
             break;
         case 'd':
-            glyr_opt_download(glyrs, true);
+            glyr_opt_download (glyrs,true);
             break;
         case 'D':
-            glyr_opt_download(glyrs, false);
+            glyr_opt_download (glyrs,false);
             break;
-        case 'c': {
-            char *path = g_strdup(optarg);
+        case 'c':
+        {
+            char * path = g_strdup(optarg);
             if(path == NULL) {
                 path = create_cache_directory();
             }
 
-            GlyrDatabase *new_db = glyr_db_init(path);
-            if(db == NULL) {
-                cprint(DEFAULT, -1, NULL, "Unable to open or create a database at specified path.\n");
-                exit(EXIT_FAILURE);
+            GlyrDatabase * new_db = glyr_db_init (path);
+            if (db == NULL)
+            {
+                cprint (DEFAULT,-1,NULL,"Unable to open or create a database at specified path.\n");
+                exit (EXIT_FAILURE);
             }
             *db = new_db;
-            glyr_opt_db_autowrite(glyrs, TRUE);
-            glyr_opt_lookup_db(glyrs, new_db);
+            glyr_opt_db_autowrite (glyrs,TRUE);
+            glyr_opt_lookup_db (glyrs,new_db);
             g_free(path);
         }
         break;
         case 'l':
-            glyr_opt_lang(glyrs, optarg);
+            glyr_opt_lang (glyrs,optarg);
             break;
         case 'L':
             visualize_from_options();
-            exit(0);
+            exit (0);
             break;
         case 'z':
-            glyr_opt_fuzzyness(glyrs, atoi(optarg));
+            glyr_opt_fuzzyness (glyrs,atoi (optarg) );
             break;
         case 'j':
             CBData->exec_on_call = optarg;
             break;
         case 'k':
-            glyr_opt_proxy(glyrs, optarg);
+            glyr_opt_proxy (glyrs,optarg);
             break;
         case 'q':
-            glyr_opt_qsratio(glyrs, atof(optarg));
+            glyr_opt_qsratio (glyrs,atof (optarg) );
             break;
         case 'F':
-            glyr_opt_allowed_formats(glyrs, optarg);
+            glyr_opt_allowed_formats (glyrs,optarg);
             break;
         case '8':
-            glyr_opt_force_utf8(glyrs, true);
+            glyr_opt_force_utf8 (glyrs,true);
             break;
         case 's':
-            glyr_opt_musictree_path(glyrs, optarg);
+            glyr_opt_musictree_path (glyrs,optarg);
             break;
         case 'g':
             CBData->as_one = true;
@@ -546,36 +564,38 @@ static void parse_commandline_general(int argc, char *const *argv, GlyrQuery *gl
             CBData->as_one = false;
             break;
         case 'y':
-            enable_color(true);
+            enable_color (true);
             break;
         case 'Y':
-            enable_color(false);
-            break;
-        case 'N': {
-            GLYR_NORMALIZATION norm = 0;
-            if(g_ascii_strcasecmp(optarg, "aggressive") == 0) {
-                norm = GLYR_NORMALIZE_AGGRESSIVE;
-            } else if(g_ascii_strcasecmp(optarg, "moderate") == 0) {
-                norm = GLYR_NORMALIZE_MODERATE;
-            } else if(g_ascii_strcasecmp(optarg, "none") == 0) {
-                norm = GLYR_NORMALIZE_NONE;
-            } else {
-                cprint(RED, -1, NULL, "No valid normalization level: '%s'\n", optarg);
-                exit(-1);
-            }
+            enable_color (false);
+            break;
+        case 'N':
+            {
+                GLYR_NORMALIZATION norm = 0;
+                if (g_ascii_strcasecmp (optarg, "aggressive") == 0)
+                    norm = GLYR_NORMALIZE_AGGRESSIVE;
+                else if (g_ascii_strcasecmp (optarg, "moderate") == 0)
+                    norm = GLYR_NORMALIZE_MODERATE;
+                else if (g_ascii_strcasecmp (optarg, "none") == 0)
+                    norm = GLYR_NORMALIZE_NONE;
+                else 
+                {
+                    cprint (RED,-1,NULL,"No valid normalization level: '%s'\n", optarg);
+                    exit(-1);
+                }
 
-            norm |= GLYR_NORMALIZE_ALL;
+                norm |= GLYR_NORMALIZE_ALL;
 
-            glyr_opt_normalize(glyrs, norm);
-        }
-        break;
+                glyr_opt_normalize(glyrs, norm);
+            }
+            break;
         case '?':
-            cprint(RED, -1, NULL, "Option \"%s\" is not known\n", argv[optind - 1]);
-            exit(-1);
+            cprint (RED,-1,NULL,"Option \"%s\" is not known\n",argv[optind-1]);
+            exit (-1);
             break;
         default:
-            cprint(RED, -1, NULL, "Unknown Error while parsing commandline arguments.\n");
-            exit(-1);
+            cprint (RED,-1,NULL,"Unknown Error while parsing commandline arguments.\n");
+            exit (-1);
         } // end switch()
     } // end while()
 }
@@ -584,67 +604,79 @@ static void parse_commandline_general(int argc, char *const *argv, GlyrQuery *gl
 // --------------------------------------------------------- //
 ////////////////////////////////////////////////////////////////
 
-static GLYR_ERROR callback(GlyrMemCache *c, GlyrQuery *s)
+static GLYR_ERROR callback (GlyrMemCache * c, GlyrQuery * s)
 {
-    callback_data_t *CBQueryData = s->callback.user_pointer;
-    g_assert(CBQueryData);
+    callback_data_t * CBQueryData = s->callback.user_pointer;
+    g_assert (CBQueryData);
 
-    char *write_to_path = NULL;
+    char * write_to_path = NULL;
 
     increment_item_counter();
 
     /* write out 'live' */
-    if(CBQueryData->output_path != NULL) {
-        gsize write_len = strlen(CBQueryData->output_path);
-        if(g_ascii_strncasecmp(CBQueryData->output_path, "stdout", write_len) == 0 ||
-                g_ascii_strncasecmp(CBQueryData->output_path, "stderr", write_len) == 0 ||
-                g_ascii_strncasecmp(CBQueryData->output_path, "null",  write_len) == 0) {
-            glyr_cache_write(c, CBQueryData->output_path);
-        } else {
-            if(g_file_test(CBQueryData->output_path, G_FILE_TEST_IS_DIR) == TRUE) {
-                char *filename  = escape_colon_expr(":artist:_:album:_:title:_:type:_:number:.:format:", s, c);
-                char *directory = escape_colon_expr(CBQueryData->output_path, s, c);
-                write_to_path = g_strdup_printf("%s%s%s", directory,
-                                                g_str_has_suffix(directory, G_DIR_SEPARATOR_S) ? "" : G_DIR_SEPARATOR_S,
-                                                filename);
-
-                g_free(filename);
-                g_free(directory);
-            } else {
-                write_to_path = escape_colon_expr(CBQueryData->output_path, s, c);
+    if (CBQueryData->output_path != NULL)
+    {
+        gsize write_len = strlen (CBQueryData->output_path);
+        if (g_ascii_strncasecmp (CBQueryData->output_path,"stdout",write_len) == 0 ||
+            g_ascii_strncasecmp (CBQueryData->output_path,"stderr",write_len) == 0 ||
+            g_ascii_strncasecmp (CBQueryData->output_path,"null",  write_len) == 0)
+        {
+            glyr_cache_write (c,CBQueryData->output_path);
+        }
+        else
+        {
+            if (g_file_test (CBQueryData->output_path,G_FILE_TEST_IS_DIR) == TRUE)
+            {
+                char * filename  = escape_colon_expr (":artist:_:album:_:title:_:type:_:number:.:format:",s,c);
+                char * directory = escape_colon_expr (CBQueryData->output_path,s,c);
+                write_to_path = g_strdup_printf ("%s%s%s",directory,
+                                                 g_str_has_suffix (directory,G_DIR_SEPARATOR_S) ? "" : G_DIR_SEPARATOR_S,
+                                                 filename);
+
+                g_free (filename);
+                g_free (directory);
+            }
+            else
+            {
+                write_to_path = escape_colon_expr (CBQueryData->output_path,s,c);
             }
 
-            if(glyr_cache_write(c, write_to_path) == -1) {
-                cprint(RED, 1, s, "Error: Writing data to <%s> failed.\n", write_to_path);
+            if (glyr_cache_write (c,write_to_path) == -1)
+            {
+                cprint (RED,1,s,"Error: Writing data to <%s> failed.\n",write_to_path);
             }
 
-            set_write_path(write_to_path);
+            set_write_path (write_to_path);
 
             /* call a program if any specified */
-            if(CBQueryData->exec_on_call != NULL) {
-                char *command = escape_colon_expr(CBQueryData->exec_on_call, s, c);
+            if (CBQueryData->exec_on_call != NULL)
+            {
+                char * command = escape_colon_expr (CBQueryData->exec_on_call,s,c);
 
                 /* Call that command */
-                int exitVal = system(command);
-                if(exitVal != EXIT_SUCCESS) {
-                    cprint(YELLOW, 3, s, "Warning: cmd returned a value != EXIT_SUCCESS\n");
+                int exitVal = system (command);
+                if (exitVal != EXIT_SUCCESS)
+                {
+                    cprint (YELLOW,3,s,"Warning: cmd returned a value != EXIT_SUCCESS\n");
                 }
-                g_free(command);
+                g_free (command);
             }
         }
     }
 
     /* Text Represantation of this item */
-    cprint(BLUE, 1, s, "\n///// ITEM #%d /////\n", get_item_counter());
-    if(write_to_path != NULL) {
-        cprint(DEFAULT, 1, s, "WRITE to '%s'\n", write_to_path);
+    cprint (BLUE,1,s,"\n///// ITEM #%d /////\n",get_item_counter() );
+    if (write_to_path != NULL)
+    {
+        cprint (DEFAULT,1,s,"WRITE to '%s'\n",write_to_path);
         //g_free(write_to_path);
     }
 
-    if(s->verbosity > 0) {
-        glyr_cache_print(c);
+    if (s->verbosity > 0)
+    {
+        glyr_cache_print (c);
     }
-    cprint(BLUE, 1, s, "\n////////////////////\n");
+    cprint (BLUE,1,s,"\n////////////////////\n");
 
     return GLYRE_OK;
 }
@@ -653,25 +685,29 @@ static GLYR_ERROR callback(GlyrMemCache *c, GlyrQuery *s)
 // --------------------------------------------------------- //
 ////////////////////////////////////////////////////////////////
 
-GLYR_GET_TYPE get_type_from_string(const char *string)
+GLYR_GET_TYPE get_type_from_string (const char * string)
 {
     GLYR_GET_TYPE result = GLYR_GET_UNKNOWN;
-    if(g_ascii_strncasecmp(string, "none", 4) == 0) {
+    if (g_ascii_strncasecmp (string,"none",4) == 0)
         return GLYR_GET_ANY;
-    }
 
-    GlyrFetcherInfo *info = glyr_info_get();
-    if(info != NULL) {
-        for(GlyrFetcherInfo *elem = info; elem; elem = elem->next) {
-            if(g_ascii_strncasecmp(elem->name, string, strlen(elem->name)) == 0) {
+    GlyrFetcherInfo * info = glyr_info_get();
+    if (info != NULL)
+    {
+        for (GlyrFetcherInfo * elem = info; elem; elem = elem->next)
+        {
+            if (g_ascii_strncasecmp (elem->name,string,strlen (elem->name) ) == 0)
+            {
                 result = elem->type;
                 break;
             }
         }
-    } else {
-        cprint(DEFAULT, -1, NULL, "Warning: Can't get type information. Probably a bug.\n");
     }
-    glyr_info_free(info);
+    else
+    {
+        cprint (DEFAULT,-1,NULL,"Warning: Can't get type information. Probably a bug.\n");
+    }
+    glyr_info_free (info);
     return result;
 }
 
@@ -679,71 +715,75 @@ GLYR_GET_TYPE get_type_from_string(const char *string)
 // --------------------------------------------------------- //
 ////////////////////////////////////////////////////////////////
 
-static gint db_foreach_callback(GlyrQuery *q, GlyrMemCache *c, void *p)
+static gint db_foreach_callback (GlyrQuery * q, GlyrMemCache * c, void * p)
 {
-    puts("\n////////////////////////////////////\n");
-    cprint(DEFAULT, -1, NULL, "%s :: %s :: %s :: %s\n", q->artist, q->album, q->title, glyr_get_type_to_string(q->type));
-    glyr_cache_print(c);
+    puts ("\n////////////////////////////////////\n");
+    cprint (DEFAULT,-1,NULL,"%s :: %s :: %s :: %s\n",q->artist,q->album,q->title,glyr_get_type_to_string (q->type) );
+    glyr_cache_print (c);
 
-    int *i = p;
+    int * i = p;
     *i += 1;
     return 0;
 }
 
 //////////////////////////////////////
 
-static void do_iterate_over_db(GlyrDatabase *db)
+static void do_iterate_over_db (GlyrDatabase * db)
 {
     gint db_item_counter = 0;
-    glyr_db_foreach(db, db_foreach_callback, &db_item_counter);
-    cprint(DEFAULT, -1, NULL, "\n-----------------------------------\n");
-    cprint(DEFAULT, -1, NULL, "=> In total %d items in database.", db_item_counter);
-    cprint(DEFAULT, -1, NULL, "\n-----------------------------------\n");
-    cprint(DEFAULT, -1, NULL, "\n");
+    glyr_db_foreach (db,db_foreach_callback,&db_item_counter);
+    cprint (DEFAULT,-1,NULL,"\n-----------------------------------\n");
+    cprint (DEFAULT,-1,NULL,"=> In total %d items in database.",db_item_counter);
+    cprint (DEFAULT,-1,NULL,"\n-----------------------------------\n");
+    cprint (DEFAULT,-1,NULL,"\n");
 }
 
 //////////////////////////////////////
 
-static int do_cache_interface(const char *operation, GlyrQuery *q, GlyrDatabase *db, callback_data_t *cbdata)
+static int do_cache_interface (const char * operation, GlyrQuery * q, GlyrDatabase * db, callback_data_t * cbdata)
 {
     const char list_op[] = "list";
     const char slct_op[] = "select";
     const char dele_op[] = "delete";
 
-    g_assert(q);
+    g_assert (q);
 
-    if(db == NULL) {
-        cvprint(RED, "No database specified. Use --cache.\n");
+    if (db == NULL)
+    {
+        cvprint (RED,"No database specified. Use --cache.\n");
         return EXIT_FAILURE;
     }
 
     ////////////////////////////////
 
-    if(g_ascii_strncasecmp(operation, list_op, sizeof(list_op) - 1) == 0) {
-        do_iterate_over_db(db);
+    if (g_ascii_strncasecmp (operation,list_op,sizeof (list_op) - 1) == 0)
+    {
+        do_iterate_over_db (db);
         return EXIT_SUCCESS;
     }
 
     ////////////////////////////////
 
-    if(g_ascii_strncasecmp(operation, dele_op, sizeof(dele_op) - 1) == 0) {
-        int killed_items = glyr_db_delete(db, q);
-        cvprint(BLUE, "Deleted %d items from the db.", killed_items);
+    if (g_ascii_strncasecmp (operation,dele_op,sizeof (dele_op) - 1) == 0)
+    {
+        int killed_items = glyr_db_delete (db,q);
+        cvprint (BLUE,"Deleted %d items from the db.",killed_items);
         return killed_items > 0;
     }
 
     ////////////////////////////////
 
-    if(g_ascii_strncasecmp(operation, slct_op, sizeof(slct_op) - 1) == 0) {
-        GlyrMemCache *list = glyr_db_lookup(db, q);
-        GlyrMemCache *iter = list;
+    if (g_ascii_strncasecmp (operation,slct_op,sizeof (slct_op) - 1) == 0)
+    {
+        GlyrMemCache * list = glyr_db_lookup (db,q);
+        GlyrMemCache * iter = list;
 
         if(iter == NULL)  {
             return EXIT_FAILURE;
         }
 
         q->callback.user_pointer = cbdata;
-        while(iter != NULL) {
+        while (iter != NULL) {
             callback(iter, q);
             iter = iter->next;
         }
@@ -757,31 +797,36 @@ static int do_cache_interface(const char *operation, GlyrQuery *q, GlyrDatabase
 
 //////////////////////////////////////
 
-static bool parse_type_argument(const char *argvi, GlyrQuery *qp)
+static bool parse_type_argument (const char * argvi, GlyrQuery * qp)
 {
     bool retv = false;
 
-    g_assert(qp);
-
-    if(argvi != NULL) {
-        GLYR_GET_TYPE type = get_type_from_string(argvi);
-        if(type == GLYR_GET_UNKNOWN) {
-            cvprint(RED, "Error: \"%s\" is not a know getter.\n", argvi);
-            cvprint(DEFAULT, "Currently available are:\n");
-            GlyrFetcherInfo *info = glyr_info_get();
-            GlyrFetcherInfo *iter = info;
-            while(iter != NULL) {
-                cvprint(BLUE, "  * %s\n", iter->name);
+    g_assert (qp);
+
+    if (argvi != NULL)
+    {
+        GLYR_GET_TYPE type = get_type_from_string (argvi);
+        if (type == GLYR_GET_UNKNOWN)
+        {
+            cvprint (RED,"Error: \"%s\" is not a know getter.\n",argvi);
+            cvprint (DEFAULT,"Currently available are:\n");
+            GlyrFetcherInfo * info = glyr_info_get();
+            GlyrFetcherInfo * iter = info;
+            while (iter != NULL)
+            {
+                cvprint (BLUE,"  * %s\n",iter->name);
                 iter = iter->next;
             }
-            glyr_info_free(info);
+            glyr_info_free (info);
 
-            suggest_other_getter(qp, argvi);
-            cvprint(DEFAULT, "\nSee `glyrc -L` for a detailed list\n");
+            suggest_other_getter (qp,argvi);
+            cvprint (DEFAULT,"\nSee `glyrc -L` for a detailed list\n");
             retv = false;
 
-        } else {
-            glyr_opt_type(qp, type);
+        }
+        else
+        {
+            glyr_opt_type (qp,type);
             retv = true;
         }
     }
@@ -791,21 +836,21 @@ static bool parse_type_argument(const char *argvi, GlyrQuery *qp)
 
 //////////////////////////////////////
 
-static GlyrMemCache *concatenate_list(GlyrMemCache *list)
+static GlyrMemCache * concatenate_list (GlyrMemCache * list)
 {
-    if(list == NULL) {
+    if (list == NULL)
         return NULL;
-    }
 
-    GlyrMemCache *iter = list;
-    GlyrMemCache *retv = glyr_cache_copy(list);
-    gchar *concat_data = g_strdup("");
+    GlyrMemCache * iter = list;
+    GlyrMemCache * retv = glyr_cache_copy (list);
+    gchar * concat_data = g_strdup ("");
 
     retv->duration = 0;
 
-    while(iter != NULL) {
-        gchar *tmp = g_strdup_printf("%s%s\n", concat_data, iter->data);
-        g_free(concat_data);
+    while (iter != NULL)
+    {
+        gchar * tmp = g_strdup_printf ("%s%s\n",concat_data,iter->data);
+        g_free (concat_data);
         concat_data = tmp;
         retv->duration += iter->duration;
         iter = iter->next;
@@ -814,30 +859,30 @@ static GlyrMemCache *concatenate_list(GlyrMemCache *list)
     retv->next = NULL;
     retv->prev = NULL;
 
-    glyr_cache_set_data(retv, concat_data, -1);
-    glyr_free_list(list);
+    glyr_cache_set_data (retv,concat_data,-1);
+    glyr_free_list (list);
     return retv;
 }
 
 //////////////////////////////////////
 
-static void global_cleanup(void)
+static void global_cleanup (void)
 {
-    set_write_path(NULL);
+    set_write_path (NULL);
 }
 
 //////////////////////////////////////
 
-int main(int argc, char *argv[])
+int main (int argc, char * argv[])
 {
-    /* Set the loghandler (used by cprint(DEFAULT, ) */
-    g_log_set_handler(LOG_DOMAIN ,
-                      G_LOG_LEVEL_MASK |
-                      G_LOG_FLAG_FATAL |
-                      G_LOG_FLAG_RECURSION,
-                      log_func, NULL);
-
-    atexit(global_cleanup);
+    /* Set the loghandler (used by cprint(DEFAULT,)) */
+    g_log_set_handler (LOG_DOMAIN ,
+                       G_LOG_LEVEL_MASK |
+                       G_LOG_FLAG_FATAL |
+                       G_LOG_FLAG_RECURSION,
+                       log_func, NULL);
+
+    atexit (global_cleanup);
     init_signals();
 
     /* Assume failure, as always in life */
@@ -848,87 +893,112 @@ int main(int argc, char *argv[])
      * Both functions are not threadsafe!
      * */
     glyr_init();
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 
-    if(argc >= 2 && argv[1][0] != '-' && strcmp(argv[1], "cache") != 0) {
+    if (argc >= 2 && argv[1][0] != '-' && strcmp (argv[1],"cache") != 0)
+    {
         callback_data_t CBQueryData = INIT_CALLBACK_DATA;
-        GlyrDatabase *db = NULL;
+        GlyrDatabase * db = NULL;
         GlyrQuery my_query;
 
-        glyr_query_init(&my_query);
-        glyr_opt_verbosity(&my_query, 2);
+        glyr_query_init (&my_query);
+        glyr_opt_verbosity (&my_query,2);
 
-        init_cancel_handler(&my_query);
+        init_cancel_handler (&my_query);
 
-        if(parse_type_argument(argv[1], &my_query)) {
+        if (parse_type_argument (argv[1],&my_query) )
+        {
             int length = -1;
             GLYR_ERROR get_error = GLYRE_OK;
 
-            parse_commandline_general(argc - 1, argv + 1, &my_query, &CBQueryData, &db);
-            SET_IF_NULL(CBQueryData.output_path, ".");
+            parse_commandline_general (argc-1, argv+1, &my_query,&CBQueryData,&db);
+            SET_IF_NULL (CBQueryData.output_path,".");
 
-            if(CBQueryData.as_one == false || glyr_type_is_image(my_query.type)) {
-                glyr_opt_dlcallback(&my_query, callback, &CBQueryData);
+            if (CBQueryData.as_one == false || glyr_type_is_image (my_query.type) )
+            {
+                glyr_opt_dlcallback (&my_query, callback, &CBQueryData);
             }
 
             /* Doing the 'hard' work here. */
-            GlyrMemCache *my_list = glyr_get(&my_query, &get_error, &length);
+            GlyrMemCache * my_list = glyr_get (&my_query, &get_error, &length);
 
-            if(my_list != NULL) {
+            if (my_list != NULL)
+            {
                 exit_code = EXIT_SUCCESS;
 
-                if(CBQueryData.as_one && glyr_type_is_image(my_query.type) == false) {
-                    GlyrMemCache *concat = concatenate_list(my_list);
-                    glyr_opt_dlcallback(&my_query, callback, &CBQueryData);
-                    callback(concat, &my_query);
+                if (CBQueryData.as_one && glyr_type_is_image (my_query.type) == false)
+                {
+                    GlyrMemCache * concat = concatenate_list (my_list);
+                    glyr_opt_dlcallback (&my_query, callback, &CBQueryData);
+                    callback (concat,&my_query);
 
-                    glyr_cache_free(concat);
-                } else {
+                    glyr_cache_free (concat);
+                }
+                else
+                {
                     /* Free all downloaded buffers */
-                    glyr_free_list(my_list);
-                    cprint(YELLOW, 2, &my_query, "# => %d item%s in total.\n", length, length == 1 ? "" : "s");
+                    glyr_free_list (my_list);
+                    cprint (YELLOW,2,&my_query,"# => %d item%s in total.\n",length,length == 1 ? "" : "s");
                 }
-            } else if(get_error == GLYRE_NO_PROVIDER) {
-                cvprint(RED, "Error `--from %s` does not contain any valid provider.\n", my_query.from);
-                cvprint(RED, "      See `glyrc -L` for a list.\n");
-                suggest_other_provider(&my_query, my_query.from);
-            } else if(get_error != GLYRE_OK) {
-                cprint(RED, 1, &my_query, "Error: %s\n", glyr_strerror(get_error));
+            }
+            else if (get_error == GLYRE_NO_PROVIDER)
+            {
+                cvprint (RED,"Error `--from %s` does not contain any valid provider.\n",my_query.from);
+                cvprint (RED,"      See `glyrc -L` for a list.\n");
+                suggest_other_provider (&my_query,my_query.from);
+            }
+            else if (get_error != GLYRE_OK)
+            {
+                cprint (RED,1,&my_query,"Error: %s\n",glyr_strerror (get_error) );
             }
         }
 
-        glyr_db_destroy(db);
-        glyr_query_destroy(&my_query);
-    } else if(argc >= 2 && strcmp(argv[1], "cache") == 0) {
-        if(argc >= 3) {
+        glyr_db_destroy (db);
+        glyr_query_destroy ( &my_query);
+    }
+    else if (argc >= 2 && strcmp (argv[1],"cache") == 0)
+    {
+        if (argc >= 3)
+        {
             GlyrQuery db_query;
-            GlyrDatabase *db = NULL;
+            GlyrDatabase * db = NULL;
             callback_data_t CBQueryData = INIT_CALLBACK_DATA;
-            SET_IF_NULL(CBQueryData.output_path, ".");
+            SET_IF_NULL (CBQueryData.output_path,".");
 
-            glyr_query_init(&db_query);
-            glyr_opt_verbosity(&db_query, 2);
+            glyr_query_init (&db_query);
+            glyr_opt_verbosity (&db_query,2);
 
-            if(argc >= 4 && strcmp("list", argv[2]) != 0) {
-                parse_type_argument(argv[3], &db_query);
+            if (argc >= 4 && strcmp("list", argv[2]) != 0)
+            {
+                parse_type_argument (argv[3],&db_query);
             }
 
-            parse_commandline_general(argc - 2, argv + 2, &db_query, &CBQueryData, &db);
-            do_cache_interface(argv[2], &db_query, db, &CBQueryData);
-        } else {
-            cvprint(RED, "Error: 'cache': needs another argument:\n");
-            cvprint(RED, "  * select [opts]\n");
-            cvprint(RED, "  * delete [opts]\n");
-            cvprint(RED, "  * list\n");
+            parse_commandline_general (argc-2, argv+2,&db_query,&CBQueryData,&db);
+            do_cache_interface (argv[2],&db_query,db, &CBQueryData);
+        }
+        else
+        {
+            cvprint (RED,"Error: 'cache': needs another argument:\n");
+            cvprint (RED,"  * select [opts]\n");
+            cvprint (RED,"  * delete [opts]\n");
+            cvprint (RED,"  * list\n");
         }
-    } else if(argc >= 2 && (!strcmp(argv[1], "-U") || !strcmp(argv[1], "--update"))) {
+    }
+    else if (argc >= 2 && (!strcmp (argv[1],"-U") || !strcmp (argv[1],"--update") ) )
+    {
         update();
-    } else if(argc >= 2 && (!strcmp(argv[1], "-V") || !strcmp(argv[1], "--version"))) {
-        print_version(NULL);
-    } else if(argc >= 2 && (!strcmp(argv[1], "-L") || !strcmp(argv[1], "--list"))) {
+    }
+    else if (argc >= 2 && (!strcmp (argv[1],"-V") || !strcmp (argv[1],"--version") ) )
+    {
+        print_version (NULL);
+    }
+    else if (argc >= 2 && (!strcmp (argv[1],"-L") || !strcmp (argv[1],"--list") ) )
+    {
         visualize_from_options();
-    } else {
-        help_short(NULL);
+    }
+    else
+    {
+        help_short (NULL);
     }
 
     return exit_code;
diff --git a/src/glyrc/update.c b/src/glyrc/update.c
index 2651638..e8f2bb7 100644
--- a/src/glyrc/update.c
+++ b/src/glyrc/update.c
@@ -30,23 +30,26 @@
 
 /////////////////////////////////
 
-static gboolean check_version(gboolean *errord)
+static gboolean check_version (gboolean * errord)
 {
     gboolean result = FALSE;
     GlyrQuery q;
-    glyr_query_init(&q);
-    glyr_opt_verbosity(&q, 3);
+    glyr_query_init (&q);
+    glyr_opt_verbosity (&q,3);
 
-    GlyrMemCache *version_page = glyr_download(GLYR_VERSION_URL, &q);
-    if(version_page != NULL && version_page->data != NULL) {
-        glong version = strtol(version_page->data, NULL, 10);
+    GlyrMemCache * version_page = glyr_download (GLYR_VERSION_URL,&q);
+    if (version_page != NULL && version_page->data != NULL)
+    {
+        glong version = strtol (version_page->data,NULL,10);
         glong current = GLYR_VERSION_MAJOR_INT * 100 + GLYR_VERSION_MINOR_INT * 10 + GLYR_VERSION_MICRO_INT;
         result = (version > current);
-    } else {
+    }
+    else
+    {
         *errord = TRUE;
     }
 
-    glyr_query_destroy(&q);
+    glyr_query_destroy (&q);
     return result;
 }
 
@@ -78,18 +81,24 @@ static gboolean check_version(gboolean *errord)
 /********************************************************************/
 
 
-void update(void)
+void update (void)
 {
     gboolean error = FALSE;
-    if(check_version(&error)) {
-        g_printerr("Updating:\n");
-        if(system(UPDATE_SCRIPT) == -1) {
-            g_printerr("Warning: the script returned a bad exitstatus.\n");
+    if (check_version (&error) )
+    {
+        g_printerr ("Updating:\n");
+        if (system (UPDATE_SCRIPT) == -1)
+        {
+            g_printerr ("Warning: the script returned a bad exitstatus.\n");
         }
-    } else if(error) {
-        g_printerr("Error while updating.\n");
-    } else {
-        g_printerr("No updates found.\n");
+    }
+    else if (error)
+    {
+        g_printerr ("Error while updating.\n");
+    }
+    else
+    {
+        g_printerr ("No updates found.\n");
     }
 }
 
diff --git a/src/utils/clean_db.c b/src/utils/clean_db.c
index 5e6a260..45485d2 100644
--- a/src/utils/clean_db.c
+++ b/src/utils/clean_db.c
@@ -6,47 +6,56 @@
 
 static bool do_delete = false;
 
-static int foreach_callback(GlyrQuery *q, GlyrMemCache *item, void *userptr)
+static int foreach_callback (GlyrQuery *q, GlyrMemCache *item, void *userptr)
 {
-    GlyrDatabase *db = (GlyrDatabase *) userptr;
+    GlyrDatabase * db = (GlyrDatabase*) userptr;
 
-    g_assert(item);
-    g_assert(db);
+    g_assert (item);
+    g_assert (db);
 
-    if(item->rating == -1) {
-        g_printerr("----------------\n");
-        glyr_cache_print(item);
+    if (item->rating == -1)
+    {
+        g_printerr ("----------------\n");
+        glyr_cache_print (item);
 
-        if(do_delete) {
-            glyr_db_delete(db, q);
+        if (do_delete)
+        {
+            glyr_db_delete (db,q);
         }
     }
 
     return 0;
 }
 
-int main(int argc, char const *argv[])
+int main (int argc, char const *argv[])
 {
 
     glyr_init();
-    atexit(glyr_cleanup);
+    atexit (glyr_cleanup);
 
-    if(argc > 1) {
+    if (argc > 1)
+    {
 
-        GlyrDatabase *db = glyr_db_init(argv[1]);
-        if(db != NULL) {
+        GlyrDatabase * db = glyr_db_init (argv[1]);
+        if (db != NULL)
+        {
 
-            if(argv[2] != NULL && strcmp(argv[2], "delete") == 0) {
+            if (argv[2] != NULL && strcmp (argv[2],"delete") == 0)
+            {
                 do_delete = true;
             }
 
-            glyr_db_foreach(db, foreach_callback, db);
-        } else {
-            g_message("Could not open DB at %s", argv[1]);
+            glyr_db_foreach (db,foreach_callback,db);
         }
-    } else {
+        else
+        {
+            g_message ("Could not open DB at %s",argv[1]);
+        }
+    }
+    else
+    {
 
-        g_message("Usage: %s /path/to/db/directory [delete]", argv[0]);
+        g_message ("Usage: %s /path/to/db/directory [delete]",argv[0]);
     }
     return EXIT_SUCCESS;
 }
diff --git a/src/utils/guess_lang.c b/src/utils/guess_lang.c
index 06dabf2..2fe72a5 100644
--- a/src/utils/guess_lang.c
+++ b/src/utils/guess_lang.c
@@ -23,73 +23,82 @@
 #include <glib.h>
 #include <string.h>
 
-const gchar *map_language[][2] = {
-    {"en_US", "us"},
-    {"en_CA", "ca"},
-    {"en_UK", "uk"}
+const gchar * map_language[][2] =
+{
+    {"en_US","us"},
+    {"en_CA","ca"},
+    {"en_UK","uk"}
 };
 
-#define END_STRING(STR, HAR) {gchar * term = strchr(STR, HAR); if(term) *term = 0;}
+#define END_STRING(STR,CHAR) {gchar * term = strchr(STR,CHAR); if(term) *term = 0;}
 
 /**
 * @brief Guesses the users language (in ISO639-1 codes like 'de') by the system locale
 *
 * @return a newly allocated language code. Free.
 */
-gchar *guess_lang(void)
+gchar * guess_lang (void)
 {
     /* Default to 'en' in any case */
-    gchar *result_lang = g_strdup("en");
+    gchar * result_lang = g_strdup ("en");
 
-#if GLIB_CHECK_VERSION(2, 8, )
+#if GLIB_CHECK_VERSION(2,28,0)
     gboolean break_out = FALSE;
 
     /* Please never ever free this */
-    const gchar *const *languages = g_get_language_names();
+    const gchar * const * languages = g_get_language_names();
 
-    for(gint i = 0; languages[i] && break_out == FALSE; i++) {
-        gchar **variants = g_get_locale_variants(languages[i]);
-        for(gint j = 0; variants[j] && !break_out; j++) {
+    for (gint i = 0; languages[i] && break_out == FALSE; i++)
+    {
+        gchar ** variants = g_get_locale_variants (languages[i]);
+        for (gint j = 0; variants[j] && !break_out; j++)
+        {
             /* Look up if we need to map a language */
-            gchar *to_investigate = variants[j];
-            gint map_size = (sizeof(map_language) / (2 * sizeof(char *)));
-            for(gint map = 0; map < map_size; map++) {
-                const gchar *to_map = map_language[map][0];
-                gsize map_len  = strlen(to_map);
-                if(g_ascii_strncasecmp(to_map, to_investigate, map_len) == 0) {
-                    to_investigate = (gchar *) map_language[map][1];
-                    g_print("Mapping language to %s\n", to_investigate);
+            gchar * to_investigate = variants[j];
+            gint map_size = (sizeof (map_language) / (2 * sizeof (char*) ) );
+            for (gint map = 0; map < map_size; map++)
+            {
+                const gchar * to_map = map_language[map][0];
+                gsize map_len  = strlen (to_map);
+                if (g_ascii_strncasecmp (to_map,to_investigate,map_len) == 0)
+                {
+                    to_investigate = (gchar*) map_language[map][1];
+                    g_print ("Mapping language to %s\n",to_investigate);
                     break;
                 }
             }
 
             gboolean allowed_lang = TRUE;
 
-            if(allowed_lang &&
-                    g_ascii_strncasecmp("en", to_investigate, 2) != 0 &&
-                    g_ascii_strncasecmp("C", to_investigate, 1) != 0 &&
-                    !strchr(to_investigate, '@') && !strchr(to_investigate, '.')) {
-                g_free(result_lang);
-                result_lang = g_strdup(to_investigate);
+            if (allowed_lang &&
+                    g_ascii_strncasecmp ("en",to_investigate,2) != 0 &&
+                    g_ascii_strncasecmp ("C", to_investigate,1) != 0 &&
+                    !strchr (to_investigate,'@') && !strchr (to_investigate,'.') )
+            {
+                g_free (result_lang);
+                result_lang = g_strdup (to_investigate);
                 break_out = TRUE;
             }
         }
-        g_strfreev(variants);
+        g_strfreev (variants);
     }
 
-#elif GLIB_CHECK_VERSION(2, 6, )
+#elif GLIB_CHECK_VERSION(2,26,0)
 
     /* Fallback to simpler version of the above,
          * g_get_locale_variants is not there in this version
          */
-    const gchar *const *possible_locales = g_get_language_names();
-    if(possible_locales != NULL) {
+    const gchar * const * possible_locales = g_get_language_names();
+    if (possible_locales != NULL)
+    {
         /* might be a bit weird */
-        for(gint i = 0; possible_locales[i]; i++) {
-            if(g_ascii_strncasecmp("en", possible_locales[i], 2) != 0 &&
-                    g_ascii_strncasecmp("C", possible_locales[i], 1) != 0) {
-                g_free(result_lang);
-                result_lang = g_strdup(possible_locales[i]);
+        for (gint i = 0; possible_locales[i]; i++)
+        {
+            if (g_ascii_strncasecmp ("en",possible_locales[i],2) != 0 &&
+                    g_ascii_strncasecmp ("C", possible_locales[i],1) != 0)
+            {
+                g_free (result_lang);
+                result_lang = g_strdup (possible_locales[i]);
                 break;
             }
         }
@@ -99,13 +108,13 @@ gchar *guess_lang(void)
      * Fallback to "en" always.
      * Gaaah... shame on you if this happens to you ;-)
      */
-    puts("GLib version 2.28 is needed to execute this properly.");
+    puts ("GLib version 2.28 is needed to execute this properly.");
 #endif
 
     /* Properly terminate string */
-    END_STRING(result_lang, '_');
-    END_STRING(result_lang, '@');
-    END_STRING(result_lang, '.');
+    END_STRING (result_lang,'_');
+    END_STRING (result_lang,'@');
+    END_STRING (result_lang,'.');
 
     /* We don't need it anymore */
 #undef END_STRING
@@ -113,12 +122,13 @@ gchar *guess_lang(void)
     return result_lang;
 }
 
-int main(int argc, const char *argv[])
+int main (int argc, const char *argv[])
 {
-    gchar *lang = guess_lang();
-    if(lang != NULL) {
-        puts(lang);
-        g_free(lang);
+    gchar * lang = guess_lang();
+    if (lang != NULL)
+    {
+        puts (lang);
+        g_free (lang);
     }
     return 0;
 }
diff --git a/src/utils/ping_url.c b/src/utils/ping_url.c
index 088deff..52f6e3c 100644
--- a/src/utils/ping_url.c
+++ b/src/utils/ping_url.c
@@ -28,58 +28,68 @@
 
 /* Simple testprogram to check the content-type header of any website given on the cmd. */
 
-struct header_data {
-    gchar *type;
-    gchar *format;
-    gchar *extra;
+struct header_data
+{
+    gchar * type;
+    gchar * format;
+    gchar * extra;
 };
 
 /* Parse header file. Get Contenttype from it and save it in the header_data struct */
-gsize header_cb(void *ptr, gsize size, gsize nmemb, void *userdata)
+gsize header_cb (void *ptr, gsize size, gsize nmemb, void *userdata)
 {
     gsize bytes = size * nmemb;
-    if(ptr != NULL && userdata != NULL) {
+    if (ptr != NULL && userdata != NULL)
+    {
         /* Transform safely into string */
         gchar nulbuf[bytes + 1];
-        memcpy(nulbuf, ptr, bytes);
+        memcpy (nulbuf,ptr,bytes);
         nulbuf[bytes] = '\0';
 
         /* We're only interested in the content type */
-        gchar *cttp  = "Content-Type: ";
-        gsize ctt_len = strlen(cttp);
-        if(ctt_len < bytes && g_ascii_strncasecmp(cttp, nulbuf, ctt_len) == 0) {
-            gchar **content_type = g_strsplit_set(nulbuf + ctt_len, " /;", 0);
-            if(content_type != NULL) {
+        gchar * cttp  = "Content-Type: ";
+        gsize ctt_len = strlen (cttp);
+        if (ctt_len < bytes && g_ascii_strncasecmp (cttp,nulbuf,ctt_len) == 0)
+        {
+            gchar ** content_type = g_strsplit_set (nulbuf + ctt_len," /;",0);
+            if (content_type != NULL)
+            {
                 gsize set_at = 0;
-                gchar **elem = content_type;
-                struct header_data *info = userdata;
+                gchar ** elem = content_type;
+                struct header_data * info = userdata;
 
                 /* Set fields..  */
-                while(elem[0] != NULL) {
-                    if(elem[0][0] != '\0') {
-                        switch(set_at) {
+                while (elem[0] != NULL)
+                {
+                    if (elem[0][0] != '\0')
+                    {
+                        switch (set_at)
+                        {
                         case 0:
-                            g_free(info->type);
-                            info->type   = g_strdup(elem[0]);
+                            g_free (info->type);
+                            info->type   = g_strdup (elem[0]);
                             break;
                         case 1:
-                            g_free(info->format);
-                            if(g_ascii_strncasecmp(elem[0], "octet-stream", 12) == 0) {
-                                info->format = g_strdup("jpeg");
-                            } else {
-                                info->format = g_strdup(elem[0]);
+                            g_free (info->format);
+                            if (g_ascii_strncasecmp (elem[0],"octet-stream",12) == 0)
+                            {
+                                info->format = g_strdup ("jpeg");
+                            }
+                            else
+                            {
+                                info->format = g_strdup (elem[0]);
                             }
                             break;
                         case 2:
-                            g_free(info->extra);
-                            info->extra  = g_strdup(elem[0]);
+                            g_free (info->extra);
+                            info->extra  = g_strdup (elem[0]);
                             break;
                         }
                         set_at++;
                     }
                     elem++;
                 }
-                g_strfreev(content_type);
+                g_strfreev (content_type);
             }
         }
     }
@@ -87,18 +97,21 @@ gsize header_cb(void *ptr, gsize size, gsize nmemb, void *userdata)
 }
 
 /* just prevent writing header to stdout */
-gsize empty_cb(void *p, gsize s, gsize n, void *u)
+gsize empty_cb (void * p, gsize s, gsize n, void * u)
 {
-    return s * n;
+    return s*n;
 };
 
 
-void chomp_breakline(gchar *string)
+void chomp_breakline (gchar * string)
 {
-    if(string != NULL) {
-        gsize len = strlen(string);
-        while(--len != 0) {
-            if(string[len] == '\n') {
+    if (string != NULL)
+    {
+        gsize len = strlen (string);
+        while (--len != 0)
+        {
+            if (string[len] == '\n')
+            {
                 string[len] = '\0';
                 break;
             }
@@ -106,61 +119,69 @@ void chomp_breakline(gchar *string)
     }
 }
 
-static struct header_data *url_is_gettable(gchar *url)
+static struct header_data * url_is_gettable (gchar * url)
 {
-    struct header_data *info = NULL;
-    if(url != NULL) {
-        CURL *eh = curl_easy_init();
+    struct header_data * info = NULL;
+    if (url != NULL)
+    {
+        CURL * eh = curl_easy_init();
         CURLcode rc = CURLE_OK;
 
-        info = g_malloc0(sizeof(struct header_data));
+        info = g_malloc0 (sizeof (struct header_data) );
 
-        curl_easy_setopt(eh, CURLOPT_TIMEOUT, 3);
-        curl_easy_setopt(eh, CURLOPT_NOSIGNAL, 1L);
-        curl_easy_setopt(eh, CURLOPT_USERAGENT, GLYR_DEFAULT_USERAGENT"/linkvalidator");
-        curl_easy_setopt(eh, CURLOPT_URL, url);
-        curl_easy_setopt(eh, CURLOPT_FOLLOWLOCATION, TRUE);
-        curl_easy_setopt(eh, CURLOPT_HEADER, TRUE);
-        curl_easy_setopt(eh, CURLOPT_NOBODY, TRUE);
-        curl_easy_setopt(eh, CURLOPT_HEADERFUNCTION, header_cb);
-        curl_easy_setopt(eh, CURLOPT_WRITEFUNCTION, empty_cb);
-        curl_easy_setopt(eh, CURLOPT_WRITEHEADER, info);
+        curl_easy_setopt (eh, CURLOPT_TIMEOUT, 3);
+        curl_easy_setopt (eh, CURLOPT_NOSIGNAL, 1L);
+        curl_easy_setopt (eh, CURLOPT_USERAGENT, GLYR_DEFAULT_USERAGENT"/linkvalidator");
+        curl_easy_setopt (eh, CURLOPT_URL,url);
+        curl_easy_setopt (eh, CURLOPT_FOLLOWLOCATION, TRUE);
+        curl_easy_setopt (eh, CURLOPT_HEADER,TRUE);
+        curl_easy_setopt (eh, CURLOPT_NOBODY,TRUE);
+        curl_easy_setopt (eh, CURLOPT_HEADERFUNCTION, header_cb);
+        curl_easy_setopt (eh, CURLOPT_WRITEFUNCTION, empty_cb);
+        curl_easy_setopt (eh, CURLOPT_WRITEHEADER, info);
 
-        curl_easy_setopt(eh, CURLOPT_VERBOSE, TRUE);
+        curl_easy_setopt (eh, CURLOPT_VERBOSE,TRUE);
 
-        rc = curl_easy_perform(eh);
-        curl_easy_cleanup(eh);
+        rc = curl_easy_perform (eh);
+        curl_easy_cleanup (eh);
 
-        if(rc != CURLE_OK) {
-            g_printerr("glyr: ping: E: %s [%d]\n", curl_easy_strerror(rc), rc);
-            g_free(info);
+        if (rc != CURLE_OK)
+        {
+            g_printerr ("glyr: ping: E: %s [%d]\n",curl_easy_strerror (rc),rc);
+            g_free (info);
             info = NULL;
 
-        } else {
-            chomp_breakline(info->type);
-            chomp_breakline(info->format);
-            chomp_breakline(info->extra);
+        }
+        else
+        {
+            chomp_breakline (info->type);
+            chomp_breakline (info->format);
+            chomp_breakline (info->extra);
         }
     }
     return info;
 }
 
-int main(int argc, char *argv[])
+int main (int argc, char * argv[])
 {
-    curl_global_init(CURL_GLOBAL_ALL);
-    if(argc > 1) {
-        struct header_data *info;
-        if((info = url_is_gettable(argv[1])) != NULL) {
-            g_print("Type  :  %s\n", info->type);
-            g_print("Format:  %s\n", info->format);
-            g_print("Extra :  %s\n", info->extra);
-
-            g_free(info->type);
-            g_free(info->format);
-            g_free(info->extra);
-            g_free(info);
-        } else {
-            g_print("Unexists.\n");
+    curl_global_init (CURL_GLOBAL_ALL);
+    if (argc > 1)
+    {
+        struct header_data * info;
+        if ( (info = url_is_gettable (argv[1]) ) != NULL)
+        {
+            g_print ("Type  :  %s\n",info->type);
+            g_print ("Format:  %s\n",info->format);
+            g_print ("Extra :  %s\n",info->extra);
+
+            g_free (info->type);
+            g_free (info->format);
+            g_free (info->extra);
+            g_free (info);
+        }
+        else
+        {
+            g_print ("Unexists.\n");
         }
     }
     curl_global_cleanup();
